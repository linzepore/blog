[{"title":"23-02-22","url":"/2023/02/22/2023-02-22.html/","content":"23-02-22方法的顺序function name(参数列表) 可见性 修饰符 returns(返回类型 返回值名称)\n除了 Solidity 0.5.0 版本之前可见性和返回参数的位置可以交换外，从 Solidity 0.5.0 版本开始，函数声明必须按照以下顺序：\nfunction functionName(parameterList) visibilityModifier stateMutabilityModifier virtualModifier overrideModifier returns (returnTypes)\n\n这些部分应该按照以下顺序进行：\n\n函数名称\n参数列表\n可见性修饰符（public、external、internal 或 private）\n状态变更修饰符（pure、view、payable 或不包含修饰符）\n虚拟修饰符（virtual 或不包含修饰符）\n覆盖修饰符（override 或不包含修饰符）\n返回值列表\n\n全局变量\n函数可见性（大）与变量作用域（小）修饰符函数可见性指的的范围会比较大，而变量作用域指的东西少一些（external不在变量作用域范畴，不能作用于变量）\npublicPublic – 公共状态变量可以在内部访问，也可以通过消息访问。对于公共状态变量，将生成一个自动getter函数。\ninternalInternal – 内部状态变量只能从当前合约或其派生合约内访问。\nprivatePrivate – 私有状态变量只能从当前合约内部访问，派生合约 内不能访问。\nexternal修饰为External的函数 — 只能通过三种种方式：一—是通过继承&#x2F;合同内其他函数的this进行调用&#x2F;二是this（&#x3D;&#x3D;合约地址调用外部函数）&#x2F;三是通过交易发送\nthis.foo() 在 Solidity 中确实也是 external 的调用方式，因为 this 关键字指的是当前合约的地址，通过它来调用合约中的函数等价于通过外部地址调用合约中的函数。\n合同状态在 Solidity 中，合约的状态（State）是指合约在任意时刻所有的状态变量的集合。这些状态变量可以是各种类型的变量，包括 uint、address、bool、mapping 等。\n状态变更修饰符状态变更修饰符包括 pure、view 和 payable 三种：\n\nview 修饰符表示函数不会修改合约状态，只读取合约状态变量的值。因此，view 函数在调用过程中不会消耗 gas，可以免费调用，即使在未来的某个时候也可以免费调用。\n\npure 修饰符表示函数不会读取或修改合约状态，只执行计算并返回结果。因此，pure 函数在调用过程中不会消耗 gas，可以免费调用，即使在未来的某个时候也可以免费调用。\n\npayable 修饰符表示函数可以接收以太币，并且会修改合约状态。在调用 payable 函数时，调用者必须发送足够的以太币来支付函数执行所需的 gas 费用和转账金额。因此，payable 函数在调用过程中会消耗 gas，调用者需要支付 gas 费用，而且调用者发送的以太币会被转移到合约地址。\n\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-23","url":"/2023/02/23/2023-02-23.html/","content":"2023-02-23学习资源\nYoutube - 二十分钟学习solidity\n\nSolidity例子练习\n\n\n自定义修饰符定义一个自定义修饰符，使用 modifier 关键字，然后在花括号内编写对应的逻辑，例如：\nmodifier onlyOwner() &#123;    require(msg.sender == owner, &quot;Only owner can execute this function&quot;);    _; // 占位符&#125;function withdraw(uint amount) public onlyOwner &#123;    // 只有 owner 能够调用这个函数    // 执行提现逻辑&#125;\n在这个实现中，我们使用 require 函数来检查当前交易的发送者地址是否与合约的拥有者地址相等，如果不相等，则会抛出一个错误信息并终止操作。如果相等，则会继续执行原来的操作。\n货币单位\n\n1 wei &#x3D;&#x3D; 1\n1 gwei &#x3D;&#x3D; 1*10^9\n1 ether &#x3D;&#x3D; 1*10^18\n\n！注意：数值与单位之间要用空格隔开\n字节数组有个概念要记一下：? 字（word）与字节（byte）、位（bit） ?：一个字节有8位，常见的例子有一个电脑多少位，它的字就有多少位\n32位计算机：1字&#x3D;32位&#x3D;4字节，64位计算机：1字&#x3D;64位&#x3D;8字节\nbytes——动态版bytes bb;    function bt() public &#123;        bb.push(0x11);        bb.push(0x12);        bb.push(0x44);    &#125;\nbytesX——固定版以太坊虚拟机是256位的，一个字就是256位那么X为多少就表示需要多少字，然后转换成十六进制bytes1 byt1 = 0x11;bytes2 byt2 = 0x2222;bytes3 byt3 = 0x333333;bytes4 byt4 = 0xFFFFFFFF;//最大bytes1 bytMIN = 0x00;···\n\n一个神奇的案例contract byt &#123;    bytes2 sm = 0x5b33;    function plus256 public returns(bytes3) &#123;        return sm;//returns 0x5b3300    &#125;    function isPlus256 public returns(bool) &#123;        return 0x5b0000/(256*256) == sm;    &#125;    function plus256 public returns(bytes2) &#123;        return sm;//error    &#125;&#125;\n\nuint跟int的极限代码：\nint minInt = type(int).min;int maxInt = type(int).max;uint minU = type(uint).min;uint maxU = type(uint).max;\n\n输出结果\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-24","url":"/2023/02/24/2023-02-24.html/","content":"2023-02-24两种常量修饰符constantconstant修饰的变量必须要初始化，并且不可以被修改\ncontract cons &#123;    address public constant addr = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;    function tryToChange() public &#123;        //addr = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;//error    &#125;&#125;\n\nimmutableimmutable修饰的变量不需要初始化，同样不可以被修改但必须在构造函数中进行初始化\npragma solidity ^0.8.17;//SPDX-License-Identifier: MITcontract immu &#123;    address private immutable immu1 ;    uint private immutable myUInt;    constructor(uint uI) &#123;        immu1 = msg.sender;        myUInt = uI;    &#125;&#125;\n\ngetter方法必须声明为view//SPDX-License-Identifier:MITpragma solidity ^0.8.17;contract stateV &#123;    uint public num;    function get() public view returns(uint)&#123;        return num;    &#125;    function set(uint n) public &#123;        num = n;    &#125;&#125;\ngas 与 gas limitpragma solidity ^0.8.17;//SPDX-License-Identifier: MITcontract gasAbout &#123;    int public i = 0;    // 花光准备的gas会导致交易失败    // 状态改变会回退    // gas不会退款    function g() public &#123;        //循环到花光所限制的gas，交易失败，i不会发生改变        while(true) &#123;            ++i;        &#125;    &#125;&#125;\n\n参考-&gt;Gas\nGasHow much ether do you need to pay for a transaction?You pay gas spent * gas price amount of ether, where\n\ngas is a unit of computation\ngas spent is the total amount of gas used in a transaction\ngas price is how much ether you are willing to pay per gas\n\nTransactions with higher gas price have higher priority to be included in a block.\nUnspent gas will be refunded.\nGas LimitThere are 2 upper bounds to the amount of gas you can spend\n\ngas limit (max amount of gas you’re willing to use for your transaction, set by you)\n\nblock gas limit (max amount of gas allowed in a block, set by the network)\n\n\n试着依靠自己的理解，翻译一下：\nGas一个交易需要支付多少？我们需要支付的以太币为 `Gas花费数量`*`Gas单价`，其中：- Gas是计算单位- Gas Spent是一个交易中花费的Gas数- Gas Price是你愿意为每个Gas支付的价格在区块中，更高的Gas单价具有更高的优先级多出的Gas会被退回Gas Limit对于我们花费gas的总数有两个上限- Gas Limit（自己设置的愿意交易Gas花费最大`数量`限额）- Block Gas Limit（网络设置的区块Gas花费最大`数量`限额）\n\nMap//SPDX-License-Identifier:MITpragma solidity ^0.8.17;contract Mapping &#123;    mapping(address =&gt; uint) public myMap;    function get(address _addr) public view returns (uint) &#123;        return myMap[_addr];    &#125;    function set(address _addr, uint _i) public &#123;        myMap[_addr] = _i;    &#125;    function remove(address _addr) public  &#123;        delete myMap[_addr];    &#125;&#125;contract NestedMapping &#123;    mapping(address =&gt; mapping(uint=&gt;bool)) public nested;    function get(address _addr, uint _ui) public view returns(bool) &#123;        return nested[_addr][_ui];    &#125;    function set(address _addr, uint _ui, bool _bool) public &#123;        nested[_addr][_ui] = _bool;    &#125;    function remove(address _addr, uint _ui) public &#123;        delete nested[_addr][_ui];    &#125;&#125;\n\n数组简单例子pragma solidity ^0.8.17;//SPDX-License-Identifier: UNLICENSEDcontract Array &#123;    uint[] public arr ;    uint[] public arr2 = [1, 2, 3];    uint[10] public arr3;    function get(uint i) public view returns (uint)&#123;        return arr[i];    &#125;    function getArr() public view returns (uint[] memory) &#123;        return arr;    &#125;    function push(uint i) public &#123;        arr.push(i);    &#125;    function pop()public &#123;    //pop会相应减少长度        arr.pop();    &#125;    function getLength() public view returns(uint)&#123;        return arr.length;    &#125;    function remove(uint index) public &#123;    //delete只删除相应索引上的值        delete arr[index];    &#125;    function examples() external &#123;        uint[] memory a = new uint[](5);//只能生成固定长度    &#125;    &#125;\n\n删除元素与Java不同的是，solidity没有现成方法来调用进行删除某一索引上的元素，比如自行定义函数\n方法一（能保留原有顺序）：pragma solidity ^0.8.17;// SPDX-License-Identifier: MITcontract arrShift1 &#123;uint[] public arr;function remove(uint _index) public &#123;require(_index &lt; arr.length, &quot;index out of bound&quot;);for(uint i = _index; i &lt; arr.length-1; i++) &#123;arr[i] = arr[i+1];&#125;arr.pop();//自要删除的元素起，后面每一元素覆盖前面，然后删除最后的值&#125;function test() external &#123;arr = [1,2,3,4,5];remove(2);assert(arr[0] == 1);assert(arr[1] == 2);assert(arr[2] == 4);assert(arr[3] == 5);assert(arr.length == 4);        arr = [1];        remove(0);        assert(arr.length == 0);    &#125;&#125;\n方法二（简单粗暴，直接替换）：pragma solidity ^0.8.17;//SPDX-License-Identifier:mitcontract arrReplace &#123;    uint[] public arr;    function arrRepl(uint _index) public &#123;        arr[_index] = arr[arr.length-1];        arr.pop();    &#125;    function test() public&#123;        arr = [1,2,3,4,5];        arrRepl(2);        assert(arr[0]==1);        assert(arr[1]==2);        assert(arr[2]==5);        assert(arr[3]==4);        assert(arr.length==4);    &#125;&#125;\n\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-25","url":"/2023/02/25/2023-02-25.html/","content":"2023-02-25Enum 枚举一个合约可以有多个枚举\npragma solidity ^0.8.0;contract Example &#123;    enum Status &#123; Pending, Approved, Rejected &#125;    enum Color &#123; Red, Green, Blue &#125;&#125;\n枚举的相关赋值方法以及重置\n//文件：test_enum.solpragma solidity ^0.8.17;// SPDX-License-Identifier: mitimport &quot;./enum.sol&quot;; //可以直接引入文件contract status &#123;    enum state&#123;        pending,        shipped,        accepted,        rejected,        canceled    &#125;    enum testa&#123;        aaaed,        bbbed,        ced    &#125;    state public ss;    function get() public view returns(state) &#123;        return ss;    &#125;    function setState(state stt) public &#123;        ss = stt;    &#125;    function cancel() public &#123;        ss = state.canceled;    &#125;    function reset() public &#123;        delete ss;//会重置为零    &#125;    function setStateByNum(uint index) public &#123;        ss = state(index);//根据索引进行赋值    &#125;    function test() public returns(bool) &#123;        setStateByNum(1);        return (ss==state.shipped);    &#125;&#125;//文件：enum.solpragma solidity ^0.8.17;//SPDX-License-Identifier: MITenum _status &#123;    Pending,    Shipped,    Accepted,    Rejected,    Canceled&#125;\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-26","url":"/2023/02/26/2023-02-26.html/","content":"2023-02-26calldata与memory的区别在 Solidity 中，参数可以被声明为 calldata 或 memory。\ncalldata 表示参数值在调用函数时不会被修改，而是被传递到函数中。在函数内部，它们可以被视为常量，不能被修改。当函数调用结束时，这些值也将被销毁。在视觉上， calldata 参数类似于函数签名中的参数。\nmemory 表示参数值在调用函数时可以被修改，并且在函数调用结束后将保留修改后的值。在函数内部， memory 用于存储临时变量和复制的值，例如在函数内部创建的新数组或结构体。在函数结束后，调用方可以通过返回值或事件查看修改后的值。\n在传递大量数据时，使用 calldata 通常比使用 memory 更高效，因为它不需要在函数调用中复制大量数据。但是，如果需要对传递的数据进行修改，则必须使用 memory。\n元组 Tuple在solidity中经常看到返回值是元组的，记录一下(函数哪里会有更详细用法)\npragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract tuple_test &#123;    function returnTul() public reuturns(uint, bool) &#123;        //...        reuturn (0, true);    &#125;    function getTul() view public &#123;        uint myUint;        bool myBool;        (myUint, myBool) = returnTul();    &#125;&#125;\n\n比较memory跟storage类型数据的stringif (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) &#123;    // do something&#125;\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-01","url":"/2023/03/01/2023-03-01.html/","content":"2023-03-01多继承// SPDX-License-Identifier: MITpragma solidity ^0.8.17;/* Graph of inheritance    A   / \\  B   C / \\ /F  D,E*/contract A &#123;    //需要被重写的函数加上virtual修饰符    function foo() public pure virtual returns(string memory) &#123;        return &quot;A&quot;;    &#125;&#125;contract B is A&#123;    function foo() public pure override virtual returns (string memory) &#123;        return &quot;B&quot;;    &#125;&#125;contract C is A &#123;    function foo() public pure override virtual returns (string memory) &#123;        return &quot;C&quot;;    &#125;&#125;// Contracts can inherit from multiple parent contracts.// When a function is called that is defined multiple times in// different contracts, parent contracts are searched from// right to left, and in depth-first manner.//合同可以多重继承//在不同合约中当函数被定义为多重继承时，父合约会自右向左，按照深度优先搜索contract D is B, C &#123;    //多继承时候需要给override传入重写合约    function foo() public pure override(B, C)  returns (string memory) &#123;        return super.foo();//返回“C”    &#125;&#125;contract E is C,B &#123;    function foo() public pure override(C, B)  returns (string memory) &#123;        return super.foo();//返回“B”    &#125;&#125;contract F is A, B &#123;        //必须把父合同放前面（A是B的父合同）        //此时是孙子合同        //调换A跟B会发生编译错误    function foo() public pure override(B, A) returns (string memory) &#123;        return super.foo();    &#125;&#125;\n\n不能够调转继承合同的父子顺序\n\n隐藏父合同的状态变量pragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract A &#123;    string public stt = &quot;contract A&quot;;    function getName() view public returns(string memory)&#123;        return stt;    &#125;&#125;//错误写法// contract B is A &#123;//     string public stt = &quot;contract B&quot;;// &#125;//正确写法contract C is A &#123;    constructor() &#123;        stt = &quot;contract C&quot;;    &#125;&#125;\n\n继承的父函数调用典型错误：没写明override的顺序\npragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract A &#123;    event log(string mess);    function foo() public virtual &#123;        emit log(&quot;A.foo() is called.&quot;);    &#125;    function bar() public virtual &#123;        emit log(&quot;A.bar() is called&quot;);    &#125;&#125;contract B is A&#123;    function foo() override virtual public &#123;        emit log(&quot;B.foo() is called&quot;);        super.foo();    &#125;    function bar() override virtual public &#123;        emit log(&quot;B.bar() is called&quot;);        A.bar();    &#125;&#125;contract C is A &#123;    function foo() override virtual public &#123;        emit log(&quot;C.foo() is called&quot;);        super.foo();    &#125;    function bar() override virtual public &#123;        emit log(&quot;C.bar() is called&quot;);        A.bar();    &#125;&#125;contract D is B, C &#123;    function foo() override(B, C) public &#123;        super.foo();//D.foo()-&gt;C.foo()-&gt;A.foo()错误理解一，错误理解二super会自右向左把自己的父类都调用一遍                    //D.foo()-&gt;C.foo()-&gt;B.foo()-&gt;A.foo()                    //super就是有父类的时候(指的是最开始调用的合约)会调用父类，没有的时候就调用其爷类    &#125;    function bar() override(B, C) public &#123;//就算override(C, B)也同样是D.bar()-&gt;C.bar()-&gt;A.bar()        super.bar();//D.bar()-&gt;C.bar()-&gt;A.bar()    &#125;&#125;\n\n思考：当为不影响传统意义上的父类，可以采用父类名称的方式去调用函数\n\n接口的五个特点\ncannot have any functions implemented\ncan inherit from other interfaces\nall declared functions must be external\ncannot declare a constructor\ncannot declare state variables\n\n//（例子貌似没太大意义）// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract Counter &#123;    uint public count;    function increment() external &#123;        count += 1;    &#125;&#125;interface ICounter &#123;    function count() external view returns (uint);    function increment() external;&#125;contract MyContract &#123;    function incrementCounter(address _counter) external &#123;        ICounter(_counter).increment();    &#125;    function getCount(address _counter) external view returns (uint) &#123;        return ICounter(_counter).count();    &#125;&#125;// Uniswap exampleinterface UniswapV2Factory &#123;    function getPair(        address tokenA,        address tokenB    ) external view returns (address pair);&#125;interface UniswapV2Pair &#123;    function getReserves()        external        view        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);&#125;contract UniswapExample &#123;    address private factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;    address private dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;    function getTokenReserves() external view returns (uint, uint) &#123;        address pair = UniswapV2Factory(factory).getPair(dai, weth);        (uint reserve0, uint reserve1, ) = UniswapV2Pair(pair).getReserves();        return (reserve0, reserve1);    &#125;&#125;\n接口的函数体实现可以通过一个普通的合约继承之后进行重写：\npragma solidity ^0.8.17;//SPDX-License-Identifier:MITinterface abs &#123;    function beforeImpl() external pure returns(uint);&#125;contract absImpl is abs &#123;    function beforeImpl() override external pure returns(uint) &#123;        return 1;    &#125;&#125;\n\npayable的运用pragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract pt &#123;    address payable owner;//就是合约部署者（由constructor初始化）    //可以写一些事件，方便理解省略了    constructor() payable &#123;        owner = payable(msg.sender);    &#125;    function deposit() public payable onlyOwner&#123;&#125;    modifier onlyOwner &#123;        require(owner == msg.sender);        _;    &#125;    function withDraw(uint _amount) public payable onlyOwner &#123;        owner.transfer(_amount);        //owner是目标账户    &#125;    function transferEther(address payable _to, uint _amount) public payable onlyOwner &#123;        _to.transfer(_amount);    &#125;    function getBalance() public view returns(uint)&#123;        return address(this).balance;    &#125;    function distributor(address receiver) public&#123;        if(gasleft()&lt;2300) &#123;            return;        &#125;        payable(receiver).transfer(1 ether);//不用payable也可以这样做    &#125;&#125;\n\n存的钱会放在合约里面，部署合约的账户就是owner，deposit是（owner-&gt;pt[contract]）转账的函数，withDraw类似；transfer参数列表中的address是另一个账户的地址，_amount是转账金额\n\n发送以太币的三种方式\n(payable)address.transfer()\n(payable)address.send()\n.callpragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract Recevier &#123;constructor() payable &#123;&#125;function getBalance() public view returns(uint) &#123;return address(this).balance;&#125;&#125;contract Sender &#123;function sendByTransfer(address payable _to) public payable &#123;_to.transfer(msg.value);&#125;function sendBySend(address payable _to) public payable &#123;bool sent = _to.send(msg.value);require(sent,&quot;ERROR&quot;);&#125;function sendByCall(address payable _to) public payable &#123;(bool success, ) = _to.call&#123;value: msg.value&#125;(&quot;&quot;);require(success,&quot;failed&quot;);&#125;&#125;\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-27","url":"/2023/02/27/2023-02-27.html/","content":"2023-02-27函数及多值返回// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract Function &#123;    // Functions can return multiple values.    function returnMany() public pure returns (uint, bool, uint) &#123;        return (1, true, 2);    &#125;    // Return values can be named.    function named() public pure returns (uint x, bool b, uint y) &#123;        return (1, true, 2);    &#125;    // Return values can be assigned to their name.    // In this case the return statement can be omitted.    function assigned() public pure returns (uint x, bool b, uint y) &#123;        x = 1;        b = true;        y = 2;    &#125;    // Use destructuring assignment when calling another    // function that returns multiple values.    function destructuringAssignments()        public        pure        returns (uint, bool, uint, uint, uint)    &#123;        (uint i, bool b, uint j) = returnMany();        // Values can be left out.        (uint x, , uint y) = (4, 5, 6);        return (i, b, j, x, y);    &#125;    // Cannot use map for either input or output    // Can use array for input    function arrayInput(uint[] memory _arr) public &#123;&#125;    // Can use array for output    uint[] public arr;    function arrayOutput() public view returns (uint[] memory) &#123;        return arr;    &#125;&#125;// Call function with key-value inputscontract XYZ &#123;    function someFuncWithManyInputs(        uint x,        uint y,        uint z,        address a,        bool b,        string memory c    ) public pure returns (uint) &#123;&#125;    function callFunc() external pure returns (uint) &#123;        return someFuncWithManyInputs(1, 2, 3, address(0), true, &quot;c&quot;);    &#125;    function callFuncWithKeyValue() external pure returns (uint) &#123;        return            someFuncWithManyInputs(&#123;a: address(0), b: true, c: &quot;c&quot;, x: 1, y: 2, z: 3&#125;);    &#125;&#125;\n\nview与purepragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract vp &#123;    uint x = 1;    function v() public view returns(uint) &#123;        return x+3;//访问了x    &#125;    function p() public pure returns(uint) &#123;        return 1;//只需要其返回值    &#125;&#125;\n\nrevert与assert、requirerevert区别在于可以抛出自定义错误，方便查看参数\nassert用于处理内部错误，如相乘相加溢出，除以零，其条件不满足时会报出错误\nrequire可以带条件，其条件不满足时会报出错误\n这两个里面revert跟require不需要消耗gas，assert需要消耗\npragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract err &#123;    function testRequire(int i) public pure &#123;        require(i &gt; 0, &quot;parameter must be bigger than 0! &quot;);    &#125;    function testRevert(int i) public pure&#123;        if(i&lt;0) &#123;            revert(&quot;parameter must be bigger than 0! &quot;);        &#125;     &#125;    uint a;    function testAssert() public&#123;        assert(a == 11);//部署的时候会检查，错误时候终止合同的部署        a = 10;    &#125;    error aerror(uint first, uint sec);    function testErr(int k) public pure &#123;        if(k == 1) revert aerror(&#123;first: 1, sec: 1&#125;);//error就是方便查看数值    &#125;    uint max = type(uint).max;    bool isMax = max == 2**256-1;&#125;\n下面是revert一个自定义错误的例子\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-02","url":"/2023/03/02/2023-03-02.html/","content":"2023-03-02call与fallbackfallback函数被调用的情况\nWhich function is called, fallback() or receive()?           send Ether               |         msg.data is empty?              / \\            yes  no            /     \\receive() exists?  fallback()/   \\yes   no/      \\receive()   fallback()\n\n函数名称不存在\n\nReceive函数没有 function 关键字，没有参数也没有返回值，且必须是 external 可见性（允许外部合约调用）并具有 payable 可支付属性。\n转账的时候会先调用receive，没有receive的时候会调用fallback\n\naddress可以唯一标识一个合约，某种意义上来说，address就是合约\n\n接收及发送以太币（send、transfer、call）\nHow to send Ether?\n如何发送以太币？\n\nYou can send Ether to other contracts by\n你可以通过以下方式发送以太币给其它合约\n\ntransfer (2300 gas, throws error) \nsend (2300 gas, returns bool)\ncall (forward all gas or set gas, returns bool)\n\n\nHow to receive Ether?\n如何接收以太币？\n\nA contract receiving Ether must have at least one of the functions below\n接收以太币的合约必须拥有至少一个以下函数：\n\nreceive() external payable\nfallback() external payable\n\nreceive() is called if is empty, otherwise is called.msg.datafallback()\n当receive()是空的的时候会被调用，否则msg.data会调用fallback()\n\nWhich method should you use?\n\ncall in combination with re-entrancy guard is the recommended method to use after December 2019.\ncall函数是2019年12月份之后被推荐使用的，它结合了重入防御机制\nGuard against re-entrancy by\n通过以下方式防止重入\n\nmaking all state changes before calling other contracts &#x2F; 在调用其他合约之前先做完所有状态的改变\n\nusing re-entrancy guard modifier &#x2F; 使用防重入修饰符\n\n\ncall能省一些gas（详见-&gt; 视频）\n如下代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract ReceiveEther &#123;    // Function to receive Ether. msg.data must be empty    receive() external payable &#123;&#125;    // Fallback function is called when msg.data is not empty    fallback() external payable &#123;&#125;    function getBalance() public view returns (uint) &#123;        return address(this).balance;    &#125;&#125;contract SendEther &#123;    function sendViaTransfer(address payable _to) public payable &#123;        // This function is no longer recommended for sending Ether.        _to.transfer(msg.value);    &#125;    function sendViaSend(address payable _to) public payable &#123;        // Send returns a boolean value indicating success or failure.        // This function is not recommended for sending Ether.        bool sent = _to.send(msg.value);        require(sent, &quot;Failed to send Ether&quot;);    &#125;    function sendViaCall(address payable _to) public payable &#123;        // Call returns a boolean value indicating success or failure.        // This is the current recommended method to use.        (bool sent, bytes memory data) = _to.call&#123;value: msg.value&#125;(&quot;&quot;);        require(sent, &quot;Failed to send Ether&quot;);    &#125;&#125;\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-02-28","url":"/2023/02/28/2023-02-28.html/","content":"2023-02-28锁与Modifierpragma solidity ^0.8.17;//SPDX-License-Identifier: MITcontract lock_ &#123;    address owner;    constructor() &#123;        owner = msg.sender;    &#125;    modifier onlyOwner() &#123;        require(owner == msg.sender, &quot;not owner! &quot;);        _;    &#125;    modifier validAddress(address addr) &#123;        require(addr != address(0), &quot;not valid address!&quot;);        _;    &#125;    function changeOwner(address newOwner) public onlyOwner validAddress(newOwner) &#123;        owner = newOwner;        //更改账户拥有者需要确认是否为袁拥有者跟新地址有效性    &#125;        bool lock;    modifier noReentrancy &#123;        require(!lock, &quot;No reentrancy!&quot;);//函数被调用的时候拒绝访问        lock = true;        _;        lock = false;    &#125;    uint x = 10;    function decrease(uint i) public noReentrancy &#123;        x-=i;        if(i&gt;1) &#123;            decrease(i-1);        &#125;    &#125;&#125;\n事件pragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract eventTest &#123;    event log(address indexed caller, string message);    event anotherLog();    function test() public &#123;        emit log(address(0), &quot;hello1&quot;);        emit log(msg.sender, &quot;hello2&quot;);        emit anotherLog();    &#125;    &#125;\n继承相关的构造器pragma solidity ^0.8.17;//SPDX-License-Identifier:MITcontract A&#123;    uint x;    constructor(uint _x) &#123;        x = _x;    &#125;&#125;contract B&#123;    uint y;    constructor(uint _y) &#123;        y = _y;    &#125;&#125;contract C is B(1), A(2) &#123;&#125;contract D is B, A &#123;    constructor(uint _x, uint _y) A(_x) B(_y) &#123;    &#125;&#125;contract E is A, B &#123;    constructor(uint _x, uint _y) B(_y) A(_x) &#123;    &#125;&#125;contract F is A, B &#123;    constructor() A(1) B(2) &#123;    &#125;&#125;","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-04","url":"/2023/03/04/2023-03-04.html/","content":"2023-03-04call方法以及abi编解码了解以下编码更多信息-&gt;查看文章\nabi.encodeCallbytes memory data = abi.encodeCall(MyContract.myFunction.selector, [arg1, arg2]);\nabi.encodeCall是Solidity中的一个函数，它可以用来对函数调用进行编码。它接受一个函数选择器和一组参数，并返回一个字节数组，该字节数组可以用来调用指定的函数\n优点：有类型检查（不是字符串形式）\nabi.encodePacked将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多 0 省略。\n比如，只用 1 字节来编码 uint 类型。当你想省空间，并且不与合约交互的时候，可以使用 abi.encodePacked，例如算一些数据的 hash（可作数据比较） 时。\n\nabi.encodeWithSignature与 abi.encode 功能类似，只不过第一个参数为函数签名，比如”foo(uint256,address)”。当调用其他合约的时候可以使用。函数签名：bytes4(keccak(“函数名(函数类型)”))\n\nabi.endeWithSelectorSelector相关文章-&gt;HERE \nselector 可以通过两种方式获取，一种是查询 function.selector，另一种就是自己计算（如下）\nreturn bytes4(keccak256(&quot;函数名(参数类型)&quot;) &#x3D;&#x3D; return 合约名(address).函数名.selector\n与 abi.encodeWithSignature 功能类似，只不过第一个参数为函数选择器，为函数签名 Keccak 哈希的前 4 个字节。\n\nabi.decodeabi.decode 用于解码 abi.encode 生成的二进制编码，将它还原成原本的参数。\n(bool b, uint ui, string memory) = abi.decode(data,(bool, uint, string));\n\n写法\naddress.call&#123;value:xxx, gas:xxx&#125;([bytes]) &#x3D;&#x3D; address.call.value(xxx).gas(xxx)([bytes])【右侧用法已被弃用】\n\naddress.call&#123;value:xxx, gas:xxx&#125;(abi.encodeWithSignature(&quot;函数名称(参数类型)&quot;), 参数) &#x3D;&#x3D; address.call&#123;value:xxx,gas:xxx&#125;(abi.encodeWithSelector(bytes4(keccak256(&quot;参数类型&quot;))),参数)\n\n\n返回值(bool success, bytes data)\ncall函数的返回结果是一个bool与bytes的元组，表示是否成功调用或者失败引起了EVM异常。该方法无法直接访问函数返回结果（因为需要事先知道编码和返回结果大小）\ncall()的返回结果即使成功，并不能说操作成功了，只是没有出现异常，有可能调用到了fallback()函数\n调用另一个合约的方法\n带参情况\n\n(bool success, bytes memory data) = _addr.call&#123;value: msg.value, gas: 5000&#125;(abi.encodeWithSignature(&quot;foo(string,uint256)&quot;, &quot;call foo&quot;, 123)) ); 花括号指定发送以太币数量以及可用gas数量，根据地址_to对应合约寻找函数foo(string,uint256)，后面跟着两个参数\n\n无参情况\n\n(bool success, bytes memory data) = _addr.call&#123;value: msg.value&#125;(abi.encodeWithSignature(&quot;doesNotExist()&quot;));\n//SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.17;contract Receiver &#123;    event received(string _callMsg, address _addr);    function foo(string memory funcName, uint num) payable external returns(uint)&#123;        emit received(funcName, msg.sender);        return num + 1;    &#125;    fallback() external&#123;        emit received(&quot;fail&quot;, msg.sender);    &#125;&#125;contract TestCall &#123;    function testCallFoo(address payable addr_to_be_called) payable public returns(bytes memory) &#123;        (bool ok, bytes memory data) = addr_to_be_called.call&#123;value:msg.value, gas:5000&#125;(abi.encodeWithSignature(&quot;foo(string, uint)&quot;, &quot;testCallFoo&quot;, 10));        require(ok, &quot;failed&quot;);        return data;    &#125;    function testDonotExist(address payable addr_to_be_called) payable public returns(bytes memory) &#123;        (bool ok, bytes memory data) = addr_to_be_called.call&#123;value:msg.value, gas:5000&#125;(abi.encodeWithSignature(&quot;DonotExist()&quot;));        require(ok, &quot;failed&quot;);        return data;    &#125;&#125;\n\n委托调用：Delegatecall写法address.delegatecall(abi.encodeCall(A.funA,(arg1, arg2, ...)))\n例子\n正常的调用其他合约//SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract Callee &#123;    uint public x;    uint public value;    function setX(uint _x) public returns(uint)&#123;        x = _x;        return x;    &#125;    function setXandEther(uint _x) public payable returns(uint, uint) &#123;        x = _x;        value = msg.value;        return (x, value);    &#125;&#125;contract Caller &#123;    function setX(Callee cl, uint _x) public returns(uint x) &#123;        x= cl.setX(_x);    &#125;    function setXWithAddress(address addr, uint _x) public returns(uint x) &#123;        Callee cl = Callee(addr);        x = cl.setX(_x);    &#125;    function setXAndEther(Callee cl, uint _x) public payable returns(uint x, uint value) &#123;        (x, value) = cl.setXandEther&#123;value:msg.value&#125;(_x);    &#125;&#125;\n特别是cl.setXandEther&#123;value:msg.value&#125;(_x);里面的&#123;value:msg.value&#125;不要忘记\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-05","url":"/2023/03/05/2023-03-05.html/","content":"2023-03-05salt关键字在 Solidity 中，salt 是一个关键字，它用于支持 create2 功能。自 0.8.0 版本起，可以通过指定 salt 选项来使用新的关键字\n相关文章&#x2F;问答-&gt;Salted contract creations &#x2F; create2、what does keyword “salt” mean in solidity?、What is the benefit of using create2() to create a smart contract?\n// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract D &#123;    uint public x;    constructor(uint a) &#123;        x = a;    &#125;&#125;contract C &#123;    function createDSalted(bytes32 salt, uint arg) public &#123;        // This complicated expression just tells you how the address        // can be pre-computed. It is just there for illustration.        // You actually only need ``new D&#123;salt: salt&#125;(arg)``.        //这些复杂的表达只是告诉我们地址是如何被提前计算的，仅作展示        //事实上只需要``(new D)&#123;salt: salt&#125;(arg)``        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(            bytes1(0xff),            address(this),            salt,            keccak256(abi.encodePacked(                type(D).creationCode,                abi.encode(arg)            ))        )))));        D d = new D&#123;salt: salt&#125;(arg);        require(address(d) == predictedAddress);    &#125;&#125;\n\n例子在一个合约中创建合约其实有助于管理合约（不借助数据库）\npragma solidity ^0.8.17;//SPDX-License-Identifier: MITcontract Car&#123;    address owner;//表示拥有者    string public model;//表示车型    address carAddr;//表示合约地址    constructor(address _owner, string memory _model) payable&#123;        owner = _owner;        model = _model;        carAddr = address(this);    &#125;&#125;contract CarFactory&#123;    Car[] public cars;    function createNewCar(string memory _model) public  &#123;        cars.push(new Car(address(this), _model));    &#125;    function createNewCarAndSendEther(string memory _model) public payable &#123;        Car car = (new Car)&#123;value:msg.value&#125;(address(this), _model);        cars.push(car);    &#125;    function create2NewCar(string memory _model, bytes32 salt) public &#123;        Car car = (new Car)&#123;salt:salt&#125;(address(this), _model);        cars.push(car);    &#125;    function create2NewCarWithEther(string memory _model, bytes32 salt) public payable &#123;        Car car = (new Car)&#123;value:msg.value, salt:salt&#125;(address(this), _model);        cars.push(car);    &#125;&#125;\n\n部署及调试推荐视频-&gt;Learning Solidity (0.5) - Creating Contracts from a Contract\n\n部署车厂（CarFactory）合约\n\n\n\n传入相关参数同时调用函数，找到cars索引复制其地址\n\n\n\n通过地址寻找车合约\n\n\n异常 try&#x2F;catch在函数体中使用try&#x2F;catch：\ntry + 合约对象+函数名称(参数) +returns(接收返回值) &#x2F; try + 合约对象(构造函数传参)\ncatch + Error(string memory result)：处理require异常\ncatch + (bytes memory somereason)：处理require异常\n//SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract Foo &#123;address public owner;constructor(address _owner) &#123;require(_owner != address(0), &quot;invalid address&quot;);assert(_owner != 0x0000000000000000000000000000000000000001);owner = _owner;&#125;function myFunc(uint x) pure public returns(string memory)&#123;require(x!=0,&quot;x!=0&quot;);return &quot;my function is called! &quot;;&#125;&#125;contract Bar &#123;event log(string message);event logBtyes(bytes data);Foo foo;function tryCatchExternalCall(uint _i) public &#123;try foo.myFunc(_i) returns( string memory result) &#123;emit log(result);&#125; catch &#123;emit log(&quot;external call failed! &quot;);&#125;&#125;    function tryCatchNewContract(address addr) public  &#123;        try new Foo(addr) &#123;            emit log(&quot;create a new contract! &quot;);        &#125;catch Error(string memory reason) &#123;            emit log(reason);//捕获recert跟require异常        &#125;catch (bytes memory somereason) &#123;            emit logBtyes(somereason);//捕获assert异常        &#125;    &#125;&#125;\n\nimport例子文件路径\n├── Import.sol└── Foo.sol\n\nFoo.sol\n// SPDX-License-Identifier: MITpragma solidity ^0.8.17;struct Point &#123;uint x;uint y;&#125;error Unauthorized(address caller);function add(uint x, uint y) pure returns (uint) &#123;return x + y;&#125;contract Foo &#123;string public name = &quot;Foo&quot;;&#125;\nImport.sol\n// SPDX-License-Identifier: MITpragma solidity ^0.8.17;// import Foo.sol from current directoryimport &quot;./Foo.sol&quot;;// import &#123;symbol1 as alias, symbol2&#125; from &quot;filename&quot;;import &#123;Unauthorized, add as func, Point&#125; from &quot;./Foo.sol&quot;;contract Import &#123;// Initialize Foo.solFoo public foo = new Foo();    // Test Foo.sol by getting it&#x27;s name.    function getFooName() public view returns (string memory) &#123;        return foo.name();    &#125;&#125;\n也可以通过其他地方导入\n// https://github.com/owner/repo/blob/branch/path/to/Contract.solimport &quot;https://github.com/owner/repo/blob/branch/path/to/Contract.sol&quot;;// Example import ECDSA.sol from openzeppelin-contract repo, release-v4.5 branch// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.solimport &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol&quot;;\n\n注意事项没包在合约体内的函数不能有可见性\n如果要调用另一个合约的状态变量，需要事先把该合约内的状态变量声明为public（会默认生成getter），然后在本合约访问时要使用合约对象名.变量名()\nLibrary 库一个可以去除元素同时减少空间的库//SPDX-License-Identifier:MITpragma solidity ^0.8.17;library Array &#123;function remove(uint[] storage arr, uint index) internal &#123;arr[index] = arr[arr.length-1];arr.pop();&#125;&#125;\n如何使用库//SPDX-License-Identifier:MITpragma solidity ^0.8.17;import &quot;./LibImported.sol&quot;;contract testLib &#123;using Array for uint[];//要放在函数体外面uint[] arr;function testRm(uint _index) public returns(uint length1,uint length2) &#123;    for(uint i = 0; i &lt; 5; i++) &#123;        arr.push(i+1);    &#125;    //第一种调用库函数方法    arr.remove(_index);    length1 = arr.length;    //第二种调用方式    Array.remove(arr, _index);    length2 = arr.length;    &#125;&#125;\n\n更多例子// SPDX-License-Identifier: MITpragma solidity ^0.8.17;library Math &#123;    function sqrt(uint y) internal pure returns (uint z) &#123;        if (y &gt; 3) &#123;            z = y;            uint x = y / 2 + 1;            while (x &lt; z) &#123;                z = x;                x = (y / x + x) / 2;            &#125;        &#125; else if (y != 0) &#123;            z = 1;        &#125;        // else z = 0 (default value)    &#125;&#125;contract TestMath &#123;    function testSquareRoot(uint x) public pure returns (uint) &#123;        return Math.sqrt(x);    &#125;&#125;// Array function to delete element at index and re-organize the array// so that there are no gaps between the elements.library Array &#123;    function remove(uint[] storage arr, uint index) public &#123;        // Move the last element into the place to delete        require(arr.length &gt; 0, &quot;Can&#x27;t remove from empty array&quot;);        arr[index] = arr[arr.length - 1];        arr.pop();    &#125;&#125;contract TestArray &#123;    using Array for uint[];    uint[] public arr;    function testArrayRemove() public &#123;        for (uint i = 0; i &lt; 3; i++) &#123;            arr.push(i);        &#125;        arr.remove(1);        assert(arr.length == 2);        assert(arr[0] == 0);        assert(arr[1] == 2);    &#125;&#125;\n\n\n相关视频-&gt;HERE\n注意事项\n\nusing A for B中A可以理解为库名称，B为第一个传入参数类型\n\n如果库的函数可见性声明为internal需要嵌入本合约代码\n\n某些函数非internal时候需要实现部署它，并将其与使用该合约函数连接起来（remix做不到、可节省gas开销）\n\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-06","url":"/2023/03/06/2023-03-06.html/","content":"2023-03-06哈希函数keccak256(abi.encode(xxx))、keccak256(abi.encodePacked())是bytes32类型不同于前面的call时候的用法：abi.encodeWithSignature(&quot;funcname&quot;,arg1,arg2,...)返回值是bytes类型\n//SPDX-License-Identifier: MITpragma solidity ^0.8.17;contract hashFunc &#123;    function hash(string memory title, uint number, address addr) public pure returns(bytes32)&#123;        return keccak256(abi.encodePacked(title, number, addr));    &#125;    function sameType(string memory astr, string memory bstr) public pure returns(bytes32)&#123;        return keccak256(abi.encode(astr, bstr));//两个数据一样时需要用abi.encode，用abi.encodePacked会出现                                                //&quot;AAA,BBB&quot;与&quot;AA,ABBB&quot;的哈希值相同    &#125;    function sameType(string memory astr) public pure returns(bytes32)&#123;//函数重载        return keccak256(abi.encode(astr));    &#125;&#125;contract guessNum &#123;    bytes32 public word = 0x0d0fbbfb6f13ca33b055053820891b647dba6d9578df439c1a6543ca379da73e;    function guessWord(string memory _word) public view returns(bool) &#123;        return word == keccak256(abi.encode(_word));    &#125;&#125;\n\ndecodeencodefunction tryEncode(string memory astr, string memory bstr) public pure returns(bytes memory) &#123;        return abi.encode(astr, bstr);    &#125;\ndecodefunction decode(bytes memory data) public pure returns(string memory, string memory) &#123;        return(abi.decode(data,(string, string)));    &#125;\n\nassembly在 Solidity 中，assembly 是一种低级语言，它可以直接与以太坊虚拟机（EVM）进行交互。它提供了更多的控制能力，可以实现一些仅使用 Solidity 无法实现的逻辑，例如指向特定的内存块。\nSolidity 定义了两种 assembly 的实现方式：内联 assembly 和独立 assembly。内联 assembly 可以直接在 Solidity 源代码中使用，而独立 assembly 则可以脱离 Solidity 使用。\nr := mload(add(sig, 32))表示从内存地址 sig + 32 处读取一个字（32 字节）的数据，并将其赋值给变量 r\n搭链一、安装依赖包sudo yum install -y openssl openssl-develcd ~ &amp;&amp; mkdir fisco &amp;&amp; cd fiscocurl如果没有的话：...后面补充\n\n","categories":["Learning","Solidity","Blockchain","Competition"],"tags":["tech","learning","blockchain","solidity"]},{"title":"23-03-07","url":"/2023/03/07/2023-03-07.html/","content":"2023-03-07 | 搭链全命令[linzepore@localhost ~]$ cd ~/fiscobash: cd: /home/linzepore/fisco: 没有那个文件或目录[linzepore@localhost ~]$ cd ~[linzepore@localhost ~]$ mkdir fisco[linzepore@localhost ~]$ cd fisco [linzepore@localhost fisco]$ curl -LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (6) Could not resolve host: github.com; 未知的错误[linzepore@localhost fisco]$ chmod u+x build.shchmod: 无法访问&quot;build.sh&quot;: 没有那个文件或目录[linzepore@localhost fisco]$ chmod u+x build_chain.shchmod: 无法访问&quot;build_chain.sh&quot;: 没有那个文件或目录[linzepore@localhost fisco]$ chmod u+x fiscochmod: 无法访问&quot;fisco&quot;: 没有那个文件或目录[linzepore@localhost fisco]$ cd ..[linzepore@localhost ~]$ chmod fiscochmod: &quot;fisco&quot; 后缺少操作数Try &#x27;chmod --help&#x27; for more information.[linzepore@localhost ~]$ chmod u+x fisco[linzepore@localhost ~]$ curl -LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (6) Could not resolve host: github.com; 未知的错误[linzepore@localhost ~]$ curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.shcurl: (6) Could not resolve host: github.com; 未知的错误[linzepore@localhost ~]$ curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.shcurl: (6) Could not resolve host: github.com; 未知的错误[linzepore@localhost ~]$ curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh######################################################################## 100.0%[linzepore@localhost ~]$ chmod u+x build_chain.sh[linzepore@localhost ~]$ chmod u+x build_chain.sh[linzepore@localhost ~]$ ./build_chain.sh Usage:    -l &lt;IP list&gt;                        [Required] &quot;ip1:nodeNum1,ip2:nodeNum2&quot; e.g:&quot;192.168.0.1:2,192.168.0.2:3&quot;    -f &lt;IP list file&gt;                   [Optional] split by line, every line should be &quot;ip:nodeNum agencyName groupList p2p_port,channel_port,jsonrpc_port&quot;. eg &quot;127.0.0.1:4 agency1 1,2 30300,20200,8545&quot;    -v &lt;FISCO-BCOS binary version&gt;      Default is the latest v2.6.0    -e &lt;FISCO-BCOS binary path&gt;         Default download fisco-bcos from GitHub. If set -e, use the binary at the specified location    -o &lt;Output Dir&gt;                     Default ./nodes/    -p &lt;Start Port&gt;                     Default 30300,20200,8545 means p2p_port start from 30300, channel_port from 20200, jsonrpc_port from 8545    -q &lt;List FISCO-BCOS releases&gt;       List FISCO-BCOS released versions    -i &lt;Host ip&gt;                        Default 127.0.0.1. If set -i, listen 0.0.0.0    -s &lt;DB type&gt;                        Default rocksdb. Options can be rocksdb / mysql / scalable, rocksdb is recommended    -d &lt;docker mode&gt;                    Default off. If set -d, build with docker    -c &lt;Consensus Algorithm&gt;            Default PBFT. Options can be pbft / raft /rpbft, pbft is recommended    -C &lt;Chain id&gt;                       Default 1. Can set uint.    -g &lt;Generate guomi nodes&gt;           Default no    -z &lt;Generate tar packet&gt;            Default no    -t &lt;Cert config file&gt;               Default auto generate    -6 &lt;Use ipv6&gt;                       Default no. If set -6, treat IP as IPv6    -k &lt;The path of ca root&gt;            Default auto generate, the ca.crt and ca.key must in the path, if use intermediate the root.crt must in the path    -K &lt;The path of sm crypto ca root&gt;  Default auto generate, the gmca.crt and gmca.key must in the path, if use intermediate the gmroot.crt must in the path    -D &lt;Use Deployment mode&gt;            Default false, If set -D, use deploy mode directory struct and make tar    -G &lt;channel use sm crypto ssl&gt;      Default false, only works for guomi mode    -X &lt;Certificate expiration time&gt;    Default 36500 days    -T &lt;Enable debug log&gt;               Default off. If set -T, enable debug log    -S &lt;Enable statistics&gt;              Default off. If set -S, enable statistics    -F &lt;Disable log auto flush&gt;         Default on. If set -F, disable log auto flush    -E &lt;Enable free_storage_evm&gt;        Default off. If set -E, enable free_storage_evm    -h Helpe.g    ./build_chain.sh -l &quot;127.0.0.1:4&quot;[linzepore@localhost ~]$ ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.164.132  netmask 255.255.255.0  broadcast 192.168.164.255        inet6 fe80::c58c:39d2:728f:e7c  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:c3:ee:6b  txqueuelen 1000  (Ethernet)        RX packets 188  bytes 98192 (95.8 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 157  bytes 16476 (16.0 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 752  bytes 64592 (63.0 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 752  bytes 64592 (63.0 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255        ether 52:54:00:91:20:4e  txqueuelen 1000  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[linzepore@localhost ~]$ ./build_chain.sh -l &quot;127.0.0.1:4&quot; -p 30300,20200,8454[INFO] Downloading fisco-bcos binary from https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/fisco-bcos.tar.gz ...######################################################################## 100.0%==============================================================Generating CA key...==============================================================Generating keys and certificates ...Processing IP=127.0.0.1 Total=4 Agency=agency Groups=1==============================================================Generating configuration files ...Processing IP=127.0.0.1 Total=4 Agency=agency Groups=1==============================================================[INFO] Start Port      : 30300 20200 8454[INFO] Server IP       : 127.0.0.1:4[INFO] Output Dir      : /home/linzepore/nodes[INFO] CA Path         : /home/linzepore/nodes/cert/==============================================================[INFO] Execute the download_console.sh script in directory named by IP to get FISCO-BCOS console.e.g.  bash /home/linzepore/nodes/127.0.0.1/download_console.sh -f==============================================================[INFO] All completed. Files in /home/linzepore/nodes[linzepore@localhost ~]$ cd fisco[linzepore@localhost fisco]$ cd nodes/12/0.0.1bash: cd: nodes/12/0.0.1: 没有那个文件或目录[linzepore@localhost fisco]$ ls[linzepore@localhost fisco]$ ll总用量 0[linzepore@localhost fisco]$ cd..bash: cd..: 未找到命令...[linzepore@localhost fisco]$ ll总用量 0[linzepore@localhost fisco]$ cd ..[linzepore@localhost ~]$ lsbuild_chain.sh  fisco  nodes  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ mv build_chain.sh fisco/build_chain.sh[linzepore@localhost ~]$ lsfisco  nodes  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ mv nodes fisco/nodes[linzepore@localhost ~]$ lsfisco  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ cd fisco[linzepore@localhost fisco]$ cd nodes/12.0.0.1bash: cd: nodes/12.0.0.1: 没有那个文件或目录[linzepore@localhost fisco]$ lsbuild_chain.sh  nodes[linzepore@localhost fisco]$ cd codesbash: cd: codes: 没有那个文件或目录[linzepore@localhost fisco]$ cd nodes[linzepore@localhost nodes]$ ls127.0.0.1  cert[linzepore@localhost nodes]$ cd 127.0.0.1[linzepore@localhost 127.0.0.1]$ ./start_all.shtry to start node0try to start node1try to start node2try to start node3 node0 start successfully node2 start successfully node1 start successfully node3 start successfully[linzepore@localhost 127.0.0.1]$ ps -ef|grep -v grep|grep fisco-bcoslinzepo+   3958      1  1 10:41 pts/0    00:00:00 /home/linzepore/fisco/nodes/127.0.0.1/node1/../fisco-bcos -c config.inilinzepo+   3960      1  1 10:41 pts/0    00:00:00 /home/linzepore/fisco/nodes/127.0.0.1/node3/../fisco-bcos -c config.inilinzepo+   3962      1  1 10:41 pts/0    00:00:00 /home/linzepore/fisco/nodes/127.0.0.1/node2/../fisco-bcos -c config.inilinzepo+   3964      1  1 10:41 pts/0    00:00:00 /home/linzepore/fisco/nodes/127.0.0.1/node0/../fisco-bcos -c config.ini[linzepore@localhost 127.0.0.1]$ tail -f node0/log/log*\\grep connectedtail: 无法打开&quot;node0/log/log*grep&quot; 读取数据: 没有那个文件或目录tail: 无法打开&quot;connected&quot; 读取数据: 没有那个文件或目录tail: 没有剩余文件[linzepore@localhost 127.0.0.1]$ tail -f node0/log/log*|grep connectedinfo|2023-03-07 10:43:45.153141|[P2P][Service] heartBeat,connected count=3info|2023-03-07 10:43:55.153870|[P2P][Service] heartBeat,connected count=3info|2023-03-07 10:44:05.154141|[P2P][Service] heartBeat,connected count=3info|2023-03-07 10:44:15.154337|[P2P][Service] heartBeat,connected count=3^C[linzepore@localhost 127.0.0.1]$ tail -f node0/log/log*|grep +++info|2023-03-07 10:44:40.568786|[g:1][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=3,hash=28597e2f...info|2023-03-07 10:44:44.592018|[g:1][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=3,hash=ba8a21de...info|2023-03-07 10:44:48.617871|[g:1][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=3,hash=176eebf9...info|2023-03-07 10:44:52.639213|[g:1][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=3,hash=964fa6dd...^C[linzepore@localhost 127.0.0.1]$ sudo yum insstall -y java java-devel[sudo] linzepore 的密码：已加载插件：fastestmirror, langpacks没有该命令：insstall。请使用 /bin/yum --help[linzepore@localhost 127.0.0.1]$ sudo yum install -y java java-devel已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.ustc.edu.cn * extras: mirrors.aliyun.com * updates: mirrors.ustc.edu.cnbase                                                                                                                                                     | 3.6 kB  00:00:00     extras                                                                                                                                                   | 2.9 kB  00:00:00     updates                                                                                                                                                  | 2.9 kB  00:00:00     (1/4): base/7/x86_64/group_gz                                                                                                                            | 153 kB  00:00:00     (2/4): extras/7/x86_64/primary_db                                                                                                                        | 249 kB  00:00:03     (3/4): base/7/x86_64/primary_db                                                                                                                          | 6.1 MB  00:00:04     (4/4): updates/7/x86_64/primary_db                                                                                                                       |  19 MB  00:00:07     软件包 1:java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64 已安装并且是最新版本正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 java-1.8.0-openjdk-devel.x86_64.1.1.8.0.362.b08-1.el7_9 将被 安装--&gt; 正在处理依赖关系 java-1.8.0-openjdk(x86-64) = 1:1.8.0.362.b08-1.el7_9，它被软件包 1:java-1.8.0-openjdk-devel-1.8.0.362.b08-1.el7_9.x86_64 需要--&gt; 正在检查事务---&gt; 软件包 java-1.8.0-openjdk.x86_64.1.1.8.0.262.b10-1.el7 将被 升级---&gt; 软件包 java-1.8.0-openjdk.x86_64.1.1.8.0.362.b08-1.el7_9 将被 更新--&gt; 正在处理依赖关系 java-1.8.0-openjdk-headless(x86-64) = 1:1.8.0.362.b08-1.el7_9，它被软件包 1:java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64 需要--&gt; 正在检查事务---&gt; 软件包 java-1.8.0-openjdk-headless.x86_64.1.1.8.0.262.b10-1.el7 将被 升级---&gt; 软件包 java-1.8.0-openjdk-headless.x86_64.1.1.8.0.362.b08-1.el7_9 将被 更新--&gt; 正在处理依赖关系 tzdata-java &gt;= 2022g，它被软件包 1:java-1.8.0-openjdk-headless-1.8.0.362.b08-1.el7_9.x86_64 需要--&gt; 正在检查事务---&gt; 软件包 tzdata-java.noarch.0.2020a-1.el7 将被 升级---&gt; 软件包 tzdata-java.noarch.0.2022g-1.el7 将被 更新--&gt; 解决依赖关系完成依赖关系解决================================================================================================================================================================================ Package                                              架构                            版本                                               源                                大小================================================================================================================================================================================正在安装: java-1.8.0-openjdk-devel                             x86_64                          1:1.8.0.362.b08-1.el7_9                            updates                          9.8 M为依赖而更新: java-1.8.0-openjdk                                   x86_64                          1:1.8.0.362.b08-1.el7_9                            updates                          317 k java-1.8.0-openjdk-headless                          x86_64                          1:1.8.0.362.b08-1.el7_9                            updates                           33 M tzdata-java                                          noarch                          2022g-1.el7                                        updates                          185 k事务概要================================================================================================================================================================================安装  1 软件包升级           ( 3 依赖软件包)总下载量：43 MDownloading packages:No Presto metadata available for updates警告：/var/cache/yum/x86_64/7/updates/packages/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: NOKEY/s | 321 kB  --:--:-- ETA java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64.rpm 的公钥尚未安装(1/4): java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64.rpm                                                                                               | 317 kB  00:00:00     (2/4): tzdata-java-2022g-1.el7.noarch.rpm                                                                                                                | 185 kB  00:00:00     (3/4): java-1.8.0-openjdk-devel-1.8.0.362.b08-1.el7_9.x86_64.rpm                                                                                         | 9.8 MB  00:00:04     (4/4): java-1.8.0-openjdk-headless-1.8.0.362.b08-1.el7_9.x86_64.rpm                                                                                      |  33 MB  00:02:30     --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------总计                                                                                                                                            296 kB/s |  43 MB  00:02:30     从 file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 检索密钥导入 GPG key 0xF4A80EB5: 用户ID     : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot; 指纹       : 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5 软件包     : centos-release-7-9.2009.0.el7.centos.x86_64 (@anaconda) 来自       : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7Running transaction checkRunning transaction testTransaction test succeededRunning transaction  正在更新    : tzdata-java-2022g-1.el7.noarch                                                                                                                              1/7   正在更新    : 1:java-1.8.0-openjdk-headless-1.8.0.362.b08-1.el7_9.x86_64                                                                                                  2/7 warning: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/blacklisted.certs created as /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/blacklisted.certs.rpmnewwarning: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.policy created as /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.policy.rpmnewwarning: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.security created as /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.security.rpmnewrestored /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/blacklisted.certs.rpmnew to /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/blacklisted.certsrestored /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.policy.rpmnew to /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.policyrestored /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.security.rpmnew to /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64/jre/lib/security/java.security  正在更新    : 1:java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64                                                                                                           3/7   正在安装    : 1:java-1.8.0-openjdk-devel-1.8.0.362.b08-1.el7_9.x86_64                                                                                                     4/7   清理        : 1:java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64                                                                                                             5/7   清理        : 1:java-1.8.0-openjdk-headless-1.8.0.262.b10-1.el7.x86_64                                                                                                    6/7   清理        : tzdata-java-2020a-1.el7.noarch                                                                                                                              7/7   验证中      : 1:java-1.8.0-openjdk-headless-1.8.0.362.b08-1.el7_9.x86_64                                                                                                  1/7   验证中      : 1:java-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64                                                                                                           2/7   验证中      : tzdata-java-2022g-1.el7.noarch                                                                                                                              3/7   验证中      : 1:java-1.8.0-openjdk-devel-1.8.0.362.b08-1.el7_9.x86_64                                                                                                     4/7   验证中      : 1:java-1.8.0-openjdk-headless-1.8.0.262.b10-1.el7.x86_64                                                                                                    5/7   验证中      : 1:java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64                                                                                                             6/7   验证中      : tzdata-java-2020a-1.el7.noarch                                                                                                                              7/7 已安装:  java-1.8.0-openjdk-devel.x86_64 1:1.8.0.362.b08-1.el7_9                                                                                                                       作为依赖被升级:  java-1.8.0-openjdk.x86_64 1:1.8.0.362.b08-1.el7_9            java-1.8.0-openjdk-headless.x86_64 1:1.8.0.362.b08-1.el7_9            tzdata-java.noarch 0:2022g-1.el7           完毕！[linzepore@localhost 127.0.0.1]$ vi ./etc/profile[linzepore@localhost 127.0.0.1]$ vi /etc/profile[已修改但尚未保存]/bin/bash: q: 未找到命令Shell 已返回127请按 ENTER 或其它命令继续[linzepore@localhost 127.0.0.1]$ cd /usr/lib/jvm[linzepore@localhost jvm]$ lsjava                                                java-openjdk                                       jre-1.8.0java-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64  jre                                                jre-1.8.0-openjdkjava-1.8.0                                          jre-1.7.0                                          jre-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64java-1.8.0-openjdk                                  jre-1.7.0-openjdk                                  jre-openjdkjava-1.8.0-openjdk-1.8.0.362.b08-1.el7_9.x86_64     jre-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64[linzepore@localhost jvm]$ cd java-1.8.0 [linzepore@localhost java-1.8.0]$ lsASSEMBLY_EXCEPTION  bin  include  jre  lib  LICENSE  tapset  THIRD_PARTY_README[linzepore@localhost java-1.8.0]$ cd lib[linzepore@localhost lib]$ lsamd64  ct.sym  dt.jar  ir.idl  jconsole.jar  jexec  orb.idl  sa-jdi.jar  tools.jar[linzepore@localhost lib]$ cd ..[linzepore@localhost java-1.8.0]$ cd ..[linzepore@localhost jvm]$ cd /[linzepore@localhost /]$ vi etc/profile[已修改但尚未保存]/bin/bash: q: 未找到命令Shell 已返回127请按 ENTER 或其它命令继续[linzepore@localhost /]$ sudo vi etc/profile[sudo] linzepore 的密码：[linzepore@localhost /]$ source etc/profile[linzepore@localhost /]$ echo JAVA_HOMEJAVA_HOME[linzepore@localhost /]$ echo $&#123;JAVA_HOME&#125;/usr/lib/jvm/java-1.8.0[linzepore@localhost /]$ echo $&#123;JRE_HOME&#125;/usr/lib/jvm/java-1.8.0/jre[linzepore@localhost /]$ echo $&#123;PATH&#125;&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ sudo vi etc/profile[linzepore@localhost /]$ echo $&#123;PATH&#125;&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ source etc/profile[linzepore@localhost /]$ echo $&#123;PATH&#125;/usr/lib/jvm/java-1.8.0/bin:&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ sudo vi etc/profile[linzepore@localhost /]$ echo $&#123;PATH&#125;/usr/lib/jvm/java-1.8.0/bin:&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ source etc/profile[linzepore@localhost /]$ echo $&#123;PATH&#125;/usr/lib/jvm/java-1.8.0/bin:/usr/lib/jvm/java-1.8.0/bin:&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ source etc/profile[linzepore@localhost /]$ echo $&#123;PATH&#125;/usr/lib/jvm/java-1.8.0/bin:/usr/lib/jvm/java-1.8.0/bin:/usr/lib/jvm/java-1.8.0/bin:&#123;JAVA_HOME&#125;/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/linzepore/.local/bin:/home/linzepore/bin[linzepore@localhost /]$ cd ~[linzepore@localhost ~]$ wget https://osp-1257653870.cos.ap-guangdong.myqcloud.com/weBASE/releases/download/v1.5.3/webase-front.zip--2023-03-07 11:13:45--  https://osp-1257653870.cos.ap-guangdong.myqcloud.com/weBASE/releases/download/v1.5.3/webase-front.zip正在解析主机 osp-1257653870.cos.ap-guangdong.myqcloud.com (osp-1257653870.cos.ap-guangdong.myqcloud.com)... 失败：未知的名称或服务。wget: 无法解析主机地址 “osp-1257653870.cos.ap-guangdong.myqcloud.com”[linzepore@localhost ~]$ wget http:/tools.zepo.re/0c5c52c7--2023-03-07 11:17:10--  ftp://http//tools.zepo.re/0c5c52c7           =&gt; “0c5c52c7”正在解析主机 http (http)... ^[[A^C[linzepore@localhost ~]$ wget http://tools.zepo.re/0c5c52c7--2023-03-07 11:17:23--  http://tools.zepo.re/0c5c52c7正在解析主机 tools.zepo.re (tools.zepo.re)... 104.21.47.181, 172.67.171.203, 2606:4700:3032::ac43:abcb, ...正在连接 tools.zepo.re (tools.zepo.re)|104.21.47.181|:80... 已连接。已发出 HTTP 请求，正在等待回应... 301 Moved Permanently位置：https://tools.zepo.re/0c5c52c7 [跟随至新的 URL]--2023-03-07 11:17:24--  https://tools.zepo.re/0c5c52c7正在连接 tools.zepo.re (tools.zepo.re)|104.21.47.181|:443... 已连接。已发出 HTTP 请求，正在等待回应... 302 Found位置：https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.3/webase-front.zip [跟随至新的 URL]--2023-03-07 11:17:25--  https://osp-1257653870.cos.ap-guangzhou.myqcloud.com/WeBASE/releases/download/v1.5.3/webase-front.zip正在解析主机 osp-1257653870.cos.ap-guangzhou.myqcloud.com (osp-1257653870.cos.ap-guangzhou.myqcloud.com)... 27.155.119.181, 27.155.119.179, 27.155.119.180, ...正在连接 osp-1257653870.cos.ap-guangzhou.myqcloud.com (osp-1257653870.cos.ap-guangzhou.myqcloud.com)|27.155.119.181|:443... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：110965309 (106M) [application/zip]正在保存至: “0c5c52c7”100%[======================================&gt;] 110,965,309 18.4MB/s 用时 10s    2023-03-07 11:17:37 (10.1 MB/s) - 已保存 “0c5c52c7” [110965309/110965309])[linzepore@localhost ~]$ ls0c5c52c7  fisco  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ cd 0c5c52c7bash: cd: 0c5c52c7: 不是目录[linzepore@localhost ~]$ unzip 0c5c52c7.zipunzip:  cannot find or open 0c5c52c7.zip, 0c5c52c7.zip.zip or 0c5c52c7.zip.ZIP.[linzepore@localhost ~]$ unzip 0c5c52c7Archive:  0c5c52c7   creating: webase-front/  inflating: webase-front/status.sh     creating: webase-front/conf/   creating: webase-front/conf/conf/  inflating: webase-front/conf/conf/sdk.publickey     creating: webase-front/conf/conf/gm/  inflating: webase-front/conf/conf/gm/gmsdk.publickey    inflating: webase-front/conf/template    inflating: webase-front/conf/libsigar-x86-linux.so    inflating: webase-front/conf/libsigar-amd64-linux.so    inflating: webase-front/conf/application-docker.yml    inflating: webase-front/conf/libsigar-universal64-macosx.dylib     creating: webase-front/conf/files/  inflating: webase-front/conf/files/ContractAbiMgr_     creating: webase-front/conf/swagger/  inflating: webase-front/conf/swagger/swagger-ui-bundle.js    inflating: webase-front/conf/swagger/swagger-ui.js    inflating: webase-front/conf/swagger/swagger-ui-standalone-preset.js   extracting: webase-front/conf/swagger/favicon-32x32.png    inflating: webase-front/conf/swagger/index.html    inflating: webase-front/conf/swagger/swagger-ui.css    inflating: webase-front/conf/swagger/swagger-ui.css.map   extracting: webase-front/conf/swagger/favicon-16x16.png    inflating: webase-front/conf/swagger/swagger-ui-bundle.js.map    inflating: webase-front/conf/swagger/swagger-ui.js.map    inflating: webase-front/conf/swagger/swagger-ui-standalone-preset.js.map    inflating: webase-front/conf/application.yml    inflating: webase-front/conf/libsigar-aarch64-linux.so    inflating: webase-front/conf/log4j2.xml    inflating: webase-front/stop.sh       creating: webase-front/lib/  inflating: webase-front/lib/jackson-annotations-2.11.4.jar    inflating: webase-front/lib/spring-plugin-core-1.2.0.RELEASE.jar    inflating: webase-front/lib/hibernate-entitymanager-5.0.12.Final.jar    inflating: webase-front/lib/log4j-api-2.15.0.jar    inflating: webase-front/lib/lombok-1.18.6.jar    inflating: webase-front/lib/tomcat-annotations-api-8.5.56.jar    inflating: webase-front/lib/tcnative-2.0.34.0.jar    inflating: webase-front/lib/error_prone_annotations-2.3.4.jar    inflating: webase-front/lib/activation-1.1.1.jar    inflating: webase-front/lib/solc-gradle-plugin-1.0.1.jar    inflating: webase-front/lib/tomcat-embed-el-8.5.56.jar    inflating: webase-front/lib/spring-boot-starter-data-jpa-1.5.22.RELEASE.jar    inflating: webase-front/lib/spring-tx-4.3.29.RELEASE.jar    inflating: webase-front/lib/spring-boot-configuration-processor-1.5.22.RELEASE.jar    inflating: webase-front/lib/springfox-core-2.8.0.jar    inflating: webase-front/lib/byte-buddy-1.7.9.jar    inflating: webase-front/lib/log4j-slf4j-impl-2.15.0.jar    inflating: webase-front/lib/aspectjweaver-1.8.14.jar    inflating: webase-front/lib/SmartDev-Scaffold-1.0.0.1.jar    inflating: webase-front/lib/commons-codec-1.6.jar    inflating: webase-front/lib/checker-qual-2.11.1.jar    inflating: webase-front/lib/httpclient-4.3.6.jar    inflating: webase-front/lib/spring-boot-autoconfigure-1.5.22.RELEASE.jar    inflating: webase-front/lib/log4j-web-2.15.0.jar    inflating: webase-front/lib/springfox-swagger2-2.8.0.jar    inflating: webase-front/lib/solcJ-0.4.25.1.jar    inflating: webase-front/lib/springfox-schema-2.8.0.jar    inflating: webase-front/lib/springfox-swagger-common-2.8.0.jar    inflating: webase-front/lib/spring-boot-starter-aop-1.5.22.RELEASE.jar    inflating: webase-front/lib/commons-lang3-3.8.1.jar    inflating: webase-front/lib/jackson-datatype-jsr310-2.11.4.jar    inflating: webase-front/lib/spring-amqp-1.7.14.RELEASE.jar    inflating: webase-front/lib/jboss-logging-3.3.0.Final.jar    inflating: webase-front/lib/spring-boot-starter-1.5.22.RELEASE.jar    inflating: webase-front/lib/httpcore-4.3.3.jar    inflating: webase-front/lib/reflections-0.9.11.jar    inflating: webase-front/lib/jcl-over-slf4j-1.7.30.jar    inflating: webase-front/lib/spring-boot-starter-amqp-1.5.22.RELEASE.jar    inflating: webase-front/lib/jackson-databind-2.11.4.jar    inflating: webase-front/lib/hibernate-validator-5.3.6.Final.jar    inflating: webase-front/lib/spring-core-4.3.29.RELEASE.jar    inflating: webase-front/lib/spring-plugin-metadata-1.2.0.RELEASE.jar    inflating: webase-front/lib/toml4j-0.7.2.jar    inflating: webase-front/lib/guava-29.0-jre.jar    inflating: webase-front/lib/hibernate-core-5.0.12.Final.jar    inflating: webase-front/lib/tomcat-juli-8.5.56.jar    inflating: webase-front/lib/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar    inflating: webase-front/lib/swagger-annotations-1.5.14.jar    inflating: webase-front/lib/gson-2.8.1.jar    inflating: webase-front/lib/slf4j-api-1.7.30.jar    inflating: webase-front/lib/dom4j-1.6.1.jar    inflating: webase-front/lib/jsr305-3.0.2.jar    inflating: webase-front/lib/validation-api-1.1.0.Final.jar    inflating: webase-front/lib/bcprov-jdk15on-1.60.jar    inflating: webase-front/lib/spring-context-4.3.29.RELEASE.jar    inflating: webase-front/lib/xml-apis-1.0.b2.jar    inflating: webase-front/lib/spring-boot-starter-tomcat-1.5.22.RELEASE.jar    inflating: webase-front/lib/spring-beans-4.3.29.RELEASE.jar    inflating: webase-front/lib/sigar-1.6.4.jar    inflating: webase-front/lib/spring-aop-4.3.29.RELEASE.jar    inflating: webase-front/lib/hibernate-commons-annotations-5.0.1.Final.jar    inflating: webase-front/lib/classmate-1.3.4.jar    inflating: webase-front/lib/netty-sm-ssl-context-1.2.0.jar    inflating: webase-front/lib/netty-all-4.1.53.Final.jar    inflating: webase-front/lib/jaxb-impl-2.3.0.jar    inflating: webase-front/lib/spring-test-4.3.29.RELEASE.jar    inflating: webase-front/lib/spring-expression-4.3.29.RELEASE.jar    inflating: webase-front/lib/tomcat-embed-websocket-8.5.56.jar    inflating: webase-front/lib/hibernate-jpa-2.1-api-1.0.0.Final.jar    inflating: webase-front/lib/jaxb-core-2.3.0.jar    inflating: webase-front/lib/spring-boot-1.5.22.RELEASE.jar    inflating: webase-front/lib/amqp-client-4.0.3.jar    inflating: webase-front/lib/failureaccess-1.0.1.jar    inflating: webase-front/lib/spring-rabbit-1.7.14.RELEASE.jar    inflating: webase-front/lib/swagger-models-1.5.14.jar    inflating: webase-front/lib/spring-retry-1.2.4.RELEASE.jar    inflating: webase-front/lib/http-client-1.1.1.RELEASE.jar    inflating: webase-front/lib/javax.transaction-api-1.2.jar    inflating: webase-front/lib/tomcat-jdbc-8.5.56.jar    inflating: webase-front/lib/springfox-spi-2.8.0.jar    inflating: webase-front/lib/solscaffold-1.0.2.jar    inflating: webase-front/lib/javassist-3.21.0-GA.jar    inflating: webase-front/lib/jsqlparser-2.0.jar    inflating: webase-front/lib/antlr-2.7.7.jar    inflating: webase-front/lib/spring-webmvc-4.3.29.RELEASE.jar    inflating: webase-front/lib/tomcat-embed-core-8.5.56.jar    inflating: webase-front/lib/spring-jdbc-4.3.29.RELEASE.jar    inflating: webase-front/lib/spring-messaging-4.3.29.RELEASE.jar    inflating: webase-front/lib/log4j-core-2.15.0.jar    inflating: webase-front/lib/h2-1.4.200.jar    inflating: webase-front/lib/spring-boot-starter-jdbc-1.5.22.RELEASE.jar    inflating: webase-front/lib/jaxb-api-2.3.0.jar    inflating: webase-front/lib/spring-data-jpa-1.11.23.RELEASE.jar    inflating: webase-front/lib/springfox-swagger-ui-2.8.0.jar    inflating: webase-front/lib/spring-boot-starter-web-1.5.22.RELEASE.jar    inflating: webase-front/lib/jackson-core-2.11.4.jar    inflating: webase-front/lib/picocli-4.6.1.jar    inflating: webase-front/lib/fisco-bcos-java-sdk-2.7.2.jar    inflating: webase-front/lib/springfox-spring-web-2.8.0.jar    inflating: webase-front/lib/spring-web-4.3.29.RELEASE.jar    inflating: webase-front/lib/jandex-2.0.0.Final.jar    inflating: webase-front/lib/j2objc-annotations-1.3.jar    inflating: webase-front/lib/commons-io-2.4.jar    inflating: webase-front/lib/javapoet-1.7.0.jar    inflating: webase-front/lib/spring-orm-4.3.29.RELEASE.jar    inflating: webase-front/lib/spring-data-commons-1.13.23.RELEASE.jar    inflating: webase-front/lib/snakeyaml-1.17.jar    inflating: webase-front/lib/commons-logging-1.2.jar    inflating: webase-front/lib/key-mini-toolkit-1.0.3.jar    inflating: webase-front/lib/mapstruct-1.2.0.Final.jar    inflating: webase-front/lib/spring-aspects-4.3.29.RELEASE.jar     creating: webase-front/gradle/   creating: webase-front/gradle/wrapper/  inflating: webase-front/gradle/wrapper/gradle-wrapper.jar    inflating: webase-front/gradle/wrapper/gradle-wrapper.properties    inflating: webase-front/start.sh     inflating: webase-front/get_solc_js.sh     creating: webase-front/static/  inflating: webase-front/static/index.html     creating: webase-front/static/static/   creating: webase-front/static/static/fonts/  inflating: webase-front/static/static/fonts/fontello.e73a064.eot    inflating: webase-front/static/static/fonts/iconfont.8ddfca3.eot    inflating: webase-front/static/static/fonts/fontello.068ca2b.ttf    inflating: webase-front/static/static/fonts/iconfont.ee39531.ttf    inflating: webase-front/static/static/fonts/element-icons.535877f.woff    inflating: webase-front/static/static/fonts/element-icons.732389d.ttf     creating: webase-front/static/static/js/  inflating: webase-front/static/static/js/5.3de44c8af7d57401ccff.js    inflating: webase-front/static/static/js/v0.4.25.js    inflating: webase-front/static/static/js/v0.6.10-gm.js    inflating: webase-front/static/static/js/10.4ec34b4c668409851945.js    inflating: webase-front/static/static/js/v0.4.25-gm.js    inflating: webase-front/static/static/js/7.9a8a4f53acd01c9cb183.js    inflating: webase-front/static/static/js/6.af6ac9aab23086b4000b.js    inflating: webase-front/static/static/js/12.80cc7afdc7d342baa5fb.js    inflating: webase-front/static/static/js/base-loading.js    inflating: webase-front/static/static/js/1.d36c3ac2e1e33301d217.js   extracting: webase-front/static/static/js/10.4ec34b4c668409851945.js.gz    inflating: webase-front/static/static/js/1.d36c3ac2e1e33301d217.js.gz    inflating: webase-front/static/static/js/web3.min.js.gz    inflating: webase-front/static/static/js/2.6602fb5a113f7b41a7b7.js    inflating: webase-front/static/static/js/0.ae1f106e6753c022a156.js.gz    inflating: webase-front/static/static/js/v0.6.10.js    inflating: webase-front/static/static/js/17.4018b6dc2baa10d8984a.js    inflating: webase-front/static/static/js/13.055b0a18633af2c97aa9.js    inflating: webase-front/static/static/js/0.ae1f106e6753c022a156.js    inflating: webase-front/static/static/js/5.3de44c8af7d57401ccff.js.gz    inflating: webase-front/static/static/js/11.2a8233ac71b1166c4189.js    inflating: webase-front/static/static/js/6.af6ac9aab23086b4000b.js.gz    inflating: webase-front/static/static/js/9.5047e29e39abbe3fdf76.js    inflating: webase-front/static/static/js/14.5dd9ee26d1fa8898120f.js    inflating: webase-front/static/static/js/16.4d0153a2620c5489082b.js    inflating: webase-front/static/static/js/15.120cd94287d0c8f016f6.js    inflating: webase-front/static/static/js/3.eb12a41a6deb04d256ae.js.gz    inflating: webase-front/static/static/js/8.3b8ae5b298eeba40c9cb.js    inflating: webase-front/static/static/js/browserfs.min.js   extracting: webase-front/static/static/js/12.80cc7afdc7d342baa5fb.js.gz   extracting: webase-front/static/static/js/7.9a8a4f53acd01c9cb183.js.gz    inflating: webase-front/static/static/js/browserfs.min.js.gz    inflating: webase-front/static/static/js/3.eb12a41a6deb04d256ae.js    inflating: webase-front/static/static/js/v0.5.2-gm.js    inflating: webase-front/static/static/js/19.9be217e8770c86e8fbf4.js    inflating: webase-front/static/static/js/v0.5.2.js    inflating: webase-front/static/static/js/runtime.ae846189f4d523a0caf3.js    inflating: webase-front/static/static/js/18.d979e449a918792042e9.js    inflating: webase-front/static/static/js/web3.min.js     creating: webase-front/static/static/font/ extracting: webase-front/static/static/font/webfont.ttf   extracting: webase-front/static/static/font/webfont.woff    inflating: webase-front/static/static/font/webfont.svg   extracting: webase-front/static/static/font/webfont.eot   extracting: webase-front/static/static/font/webfont.woff2     creating: webase-front/static/static/img/ extracting: webase-front/static/static/img/transationPedding.d68f750.png   extracting: webase-front/static/static/img/transation.1a3785f.png    inflating: webase-front/static/static/img/fontello.9354499.svg    inflating: webase-front/static/static/img/iconfont.7fa1e8d.svg     creating: webase-front/static/static/image/ extracting: webase-front/static/static/image/logo@2x.png    inflating: webase-front/static/static/image/logo-title.png    inflating: webase-front/static/static/image/logo-2 copy@1.5x.jpg    inflating: webase-front/static/static/image/banner.jpg    inflating: webase-front/static/static/image/block.png   extracting: webase-front/static/static/image/logo.jpg   extracting: webase-front/static/static/image/webase_35x35.png   extracting: webase-front/static/static/image/transation.png    inflating: webase-front/static/static/image/nodes.png   extracting: webase-front/static/static/image/transationPedding.png     creating: webase-front/static/static/css/  inflating: webase-front/static/static/css/base.css    inflating: webase-front/static/static/css/reset.css     creating: webase-front/apps/  inflating: webase-front/apps/WeBASE-Front.jar   extracting: webase-front/release_note.txt  [linzepore@localhost ~]$ ls0c5c52c7  fisco  webase-front  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ rm 0c5c52c7[linzepore@localhost ~]$ lsfisco  webase-front  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ cp -r fisco/nodes/127.0.0.1/sdk/* webase-front/conf[linzepore@localhost ~]$ lsfisco  webase-front  公共  模板  视频  图片  文档  下载  音乐  桌面[linzepore@localhost ~]$ cd webase-front/conf[linzepore@localhost conf]$ lsapplication-docker.yml     libsigar-amd64-linux.so            sdk.crtapplication.yml            libsigar-universal64-macosx.dylib  sdk.keyca.crt                     libsigar-x86-linux.so              sdk.publickeyconf                       log4j2.xml                         swaggerfiles                      node.crt                           templatelibsigar-aarch64-linux.so  node.key[linzepore@localhost conf]$ cd..bash: cd..: 未找到命令...[linzepore@localhost conf]$ cd ..[linzepore@localhost webase-front]$ bash start.sh===============================================================================================Server com.webank.webase.front.Application Port 5002 ....PID(6230) [Starting]. Please check message through the log file (default path:./log/).===============================================================================================\n步骤分析配置Fisco在当前用户目录下，创建fisco目录：cd ~ &amp;&amp; mkdir fisco\n给fisco文件夹加权限然后进入：cd ~ &amp;&amp; chmod u+x fisco &amp;&amp; cd fisco\n下载安装build_chain.sh：curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh\n运行build_chain.sh：./build_chain.sh，如下图则为下载完成\n指定链的标识符：./build_chain.sh -l &quot;127.0.0.1:4&quot; -p 30300,20200,8454，如图二则成功完成\n\n确保文件存放位置无误后，开启节点：cd ~/fisco/nodes/127.0.0.1 ./start_all.sh，有四个节点则为成功部署\n查找正在运行的 fisco-bcos 进程：ps -ef|grep -v grep|grep fisco-bcos\n依次执行tail -f node0/log/log*|grep connected tail -f node0/log/log*|grep +++\n安装jdk：sudo yum install -y java java-devel\n配置环境变量：sudo vi etc/profile，在下方添加（可自行进入”&#x2F;usr&#x2F;lib&#x2F;jvm“进行查看版本号及目录名称）\nexport JAVA_HOME=/usr/lib/jvm/java-1.8.0export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n\n刷新：source etc/profile\n下载weBASE:wget http:/tools.zepo.re/0c5c52c7\n解压：unzip 0c5c52c7，然后把Fisco-Bcos的SDK复制到weBASE-Front：cp -r fisco/nodes/127.0.0.1/sdk/* webase-front/conf\n在解压后主目录下执行脚本：bash start.sh，浏览器打开”http://localhost:5002/WeBASE-Front“\n\n出现错误及相应解决curl: (6) Could not resolve host: github.com; 未知的错误\n\n没有开网络\n\n","categories":["Learning","Blockchain","Fisco","Competition"],"tags":["tech","learning","blockchain","fisco"]},{"title":"23-03-10","url":"/2023/03/10/2023-03-10.html/","content":"2023-03-10~2023-03-11 | 搭链一些问题留档问题启动WeBase-Front必须在本目录下尝试在上一层目录下执行脚本，出现：\n[root@localhost fisco]# bash webase-front/start.shcat: /root/fisco/conf/application.yml: 没有那个文件或目录/root/fisco/conf/application.yml server port has not been configured[root@localhost fisco]# cd confbash: cd: conf: 没有那个文件或目录\n\n脚本会默认在当前目录找application.yml\n\n打#变成今天重新安装Linux之后发现输入#号变成了£符号\n\n\n英语输入法设置成了英国区，改成美国就回来了\n或者参考-&gt;Why is my @ symbol not working，执行sudo vi /etc/default/keyboard之后，找到XKBLAYOUT=“gb”修改成us\n\n\nwebase-front启动失败[root@localhost webase-front]# bash start.sh ===============================================================================================Server com.webank.webase.front.Application Port 5002 ................................[Failed]. Please check message through the log file (default path:./log/).===============================================================================================[root@localhost webase-front]# cat ./log/cat: ./log/: 是一个目录[root@localhost webase-front]# cd ./log/[root@localhost log]# lsfront.out[root@localhost log]# cat front.out nohup: 无法运行命令&quot;/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/bin/java&quot;: 没有那个文件或目录[root@localhost log]# cd usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/bin/bash: cd: usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/bin/: 没有那个文件或目录\n找到脚本start.sh，发现只需要Java-Home\n\n把JRE_HOME删除，然后JAVA_HOME后面添加/jre\n还是没出现？CTRL + Shift + R，刷新浏览器缓存\n\nfisco-bcos未找到命令\n\nfisco-bcos-&gt;./fisco-bcos\n\n\n命令查找真实路径which—— which java是无法定位到Java的安装路径的，只能定位到执行路径\nls -lrt——ls -lrt解析：即将文件以建立时间先后顺序的倒叙排列显示，从上面的结果可以看出，/usr/bin/java是执行路径，那么继续执行后面的文件路径，即可找到JDK的安装路径为/usr/lib/jvm/java-1.8.0\n[root@localhost /]# which java/usr/bin/java[root@localhost /]# ls -lrt /usr/bin/javalrwxrwxrwx. 1 root root 22 3月  10 2023 /usr/bin/java -&gt; /etc/alternatives/java[root@localhost /]# ls -lrt /etc/alternatives/javalrwxrwxrwx. 1 root root 71 3月  10 2023 /etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/jre/bin/java[root@localhost /]# cd /usr/lib/jvm[root@localhost jvm]# lsjava-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64jrejre-1.7.0jre-1.7.0-openjdkjre-1.7.0-openjdk-1.7.0.261-2.6.22.2.el7_8.x86_64jre-1.8.0jre-1.8.0-openjdkjre-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64jre-openjdk\n","categories":["Learning","Blockchain","Fisco-Bcos","Competition"],"tags":["tech","learning","blockchain","fisco"]},{"title":"23-03-11","url":"/2023/03/11/2023-03-11.html/","content":"2023-03-10 | 扩容一个新节点Fisco-Bcos扩容新节点相关文章-&gt;扩容一个新节点\n概念FISCO BCOS引入了游离节点、观察者节点和共识节点，这三种节点类型可通过控制台相互转换。\n\n共识节点：参与共识的节点，拥有群组的所有数据（搭链时默认都生成共识节点）。\n\n观察者节点：不参与共识，但能实时同步链上数据的节点。\n\n游离节点：已启动，待等待加入群组的节点。处在一种暂时的节点状态，不能获取链上的数据。\n\n\n步骤为节点生成证书并启动获取证书下载脚本curl -#LO https://raw.githubusercontent.com/FISCO-BCOS/FISCO-BCOS/master-2.0/tools/gen_node_cert.sh\n\n执行脚本生成新节点证书# -c指定机构证书及私钥所在路径# -o输出到指定文件夹，其中node4/conf中会存在机构agency新签发的证书和私钥# 成功会输出 All completed 提示bash gen_node_cert.sh -c ../cert/agency -o node4\n\n复制文件到node4目录拷贝node0目录下start.sh、stop.sh脚本和config.ini配置到node4目录\ncp node0/config.ini node0/start.sh node0/stop.sh node4/\n\n配置参数一共需要修改四处\n$ vim node4/config.ini[rpc]    ;rpc listen ip    listen_ip=127.0.0.1    ;channelserver listen port    channel_listen_port=20204 #第一处    ;jsonrpc listen port    jsonrpc_listen_port=8549 #第二处[p2p]    ;p2p listen ip    listen_ip=0.0.0.0    ;p2p listen port    listen_port=30304 #第三处    ;nodes to connect    node.0=127.0.0.1:30300    node.1=127.0.0.1:30301    node.2=127.0.0.1:30302    node.3=127.0.0.1:30303    node.4=127.0.0.1:30304 #第四处\n\n拷贝群组相关文件拷贝节点1的node0/conf/group.1.genesis（内含群组节点初始列表）和node0/conf/group.1.ini到node4/conf目录下，不需改动\ncp node0/conf/group.1.genesis node0/conf/group.1.ini node4/conf/\n\n启动新节点在node4目录执行start.sh脚本启动节点\nbash node4/start.sh\n\n检查节点启动情况确认node4与其他节点连接已经建立，加入网络操作完成\ntail -f node4/log/log*  | grep &quot;connected&quot;\n# 以下日志表明节点node4与其他4个节点建立了连接[root@localhost localhost]# tail node0/log/log* -f | grep -v grep | grep connectedinfo|2023-03-11 11:44:29.722535|[P2P][Service] heartBeat,connected count=4info|2023-03-11 11:44:39.722712|[P2P][Service] heartBeat,connected count=4\n\n新节点加入群组获取node4的nodeidcat node4/conf/node.nodeid\n加入group:1使用addObserver将node4作为观察节点加入群组1\n[group:1]&gt; getObserverList[][group:1]&gt; addObserver 94ae60f93ef9a25a93666e0149b7b4cb0e044a61b7dcd1b00096f2bdb17d1c6853fc81a24e037c9d07803fcaf78f768de2ba56a4f729ef91baeadaa55a8ccd6e&#123;    &quot;code&quot;:1,    &quot;msg&quot;:&quot;Success&quot;&#125;[group:1]&gt; getObserverList[    94ae60f93ef9a25a93666e0149b7b4cb0e044a61b7dcd1b00096f2bdb17d1c6853fc81a24e037c9d07803fcaf78f768de2ba56a4f729ef91baeadaa55a8ccd6e]\n\n使用addSealer将node4作为共识节点加入群组1\n[group:1]&gt; getSealerList[    6c41f7e138051a13a220cb186e934398e37700295ff355b87f113704996b3e03750100e16653cda18b5f954d3b7b08d068ca4a9d65cec5a40db980b697ffb699,    7404cdf7f34f038aba90059ff25dc5f05f538010c55e98976aea6bc954910f34f15a255869751c8fe564bdb0fa1eee8e2db47eeca0fdd1359beaac6adcd37ede,    a7b856e5b59072c809ea963fa45ede72f7d37561affff989fbede6cd61a40137e2146db205434788e61b89a57f08c614cd283e5e915c23714c2fa685237e8bdb,    e5ea1e18717418a57f115bf1cea5168250f86e5b77f74dd15d0c4bf3758ca37002059ba2e54131296d1646a62be5faf85e243dac8d33d452acd63e20428b72ed][group:1]&gt; addSealer 94ae60f93ef9a25a93666e0149b7b4cb0e044a61b7dcd1b00096f2bdb17d1c6853fc81a24e037c9d07803fcaf78f768de2ba56a4f729ef91baeadaa55a8ccd6e&#123;    &quot;code&quot;:1,    &quot;msg&quot;:&quot;Success&quot;&#125;[group:1]&gt; getSealerList[    6c41f7e138051a13a220cb186e934398e37700295ff355b87f113704996b3e03750100e16653cda18b5f954d3b7b08d068ca4a9d65cec5a40db980b697ffb699,    7404cdf7f34f038aba90059ff25dc5f05f538010c55e98976aea6bc954910f34f15a255869751c8fe564bdb0fa1eee8e2db47eeca0fdd1359beaac6adcd37ede,    a7b856e5b59072c809ea963fa45ede72f7d37561affff989fbede6cd61a40137e2146db205434788e61b89a57f08c614cd283e5e915c23714c2fa685237e8bdb,    e5ea1e18717418a57f115bf1cea5168250f86e5b77f74dd15d0c4bf3758ca37002059ba2e54131296d1646a62be5faf85e243dac8d33d452acd63e20428b72ed,    94ae60f93ef9a25a93666e0149b7b4cb0e044a61b7dcd1b00096f2bdb17d1c6853fc81a24e037c9d07803fcaf78f768de2ba56a4f729ef91baeadaa55a8ccd6e]\n\n节点管理参考文章-&gt;节点管理\n多群组部署实现新建文件[root@localhost /]# cd fisco2  &amp;&amp; cat &gt; ipconf &lt;&lt;HHH&gt; localhost:2 agencyA 1,2&gt; localhost:2 agencyB 1&gt; HHH[root@localhost fisco2]# cat ipconflocalhost:2 agencyA 1,2 # agencyA：在127.0.0.1上有2个节点，同时属于group1、group2；localhost:2 agencyB 1   # agencyB：在127.0.0.1上有2个节点，属于group1；\n使用配置文件创建节点bash build_chain.sh -f ./ipconf -e ./fisco\n启动节点[root@localhost localhost]# bash ./start_all.sh try to start node0try to start node1try to start node2try to start node3 node0 start successfully node3 start successfully node2 start successfully node1 start successfully\n检查连接以及是否产生共识[root@localhost localhost]# ps -ef | grep -v grep | grep fisco-bcosroot      69993      1  2 20:11 pts/0    00:00:03 /fisco2/nodes/localhost/node0/../fisco-bcos -c config.iniroot      69995      1  1 20:11 pts/0    00:00:01 /fisco2/nodes/localhost/node2/../fisco-bcos -c config.iniroot      69997      1  1 20:11 pts/0    00:00:01 /fisco2/nodes/localhost/node3/../fisco-bcos -c config.iniroot      69999      1  2 20:11 pts/0    00:00:03 /fisco2/nodes/localhost/node1/../fisco-bcos -c config.ini[root@localhost localhost]# tail -f node0/log/log* | grep +++info|2023-03-11 20:16:36.908649|[g:2][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=1,hash=160ccf37...info|2023-03-11 20:16:37.861884|[g:1][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=3,hash=8ce12fdb...info|2023-03-11 20:16:38.914920|[g:2][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=1,hash=655bec83...info|2023-03-11 20:16:40.920451|[g:2][CONSENSUS][SEALER]++++++++++++++++ Generating seal on,blkNum=1,tx=0,nodeIdx=1,hash=82967295...\n\n细节cat写文件cat &gt; filename &lt;&lt; end_signal&gt; content&gt; end_signal\n\n\nEOF只是标识，不是固定的\n可以用按键Ctrl+D输出EOF的标识\ncat &lt;&lt; EOF &gt;&gt; test.sh  内容  EOF &#x3D;&#x3D; cat &gt; test.sh &lt;&lt; EOF 内容  EOF\n\n","categories":["Learning","Blockchain","Fisco-Bcos","Competition"],"tags":["tech","learning","blockchain","fisco"]},{"title":"23-03-15","url":"/2023/03/15/2023-03-15.html/","content":"2023-03-15 | Spring中出现的一些错误没有数组却出现数组越界如图，有两个简单的实体类：User的属性包含了一个List&lt;Address&gt;类型\n一个典型的一对多的关系\n业务上简单地查找用户信息\n运行的时候出现了数组越界的错误\n\n原因：User类没有无参构造函数\n\n\nProvider传不传参数的区别\n如果不传参数的话，没有作判断的可能性，就会出现值缺失的时候，向表中列传入空值\n\n","categories":["Learning","Spring_Framework"],"tags":["learning","Spring Framework","GDIP"]},{"title":"Vue2 - 23-03-17","url":"/2023/03/17/2023-03-17.html/","content":"Vue2 - 23-03-17VS Code的工作区你真的会用vscode吗？——工作区干货\n初识Vue-1\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;初识Vue&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //创建Vue示例        new Vue(&#123;            el:&#x27;#root&#x27;, //el用于指定当前Vue示例为那个容器服务，值通常为css选择器字符串            // el:document.getElementById(&#x27;root&#x27;)            data:&#123;//data中用于存储数据，数据供el所指定的容器去使用                name:&#x27;Linzepore&#x27;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;初识Vue&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/h1&gt;        &lt;h2&gt;&#123;&#123;address.toUpperCase()&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;p&gt;        &#123;&#123;&#125;&#125;里面可以放data的属性值，也可以放js的表达式&lt;br&gt;        &#123;&#123;1+1&#125;&#125; =&gt; 2 //表达式        &#123;&#123;Date.now()&#125;&#125; =&gt; 12345456 //js语句（js代码）    &lt;/p&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //创建Vue示例        new Vue(&#123;            el:&#x27;#root&#x27;, //el用于指定当前Vue示例为那个容器服务，值通常为css选择器字符串            // el:document.getElementById(&#x27;root&#x27;)            data:&#123;//data中用于存储数据，数据供el所指定的容器去使用                name:&#x27;Linzepore&#x27;,                address:&#x27;gdip&#x27;            &#125;        &#125;)        //一一对应，不能多个实例对应一个组件，不能多个组件对应一个实例     &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n开发者工具条未出现Vue选项详见-&gt;官方解答\n\n\n我的解决方法是：先关闭选项卡再刷新，然后就出现了\n\nvue模板标签体与标签属性分别用插值与指令语法\n指令语法视频-&gt;Here  \n&lt;a v-bind:href=&quot;url&quot;&gt;点我去博客首页1&lt;/a&gt;&lt;a :test=&quot;hello&quot;&gt;2&lt;/a&gt;\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;插值语法&lt;/h1&gt;        &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt;&lt;!--直接读取data、js表达式，解析标签体内容--&gt;        &lt;br&gt;&lt;p &gt;学校：&#123;&#123;school.name.toUpperCase()&#125;&#125;&lt;/p&gt;        &lt;hr /&gt;        &lt;h1&gt;指令语法&lt;/h1&gt;        &lt;!-- 解析标签，不限于属性--&gt;        &lt;a v-bind:href=&quot;url.toUpperCase()&quot;&gt;点我去博客首页1&lt;/a&gt;&lt;!--v-bind绑定一个属性或者函数等等等等 --&gt;        &lt;a :test=&quot;hello&quot;&gt;2&lt;/a&gt;&lt;!-- : 等同于v-bind: --&gt;        &lt;br&gt;&lt;p :loc=&quot;school.location&quot;&gt;学校：&#123;&#123;school.name.toUpperCase()&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el:&#x27;#root&#x27;,            data:&#123;                name: &#x27;Linzepore&#x27;,                url: &#x27;http://blog.zepo.re&#x27;,                hello: &quot;hello&quot;,                school: &#123;                    name: &#x27;gdip&#x27;,                    location: &#x27;南海&#x27;                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-18","url":"/2023/03/18/2023-03-18.html/","content":"Vue2 - 23-03-18数据绑定缩写：v-model:value &#x3D;&gt; v-modelv-bind &#x3D;&gt; :\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;数据绑定&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br&gt;        双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;        &lt;!-- v-model只能应用于表单类元素，即输入类，要有value值 --&gt;        &lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好&lt;/h2&gt; --&gt;        &lt;hr&gt;        单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br&gt;        双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            name:&#x27;Linzepore&#x27;,            hello:&#x27;hello&#x27;        &#125;    &#125;)&lt;/script&gt;&lt;/html&gt;\n\nel与datael跟data都有两种写法，其中data的尤为重要\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;el与data区别&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        /*const v = new Vue(&#123;            // el: &#x27;#root&#x27;, 第一种写法            data:&#123;                name:&#x27;Linzepore&#x27;            &#125;        &#125;)        console.log(v)        // v.$mount(&#x27;#root&#x27;)        setTimeout(() =&gt;            v.$mount(&#x27;#root&#x27;),//第二种写法            1000        )*/        //data的第一种写法：对象式        new Vue(&#123;            el:&#x27;#root&#x27;,            /*data:&#123;                name:&#x27;Linzepore&#x27;            &#125;*/            //第二种写法：函数式            data:function() &#123;                return &#123;                    name:&#x27;Linzepore&#x27;                &#125;            &#125;            /*简写            data()&#123;                return &#123;                    name:&#x27;Linzepore&#x27;                &#125;            &#125;            */        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nMVVM模型\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;理解MVVM&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;学校名称：&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试一下：&#123;&#123;1+1&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试两下：&#123;&#123;$options&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试三下：&#123;&#123;$emit&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试四下：&#123;&#123;_c&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        const vm = new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&#x27;gdip&#x27;,                address:&#x27;gdip&#x27;            &#125;        &#125;)        console.log(vm);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n数据代理前置内容视频-&gt;HERE关键：通过getter跟setter，可以修改a影响b\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;数据代理回顾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        let number;        let person = &#123;            name: &#x27;张三&#x27;,            sex: &#x27;男&#x27;,            //age: number 一次性赋值而已        &#125;        console.log(person);        console.log(Object.keys(person));        Object.defineProperty(person,&#x27;age&#x27;,&#123;            value:18,            enumerable:true,            writable:true,            configurable:true,            get:function()&#123;                return number;            &#125;,            set(value) &#123;                console.log(&quot;有人修改了age，值为&quot;+value);                number = value;            &#125;        &#125;)        console.log(person);        console.log(Object.keys(person));    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n何为数据代理可以给B添加一个属性x，修改B的x会影响A的x\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;何为数据代理&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    let obj1 = &#123;        x : &#x27;xx&#x27;    &#125;    let obj2 = &#123;        y : &#x27;yy&#x27;    &#125;    Object.defineProperty(obj2, &#x27;x&#x27;,&#123;        get:function()&#123;            return obj1.x;        &#125;,        set:function(value) &#123;            obj1.x = value;        &#125;    &#125;)&lt;/script&gt;&lt;/html&gt;\n如图演示：\nVue中的数据代理const vm = new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name: &#x27;gdip&#x27;,                address: &#x27;foshan&#x27;            &#125;        &#125;)\n上面的操作中Vue实例中的data&#x3D;&gt;vm._data&#x3D;&gt;数据代理转换成属性也就是说，vue中的数据代理是如下图显示的过程  \n事件处理&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;        &lt;button v-on:click=&quot;showInfo1&quot;&gt;点我提醒信息1&lt;/button&gt;        &lt;!-- 简写 --&gt;        &lt;button @click=&quot;showInfo1&quot;&gt;点我提醒信息1&lt;/button&gt;        &lt;!-- 传信息 --&gt;        &lt;button @click=&quot;showInfo2(666,$event)&quot;&gt;点我提醒信息2&lt;/button&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&#x27;gdip&#x27;,            &#125;,            methods:&#123;                showInfo1(event)&#123;                    // console.log(event.target.innerText);                    // console.log(this);此处的this为vm本身                    alert(&#x27;同学你好！&#x27;);                &#125;,                showInfo2(number,event)&#123;                    console.log(event);//event非必须                    console.log(number);                    alert(&#x27;同学你好！！&#x27;);                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n&lt;!-- 简写 --&gt;&lt;button @click=&quot;showInfo1&quot;&gt;点我提醒信息1&lt;/button&gt;&lt;!-- 传信息 --&gt;&lt;button @click=&quot;showInfo2(666,$event)&quot;&gt;点我提醒信息2&lt;/button&gt;\n\n\nVue中的事件修饰符\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        .box_fa &#123;            padding: 5px;            background-color: aquamarine;        &#125;        .box_ch&#123;            background-color: orange;        &#125;        .list &#123;            width: 200px;            height: 200px;            background-color: peru;            overflow: auto;        &#125;        .list li &#123;            height: 100px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;的博客&lt;/h2&gt;        &lt;!-- 阻止默认事件 --&gt;        &lt;a href=&quot;http://blog.zepo.re&quot; @click=&quot;showInfo&quot;&gt;会跳转链接&lt;/a&gt;        &lt;a href=&quot;http://blog.zepo.re&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提醒信息但是不会跳转&lt;/a&gt;        &lt;!-- 阻止事件冒泡 --&gt;        &lt;div @click=&quot;showInfo&quot;&gt;            &lt;button @click=&quot;showInfo&quot;&gt;未使用会冒泡&lt;/button&gt;        &lt;/div&gt;        &lt;div @click.stop=&quot;showInfo&quot;&gt;            &lt;button @click.stop=&quot;showInfo&quot;&gt;修饰了stop不会冒泡&lt;/button&gt;        &lt;/div&gt;        &lt;!-- 事件只会触发一次 --&gt;        &lt;button @click.once=&quot;showInfo&quot;&gt;事件只会触发一次&lt;/button&gt;        &lt;hr&gt;        &lt;!-- 事件的捕获阶段由外往内，冒泡阶段由内往外（默认） --&gt;        &lt;div class=&quot;box_fa&quot; @click=&quot;showMsg(&#x27;father&#x27;)&quot;&gt;            div1            &lt;div class=&quot;box_ch&quot; @click=&quot;showMsg(&#x27;child&#x27;)&quot;&gt;div2&lt;/div&gt;        &lt;/div&gt;&lt;!-- 点击child，会从内向外冒泡 --&gt;        &lt;!-- 只有event.target是当前操作的元素时才触发事件,也就是说如果在父容器使用了.self也能阻止冒泡 --&gt;        &lt;div @click=&quot;showSelf&quot;&gt;            &lt;button @click=&quot;showSelf&quot;&gt;虽然触发了两次，但是由谁触发的呢，点点试试&lt;/button&gt;        &lt;/div&gt;        &lt;div @click.self=&quot;showInfo&quot; &gt;            &lt;button @click=&quot;showInfo&quot;&gt;由父容器来进行阻止冒泡&lt;/button&gt;        &lt;/div&gt;        &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;        &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;&lt;!--先滚动不管回调--&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;        &lt;/ul&gt;            &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&quot;Linzepore&quot;            &#125;,            methods:&#123;                showInfo(e) &#123;                    // e.preventDefault() == 属性名.prevent                                        alert(&#x27;Hello&#x27;)                &#125;,                showMsg(msg) &#123;                    alert(msg);                &#125;,                showSelf(e) &#123;                    alert(e.target)                &#125;,                demo() &#123;                    for(let i = 0; i &lt; 100000; i++) &#123;                        console.log(&#x27;#&#x27;);                                            &#125;                    console.log(&#x27;累坏了&#x27;);                &#125;        &#125;    &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n常用的只有三个\n&lt;!-- 阻止默认事件 --&gt;&lt;a href=&quot;http://blog.zepo.re&quot; @click=&quot;showInfo&quot;&gt;会跳转链接&lt;/a&gt;&lt;a href=&quot;http://blog.zepo.re&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提醒信息但是不会跳转&lt;/a&gt;&lt;!-- 阻止事件冒泡 --&gt;&lt;div @click=&quot;showInfo&quot;&gt;    &lt;button @click=&quot;showInfo&quot;&gt;未使用会冒泡&lt;/button&gt;&lt;/div&gt;&lt;div @click.stop=&quot;showInfo&quot;&gt;    &lt;button @click.stop=&quot;showInfo&quot;&gt;修饰了stop不会冒泡&lt;/button&gt;&lt;/div&gt;&lt;!-- 事件只会触发一次 --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;事件只会触发一次&lt;/button&gt;\n修饰符可以连续写\n&lt;div @click.stop=&quot;showInfo&quot;&gt;    &lt;button @click.stop.prevent=&quot;showInfo&quot;&gt;修饰了stop不会冒泡&lt;/button&gt;&lt;/div&gt;\n键盘事件、按键别名\n例外\nTAB键会移除焦点，所以要用keyDown  \nCapsLock要写成caps-lock\n系统修饰键Ctrl、alt、shift、meta配合keydown可以，但是配合keyup的话要按下并释放其他键之后才会触发&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;的博客&lt;/h2&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提醒输入&quot; @keyup.caps-lock=&quot;showInfo&quot;&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        Vue.config.keyCodes.huiche = 13;//定义了一个别名        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name: &#x27;Linzepore&#x27;            &#125;,            methods: &#123;                showInfo(e) &#123;                    // console.log(e.keyCode);                    // console.log(e.key);//获取真实按键名称                    // if(e.keyCode!=13) return//等同于.13                    console.log(e.target.value);                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n也可以连续着来写&lt;input type=&quot;text&quot; placeholder=&quot;按下回车提醒输入&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-19","url":"/2023/03/19/2023-03-19.html/","content":"Vue2 - 23-03-19计算属性computed会转化成vm的属性、computed必须是计算已有属性，而非脱离vue管理的变量当只读不改的时候，才可以使用简写  （fulname:function(){}）\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;姓名案例_计算属性实现&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;&lt;br&gt;        名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;&lt;br&gt;        全名：&lt;span&gt;&#123;&#123;fullname&#125;&#125;&lt;/span&gt;        &lt;!-- 只有属性（data里的东西）和方法可以直接使用，computed的不行 --&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    new Vue(&#123;        el:&#x27;#root&#x27;,        data:&#123;            firstname:&#x27;张&#x27;,            lastname:&#x27;三&#x27;        &#125;,        computed:&#123;            fullname:&#123;                // 底层还是通过Object.defineProperty将其转化成属性                // 缓存机制使得其优于methods,不会每次都调用                // 1.初次读取的时候会调用get 2.所依赖的数据发生改变时候会调用                get()&#123;                    return this.firstname + &#x27;-&#x27; + this.lastname;                &#125;,                set(value)&#123;                    const arr = value.split(&#x27;-&#x27;)                    this.firstname = arr[0]                    this.lastname = arr[1]                &#125;            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;/html&gt;\n相比之下，methods\n&lt;!-- 只要data发生改变，Vue就会重新解析模板     解析的时候只要遇到插值语法中的方法     都会重新调用方法--&gt;\n插值语法违背简洁原则\n&lt;!-- 违背不复杂原则 --&gt;全名：&lt;span&gt;&#123;&#123;firstname.slice(0,3)&#125;&#125;-&#123;&#123;lastname&#125;&#125;&lt;/span&gt;\n\n监视属性\n\n可以监视计算属性\n可以给受监视的对象加上一个属性immediate:true来设置其初始化的时候也触发监视\nVue提供的watch默认不可以监视内部值的改变\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;天气案例_深度监视&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;        &lt;hr&gt;        &lt;h3&gt;a的值为&#123;&#123;numbers.a&#125;&#125;&lt;/h3&gt;        &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;&lt;br&gt;        &lt;h3&gt;b的值为&#123;&#123;numbers.b&#125;&#125;&lt;/h3&gt;        &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        const vm = new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                isHot:true,                numbers:&#123;                    a:1,                    b:1                &#125;            &#125;,            computed:&#123;                info()&#123;                    return this.isHot? &#x27;炎热&#x27; : &#x27;凉爽&#x27;                &#125;            &#125;,            methods:&#123;                changeWeather()&#123;                    this.isHot = !this.isHot;                &#125;            &#125;,            watch:&#123;                // 可以监视计算属性                info:&#123;                    // immediate:true,                    handler(newValue,oldValue)&#123;                        console.log(&#x27;info监视：&#x27;,newValue,oldValue);                    &#125;                &#125;,                // 监视多级结构中某个属性的变化                &#x27;numbers.a&#x27;:&#123;                    handler() &#123;                        console.log(&quot;a被改变了&quot;);                    &#125;                &#125;,                numbers:&#123;                    deep:true,                    handler()&#123;                        console.log(&quot;number被改变了&quot;);                    &#125;                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n简写监视属性-&gt;写成函数\nwatch:&#123;            // 正常写法一            // info:&#123;                // immediate:true,                // deep:true,                // handler(newValue,oldValue)&#123;                //     console.log(&#x27;info监视：&#x27;,newValue,oldValue);                // &#125;            // &#125;            //不需要额外配置东西的时候，可以采用简写一            // info(newValue, oldValue)&#123;            //     console.log(&#x27;info被修改了&#x27;,newValue,oldValue);            // &#125;        &#125;    //正常写法二        // vm.$watch(&#x27;info&#x27;,&#123;        //         immediate:true,        //         deep:true,        //         handler(newValue,oldValue)&#123;        //             console.log(&#x27;info监视：&#x27;,newValue,oldValue);        //         &#125;        // &#125;)    //简写二        vm.$watch(&#x27;info&#x27;, function(newValue, oldValue)&#123;            console.log(&#x27;info监视：&#x27;,newValue, oldValue);        &#125;)\n\n监视VS计算P25-&gt;P25 &#x2F; 官方说法：计算属性 vs 侦听属性\n绑定class属性的三种形式\n\n      &lt;!-- 绑定class样式，字符串写法：样式的类名不确定，需要动态指定 --&gt;\n      &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; id=&quot;demo&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;```\n\n\n      &lt;!-- 绑定class样式，数组写法：要绑定的样式个数不确定，名字也不确定 --&gt;\n      &lt;div class=&quot;basic&quot; :class=&quot;arr&quot; &gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;```\n\n\n      &lt;!-- 绑定class样式，数组写法：要绑定的样式个数确定，名字也确定，需要动态决定用不用 --&gt;\n      &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot; &gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;```\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;绑定样式&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;         .basic &#123;width: 300px;height: 50px;border: 1px solid black;&#125;          .happy &#123;border: 3px solid red;background-color: rgba(255, 255, 0, 0.644);            background: linear-gradient(30deg, yellow, pink, orange, yellow);&#125;          .sad &#123;border: 4px dashed rgb(2, 197, 2);background-color: skyblue;&#125;          .normal &#123;background-color: #bfa;&#125;          .atguigu1 &#123;background-color: yellowgreen;&#125;          .atguigu2 &#123;font-size: 20px;text-shadow: 2px 2px 10px red;&#125;          .atguigu3 &#123;border-radius: 20px;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;!-- 绑定class样式，字符串写法：样式的类名不确定，需要动态指定 --&gt;        &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; id=&quot;demo&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;                &lt;!-- 绑定class样式，数组写法：要绑定的样式个数不确定，名字也不确定 --&gt;        &lt;div class=&quot;basic&quot; :class=&quot;arr&quot; &gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;        &lt;!-- 绑定class样式，数组写法：要绑定的样式个数确定，名字也确定，需要动态决定用不用 --&gt;        &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot; &gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&#x27;Linzepore&#x27;,                mood:&#x27;normal&#x27;,                arr:[&#x27;atguigu1&#x27;,&#x27;atguigu2&#x27;,&#x27;atguigu3&#x27;],                classObj:&#123;                    atguigu1:true,                    atguigu2:true,                    atguigu3:true                &#125;            &#125;,            methods:&#123;                changeMood()&#123;                    // document.getElementById(&#x27;demo&#x27;).className = &#x27;basic happy&#x27;                    // this.mood = &#x27;happy&#x27;、                    const arr = [&#x27;happy&#x27;, &#x27;sad&#x27;, &#x27;normal&#x27;];                    const random = Math.floor(Math.random()*3);                    this.mood = arr[random]                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n绑定style &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;&#123;fontSize:fsize+&#x27;px&#x27;&#125;&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleObj1&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;[styleObj1,styleObj2]&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;  data:&#123;         fsize:48,         styleObj1:&#123;             fontSize:&#x27;40px&#x27;,             color:&#x27;red&#x27;         &#125;,         styleObj2:&#123;             backgroundColor:&#x27;orange&#x27;         &#125;,         styleArr:[&#123;             fontSize:&#x27;40px&#x27;,             color:&#x27;red&#x27;         &#125;,         &#123;             backgroundColor:&#x27;green&#x27;         &#125;]&#125;\n\n条件渲染\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;条件渲染&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;!-- 使用v-show做条件渲染 --&gt;        &lt;h1 v-show=&quot;showOrNot1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;的博客&lt;/h1&gt;        &lt;h1 v-if=&quot;showOrNot2&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;的博客&lt;/h1&gt;        &lt;hr&gt;        &lt;h1&gt;当前的n值为&#123;&#123;n&#125;&#125;&lt;/h1&gt;        &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;        &lt;!-- 切换频率高的时候就使用v-show，避免反复增删节点 --&gt;        &lt;div v-show=&quot;n==1&quot;&gt;Angular&lt;/div&gt;        &lt;div v-show=&quot;n==2&quot;&gt;React&lt;/div&gt;        &lt;div v-show=&quot;n==3&quot;&gt;Vue&lt;/div&gt;        &lt;div v-if=&quot;n==1&quot;&gt;Angular&lt;/div&gt;        &lt;div v-if=&quot;n==2&quot;&gt;React&lt;/div&gt;        &lt;div v-if=&quot;n==3&quot;&gt;Vue&lt;/div&gt;        &lt;hr&gt;        &lt;!-- v-if、v-else-if、v-else中间不能打断 --&gt;        &lt;div v-if=&quot;n==1&quot;&gt;Angular&lt;/div&gt;        &lt;div v-else-if=&quot;n==1&quot;&gt;React&lt;/div&gt;        &lt;!-- &lt;div&gt;@&lt;/div&gt; --&gt;        &lt;div v-else-if=&quot;n==2&quot;&gt;Vue&lt;/div&gt;        &lt;div v-else&gt;哈哈&lt;/div&gt;        &lt;hr&gt;        &lt;h2 v-show=&quot;n==1&quot;&gt;你好&lt;/h2&gt;        &lt;h2 v-show=&quot;n==1&quot;&gt;Vue&lt;/h2&gt;        &lt;h2 v-show=&quot;n==1&quot;&gt;Linzepore&lt;/h2&gt;        &lt;!-- v-if与template配合使用 --&gt;        &lt;template v-if=&quot;n==1&quot;&gt;            &lt;h2&gt;你好&lt;/h2&gt;            &lt;h2&gt;Vue&lt;/h2&gt;            &lt;h2&gt;Linzepore&lt;/h2&gt;        &lt;/template&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;    const vm = new Vue(&#123;        el:&#x27;#root&#x27;,        data:&#123;            name:&#x27;Linzepore&#x27;,            showOrNot1:true,            showOrNot2:true,            n:0,        &#125;,    &#125;)&lt;/script&gt;&lt;/html&gt;\n基本列表v-for=&quot;(value, index) in/of list&quot; :key=&quot;index&quot;\n&lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;测试数组遍历&lt;/h2&gt;        &lt;ul&gt;             &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;                &lt;ul&gt;             &lt;li v-for=&quot;(p, index) of personList&quot; :key=&quot;index&quot;&gt;                &#123;&#123;p&#125;&#125;---&#123;&#123;index&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;        &lt;h2&gt;测试对象遍历&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt;                &#123;&#123;key&#125;&#125;---&#123;&#123;value&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;               &lt;h2&gt;测试字符串遍历&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;                &#123;&#123;index&#125;&#125;---&#123;&#123;char&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;        &lt;h2&gt;遍历指定次数&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(number, index) of 5&quot; :key=&quot;index&quot;&gt;                &#123;&#123;index&#125;&#125; --- &#123;&#123;number&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;&lt;/div&gt;-----        data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;王五&#x27;,age:20&#125;,                ],                car:&#123;                    name:&#x27;奥迪A8&#x27;,                    price:&#x27;70万&#x27;,                    color:&#x27;黑色&#x27;                &#125;,                str:&#x27;hello&#x27;            &#125;","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-20","url":"/2023/03/20/2023-03-20.html/","content":"Vue2 - 23-03-20key的作用与原理\n如果使用的是生成的索引作为key，破坏key与index的顺序之后，虚拟dom会根据diff算法（对比算法），保留原有key上面的东西，造成顺序混乱\nkey为p.id的时候，会根据唯一标识ID进行对比\n没有书键入key的时候默认会生成index为key\n\n如果数据是从后方插入的时候就不会出现下面问题\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;key的原理&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;测试数组遍历&lt;/h2&gt;        &lt;button @click=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;        &lt;ul&gt;             &lt;li v-for=&quot;(p,index) in personList&quot; :key=&quot;index&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;                &lt;input type=&quot;text&quot;&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(p,index) in personList&quot; :key=&quot;p.id&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;                &lt;input type=&quot;text&quot;&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;张三&#x27;,age:18&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;李四&#x27;,age:19&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;王五&#x27;,age:20&#125;,                ]            &#125;,            methods:&#123;                add()&#123;                    const p = &#123;id:&#x27;004&#x27;,name:&#x27;老刘&#x27;,age:40&#125;;                    this.personList.unshift(p)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n列表过滤及排序\n过滤list.filter((listItem)=&gt;&#123; return listItem.indexOf(keyword) !== -1 &#125;)\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;列表过滤&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;人员遍历&lt;/h2&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyword&quot;&gt;        &lt;ul&gt;             &lt;li v-for=&quot;(p,index) in filPersonList&quot; :key=&quot;index&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;--&#123;&#123;p.gender&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //同watch实现        //#region        /*        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:18,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,gender:&#x27;男&#x27;&#125;,                    &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,gender:&#x27;男&#x27;&#125;                ],                keyword:&#x27;&#x27;,                filPersonList:[]            &#125;,            watch:&#123;                keyword:&#123;                    handler(val)&#123;                        this.filPersonList = this.personList.filter((p)=&gt;&#123;                        return p.name.indexOf(val) !=-1                    &#125;)                    &#125;,                    immediate:true                &#125;            &#125;        &#125;)*/        //#endregion        //用computed实现        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:18,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:19,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,gender:&#x27;男&#x27;&#125;,                    &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,gender:&#x27;男&#x27;&#125;                ],                keyword:&#x27;&#x27;,                            &#125;,            computed:&#123;                filPersonList()&#123;                    return this.personList.filter((p)=&gt;&#123;                        return p.name.indexOf(this.keyword) !== -1                    &#125;)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n排序升序：  const arr = [1,5,3];arr.sort((a,b)=&gt;&#123; return a-b &#125;) &#x3D;&gt;[1, 3, 5]降序：  const arr = [1,5,3];arr.sort((a,b)=&gt;&#123; return a-b &#125;) &#x3D;&gt;[5, 3, 1]\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;列表过滤后排序&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;人员遍历&lt;/h2&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyword&quot;&gt;        &lt;button @click=&quot;sortType = 2&quot;&gt;年龄升序&lt;/button&gt;        &lt;button @click=&quot;sortType = 1&quot;&gt;年龄降序&lt;/button&gt;        &lt;button @click=&quot;sortType = 0&quot;&gt;原顺序&lt;/button&gt;        &lt;ul&gt;             &lt;li v-for=&quot;(p,index) in filPersonList&quot; :key=&quot;p.id&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;--&#123;&#123;p.gender&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //用computed实现        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:30,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:27,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,gender:&#x27;男&#x27;&#125;,                    &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,gender:&#x27;男&#x27;&#125;                ],                keyword:&#x27;&#x27;,                sortType:0,//0:原顺序，1:降序，2:升序            &#125;,            computed:&#123;                filPersonList()&#123;                    const arr = this.personList.filter((p)=&gt;&#123;                        return p.name.indexOf(this.keyword) !== -1                    &#125;)                    //判断一下需不需要排序                    if(this.sortType) &#123;                        arr.sort((p1, p2)=&gt;&#123;                            return this.sortType==1?p2.age-p1.age:p1.age-p2.age                        &#125;                        )                    &#125;                    return arr                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nVue监测（侦听）数据的原理更新时候出现的一个问题点击按钮之后，开发者工具中没有发现变化，列表也没变Vue中数组没有getter、setter，只能通过七个变更方法才能做到响应式Vue对被侦听的数组变更方法进行了包裹\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;更新时出现的一个问题&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;人员遍历&lt;/h2&gt;        &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;        &lt;ul&gt;             &lt;li v-for=&quot;(p,index) in personList&quot; :key=&quot;p.id&quot;&gt;                &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;--&#123;&#123;p.gender&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //用computed实现        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                personList:[                    &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:30,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:27,gender:&#x27;女&#x27;&#125;,                    &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:20,gender:&#x27;男&#x27;&#125;,                    &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:21,gender:&#x27;男&#x27;&#125;                ],            &#125;,            methods:&#123;                updateMei()&#123;                    // this.personList[0].name=&#x27;马老师&#x27;;                    // this.personList[0].age=50;                    // this.personList[0].gender=&#x27;男&#x27;;                    // X this.personList[0] =  &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,gender:&#x27;男&#x27;&#125;;                    this.personList.splice(0,1,&#x27;打台球&#x27;)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n模拟监测的实现为了响应式，Vue实例将data的东西交给Observer进行处理，然后再给了一份vm._data，一份data这里模拟了加工的实现\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;模拟一个数据监测&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;学校名称：&#123;&#123;&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        let data = &#123;            name:&quot;gdip&quot;,            address:&quot;nanhai&quot;,        &#125;;        const obs = new Observer(data);        const vm = &#123;&#125;        vm._data = data =  obs;        //Vue实例将data的东西交给Observer进行处理，然后再给了一份vm._data，一份data        function Observer(val) &#123;            //获取所有的key            const keys = Object.keys(val);            keys.forEach((key) =&gt; &#123;                Object.defineProperty(this,key,&#123;//this指的是Object本身                    get() &#123;                        return val[key];                    &#125;,                    set(proVal) &#123;                        console.log(&quot;监测到了修改，Vue去更新页面&quot;);                        val[key] = proKey;                    &#125;                &#125;)            &#125;);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n数据在Vue实例通过Observer进行的对data处理之后会同时赋值给data、vm._datagetter、setter是为了响应式而生；数据代理中我认为代理商就是getter和setter，vm的属性来自他们而不是直接读取从vue实例拷贝过来的_data；  \n\nVue.set，添加一个响应式属性只能给data里面的某一个对象追加属性，不能是直接给vm（vue实例的data）追加X没有响应式：vm._data.student.gender &#x3D; ‘男’详见文档-&gt;Vue.setVue.set( target, propertyName/index, value )\n\nVue.set(this.student,&#39;gender&#39;,&#39;男&#39;)\nthis.$set(this.student,&#39;gender&#39;,&#39;男&#39;)\n\n演示：  \n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue监测数据改变的原理&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;学校信息：&lt;/h1&gt;        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;hr&gt;        &lt;h1&gt;学生信息：&lt;/h1&gt;        &lt;button @click=&quot;addGender&quot;&gt;添加一个性别属性&lt;/button&gt;        &lt;h2 v-if=&quot;student.gender&quot;&gt;学生性别：&#123;&#123;student.gender&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生姓名：&#123;&#123;student.name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：真实&#123;&#123;student.age.rAge&#125;&#125;，对外&#123;&#123;student.age.sAge&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;朋友们&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(friend, index) in student.friends&quot; :key=&quot;index&quot;&gt;                &#123;&#123;friend.name&#125;&#125;--&#123;&#123;friend.age&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&quot;gdip&quot;,                address:&quot;nanhai&quot;,                student:&#123;                    name:&#x27;Tom&#x27;,                    age:&#123;                        rAge:40,                        sAge:29                    &#125;,                    friends:[                        &#123;name:&#x27;jerry&#x27;,age:17&#125;,                        &#123;name:&#x27;tony&#x27;,age:30&#125;                    ]                &#125;            &#125;,            methods:&#123;                addGender()&#123;                    // Vue.set(this.student,&#x27;gender&#x27;,&#x27;男&#x27;)                    this.$set(this.student,&#x27;gender&#x27;,&#x27;男&#x27;)                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nVue监测数据改变的原理&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Vue监测数据改变的原理&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        //用computed实现        const vm = new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&quot;gdip&quot;,                address:&quot;nanhai&quot;,                student:&#123;                    name:&#x27;Tom&#x27;,                    age:&#123;                        rAge:40,                        sAge:29                    &#125;                &#125;,                friends:[                    &#123;name:&#x27;jerry&#x27;,age:17&#125;                ]            &#125;,            methods:&#123;                updateMei()&#123;                    // this.personList[0].name=&#x27;马老师&#x27;;                    // this.personList[0].age=50;                    // this.personList[0].gender=&#x27;男&#x27;;                    this.personList[0] =  &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,gender:&#x27;男&#x27;&#125;;                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-23","url":"/2023/03/23/2023-03-23.html/","content":"Vue2 - 23-03-23VueComponent\n\n每次调用Vue.extend都会返回一个全新的VueComponent\nVueComponent的this指的是VueComponent本身\nVueComponent拥有VM的大部分东西，注册了VC的VM身上有着children&lt;!-- 如果标签没有应用的话，开发者工具、vm都不会有他--&gt;&lt;!-- &lt;test&gt;&lt;/test&gt; --&gt;const test = Vue.extend(&#123;    template:`    &lt;div&gt;测试&lt;/div&gt;    `,&#125;)    components:&#123;            test        &#125;\n\n\n解开注释\n重要的内置关系前置知识：原型相关的知识说白了，原型就相当于Java中的类，类实例化出来的对象中有__proto__，指向原型的各种属性prototype，所以才会有xx.__proto__ === XX.prototypeXX.prototype = value相当于给类添加一个私有属性\n\n内置关系：VueComponent.prototype.__proto__ == Vue.prototype\n//前置知识：原型对象function Demo()&#123;    this.a = 1;    this.b = 2;&#125;;const d = new Demo();console.log(Demo.prototype);//显示原型属性console.log(d.__proto__);//隐形原型属性console.log(Demo.prototype === d.__proto__);\n\n但是有个东西还没搞懂：VueComponent与VueComponent实例、函数与原型对象之间的关系，明天更新\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-21","url":"/2023/03/21/2023-03-21.html/","content":"Vue2 - 23-03-21总结数据监视\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;总结Vue数据监测&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;学生信息&lt;/h1&gt;        &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt;        &lt;button @click=&quot;addGender&quot;&gt;添加性别属性，默认值为男&lt;/button&gt;        &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt;        &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为“张三”&lt;/button&gt;        &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt;        &lt;button @click=&quot;modifyHobby&quot;&gt;修改第一个爱好为“开车”&lt;/button&gt;        &lt;button @click=&quot;filterSmoking&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt;        &lt;h2&gt;学生姓名：&#123;&#123;student.name&#125;&#125;&lt;/h2&gt;        &lt;h2 v-if=&quot;student.gender&quot;&gt;学生性别：&#123;&#123;student.gender&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：&#123;&#123;student.age&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生爱好&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(h, index) in student.hobby&quot;&gt;                &#123;&#123;h&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;        &lt;h2&gt;朋友：&lt;/h2&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(f,index) of student.friends&quot; :key=&quot;index&quot;&gt;                &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;Vue.config.productionTip = false;const vm = new Vue(&#123;    el:&quot;#root&quot;,    data:&#123;        student:&#123;            name:&#x27;Linzepore&#x27;,            age:18,            hobby:[&#x27;抽烟&#x27;,&#x27;喝酒&#x27;,&#x27;烫头&#x27;],            friends:[                &#123;name:&#x27;jack&#x27;,age:30&#125;,                &#123;name:&#x27;lily&#x27;,age:20&#125;            ]        &#125;    &#125;,    methods:&#123;        addGender()&#123;            // 错误写法 vm.set(this,student.gender,&#x27;男&#x27;)            // 另一种方式 Vue.set(this.student,&#x27;gender&#x27;,&#x27;男&#x27;),            this.$set(this.student,&#x27;gender&#x27;,&#x27;男&#x27;)        &#125;,        addFriend()&#123;            this.student.friends.unshift(&#123;name:&#x27;tom&#x27;, age:13&#125;)        &#125;,        updateFirstFriendName()&#123;            this.student.friends[0].name = &#x27;张三&#x27;        &#125;,        addHobby()&#123;            this.student.hobby.push(&#x27;打台球&#x27;)        &#125;,        modifyHobby()&#123;            // this.student.hobby.splice(0,1,&#x27;开车&#x27;)            Vue.set(this.student.hobby,0,&#x27;开车&#x27;)        &#125;,        filterSmoking()&#123;            const newHobby = this.student.hobby.filter((val)=&gt;&#123;                return val != &#x27;抽烟&#x27;            &#125;)            this.student.hobby = newHobby;        &#125;    &#125;&#125;)&lt;/script&gt;&lt;/html&gt;\n\n补充filter监测不到做不了响应式，那么就可以通过直接将过滤之后的新数组覆盖原数组数据劫持实际上就是数据代理，通过Object.defineProperty()可以实现数据劫持，让属性在赋值的时候能够触发set方法\n\n收集表单数据v-model修饰符v-model.number：将value的值赋给data的属性时候转换成数字类型v-model.trim：去掉value中前后的空格v-model.lazy：失去焦点之后再返回数据  \n一些input里面需要手动配value\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;form @submit.prevent=&quot;demo&quot;&gt;            &lt;!-- .trim前后去掉空格 --&gt;            账号：&lt;input type=&quot;text&quot; v-model=&quot;account&quot;&gt;&lt;br&gt;            密码：&lt;input type=&quot;password&quot; v-model=&quot;password&quot;&gt;&lt;br&gt;            &lt;!-- 一般来说type=&quot;number&quot;和“.number”修饰符会同时使用 --&gt;            年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt;&lt;br&gt;            性别：            男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; v-model=&quot;gender&quot; value=&quot;male&quot;&gt;            女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; v-model=&quot;gender&quot; value=&quot;female&quot;&gt;&lt;br&gt;            爱好：            学习&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;study&quot;&gt;            打电动&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;game&quot;&gt;            吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;eat&quot;&gt;            所属校区            &lt;select v-model=&quot;city&quot;&gt;                &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;                &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;                &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;                &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;                &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;            &lt;/select&gt;&lt;br&gt;            其他信息：            &lt;!-- .lazy失去焦点的时候就会解析 --&gt;            &lt;textarea v-model.lazy=&quot;other&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;            &lt;input type=&quot;checkbox&quot; v-model=&quot;agree&quot;&gt; 阅读并接受&lt;a href=&quot;http://baidu.com&quot;&gt;《用户协议》&lt;/a&gt;            &lt;button &gt;提交&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                account:&#x27;&#x27;,                password:&#x27;&#x27;,                age:null,                gender:&#x27;female&#x27;,                hobby:[],                city:&#x27;beijing&#x27;,                other:&#x27;&#x27;,                agree:&#x27;&#x27;            &#125;,            methods:&#123;                demo()&#123;                    // console.log(this.account);                    // console.log(this.password);                    // console.log(this.gender);                    // console.log(this.hobby);                    // console.log(this.city);                    // console.log(this.other);                    // console.log(this.agree);                    console.log(JSON.stringify(this._data))                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n过滤器\n局部过滤器&lt;!-- 不传参默认只向管道传入time --&gt;&lt;h3&gt;现在是:&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt;&lt;!-- 传参的话会向管道传入两个参数：time、&#x27;YYYY年MM月DD日&#x27; --&gt;&lt;h3&gt;现在是:&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD hh:mm:ss&#x27;)&#125;&#125;&lt;/h3&gt;&lt;!--可以有多个管道--&gt;&lt;h3&gt;现在是:&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD hh:mm:ss&#x27;) | mySlice&#125;&#125;&lt;/h3&gt;//局部过滤器filters:&#123;    // ES6中可以有形参默认值    timeFormater(originalTime,str=&#x27;YYYY年MM月DD日&#x27;) &#123;        return dayjs(originalTime).format(str)    &#125;,    mySlice(value) &#123;        return value.slice(0,4)    &#125;&#125;\n如何证明其为局部？  \n&lt;div id=&quot;root2&quot;&gt;    &lt;h2&gt;&#123;&#123;msg | mySlice&#125;&#125;&lt;/h2&gt;&lt;/div&gt;new Vue(&#123;    el:&#x27;#root2&#x27;,    data:&#123;        msg:&quot;hello, I&#x27;m Linzepore!&quot;    &#125;&#125;)\n\n全局过滤器Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;    return value.slice(0,4);&#125;)new Vue(&#123;    el:&#x27;#root2&#x27;,    data:&#123;        msg:&quot;hello, I&#x27;m Linzepore!&quot;    &#125;&#125;)\n也可以用在v-bind属性上，不限于插值语法\nv-text\nv-html\n安全威胁：容易受到XXS攻击（虽然一般会进行HttpOnly保护）【尚硅谷Vuejs从入门到精通P41_尚硅谷Vue技术_v-html指令】 【精准空降到 19:07】\nv-cloak为了避免由于js未加载出来导致页面混乱，vue提供了一个v-cloak属性，该属性会在Vue接管时候删除，可以配合CSS的属性选择器来使用\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;v-cloak指令&lt;/title&gt;    &lt;style&gt;        [v-cloak] &#123;            display: none;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;        &lt;h3 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt;        &lt;!-- 假如vue.js没出来，h3不会出现 --&gt;    &lt;/div&gt;    &lt;script src=&quot;./resources/js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                name:&#x27;Linzepore&#x27;,            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-once\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;v-once指令&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2 v-once&gt;初始化的n值：&#123;&#123;n&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;        &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                n:1            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nv-pre\n自定义v-big指令big函数何时会被调用？\n\n1.指令与元素成功绑定时\n2.指令所在模板重新解析时（而非依赖的数据被改变时！）\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;自定义指令&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;当前的n值是&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;h2&gt;放大十倍后的n值是&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                n:1            &#125;,            directives:&#123;                //big函数何时会被调用？                //1。指令与元素成功绑定时                //2.指令所在模板重新解析时（并非依赖的数据被改变时！）                big:function(element, binding)&#123;                    // console.dir(element);                    // console.log(element instanceof HTMLElement);                    element.innerText = binding.value*10                    console.log(binding);                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-22","url":"/2023/03/22/2023-03-22.html/","content":"Vue2 - 23-03-22自定义v-fbind指令如果要写一个一上来就能够自动获取焦点的指令，就会涉及到插入页面，但是默认函数式写法只包括元素与指令绑定时和模板重新解析时  \n此时就需要时候对象式写法\n&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;hr&gt;&lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;fbind:&#123;    bind(element, binding)&#123;        element.value = binding.value;    &#125;,    inserted(element, binding)&#123;        element.focus();    &#125;,    update(element, binding)&#123;        element.value = binding.value    &#125;&#125;\n\n回顾DOM操作顺序\n自定义指令容易踩的坑指令名称多个单词组成&lt;h2&gt;放大十倍后的n值是&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&#x27;big-number&#x27;(element, binding)&#123;    element.innerText = binding.value*10&#125;\n\n自定指令的this指令里面的this都是Windows，需要什么属性通过binding传\n定义全局指令做法与全局过滤器类似\n&lt;h2&gt;放大十倍后的n值是&lt;span v-bigg=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;//定义全局指令Vue.directive(&#x27;bigg&#x27;,function(element, binding)&#123;            element.innerText = binding.value*10        &#125;);\n\n总结自定义指令\nVue生命周期\n生命周期又名生命周期回调函数、生命周期函数、生命周期钩子\n是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数\n生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n生命周期函数中的 this 指向是vm或组件实例对象\n\nbeforeCreate()&#123;    // 生成数据代理前    console.log(&quot;beforeCreate&quot;);&#125;,created()&#123;    // 生成数据代理后    console.log(&quot;created&quot;);&#125;,beforeMount() &#123;    // 虚拟dom覆盖原来dom之前    console.log(&quot;beforeMount&quot;);&#125;,mounted()&#123;    // 虚拟dom覆盖原来dom之后    console.log(&quot;mounted&quot;);    console.log(this.$el);&#125;,beforeUpdate()&#123;    // 数据已经变了，页面更新前    console.log(&quot;beforeUpdate&quot;);&#125;,updated()&#123;    // 数据页面同步    console.log(&quot;updated&quot;);&#125;,beforeDestroy()&#123;    // 收尾    console.log(&quot;beforedestroy&quot;);&#125;,destroyed()&#123;    //对页面残留结果进行操作    console.log(&quot;destroyed&quot;);&#125;\n\n生命周期总结\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;总结生命周期&lt;/title&gt;    &lt;script src=&quot;../resources/js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt;        &lt;button @click=&quot;opacity = 1&quot;&gt;透明度变为1&lt;/button&gt;        &lt;button @click=&quot;stop&quot;&gt;停止变换&lt;/button&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false;        const vm = new Vue(&#123;            el: &#x27;#root&#x27;,            data:&#123;                opacity:1            &#125;,            methods:&#123;                stop()&#123;                    this.$destroy();                &#125;            &#125;,            mounted()&#123;                //开发中常用的给当前实例追加属性                this.timer = setInterval(()=&gt;&#123;                    this.opacity-=0.01;                    // if(this.opacity==0) this.opacity=1 js没办法与零比较                    if(this.opacity&lt;=0) this.opacity=1                &#125;,16)            &#125;,            beforeDestroy()&#123;                clearInterval(this.timer)            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n模块化与组件化\n模块化是指将js文件进行拆分组件化是指一系列代码和资源的集合\n\n组件的基本使用\n创建组件（一般包括data、template）\n注册组件\n使用组件标签\n\n\n为什么要将data的data写成函数式？let data = &#123;a: 1, b: 2&#125;const d1 = data;const d2 = data;d1.a = 10;console.log(d2)//returns &#123;a: 10, b: 2&#125;-----let data()&#123;    return &#123;a: 1, b: 2&#125;&#125;const d1 = data;const d2 = data;d1.a = 10;console.log()//returns &#123;a: 1, b: 2&#125;\n\n全局组件全局组件要放在最开头处，否则容易未被解析出现错误\n// 全局组件    // 创建组件    const test = Vue.extend(&#123;        template:`        &lt;div&gt;        &lt;h2&gt;&#123;&#123;test&#125;&#125;&lt;/h2&gt;        &lt;/div&gt;        `,        data()&#123;            return &#123;                test:&#x27;test successfully! &#x27;            &#125;        &#125;,    &#125;)    // 全局注册组件    Vue.component(&#x27;test&#x27;,test);    \n\n局部组件// 注册局部组件    //第一步：创建组件    const school = Vue.extend(&#123;        template:`        &lt;div&gt;        &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;/div&gt;        `,        // 只能写成函数式        data()&#123;            return &#123;                schoolName: &#x27;gdip&#x27;,                address:&#x27;foshan&#x27;            &#125;        &#125;    &#125;)    const student = Vue.extend(&#123;        template:`        &lt;div&gt;        &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;        &lt;test&gt;&lt;/test&gt;        &lt;/div&gt;`,        data()&#123;            return &#123;                studentName:&#x27;linzepore&#x27;,                age:20            &#125;        &#125;    &#125;)    //第二步：创建vm，注册组件    new Vue(&#123;        el:&#x27;#root&#x27;,        data:&#123;            hello:&#x27;hello&#x27;        &#125;,        components:&#123;            school: school,            // student: student            student        &#125;    &#125;)\n\n组件的使用&lt;div id=&quot;root&quot;&gt;    &lt;!-- 第三步：编写组件标签 --&gt;    &lt;h1&gt;&#123;&#123;hello&#125;&#125;&lt;/h1&gt;    &lt;school&gt;&lt;/school&gt;    &lt;hr&gt;    &lt;student&gt;&lt;/student&gt;    &lt;test&gt;&lt;/test&gt;&lt;/div&gt;\n组件标签名称大小写\n注册组件名称写成以-连接会自动形成大写（如&#39;my-school&#39;:school）  \n注册的时候用的什么名字，使用标签就要用什么名字；如果组件定义了名字，开发者工具会随之变化，但是使用标签时候还是要用注册的名字  \n创建组件的时候可以先不写Vue.extend，直接写成对象的形式，注册的时候Vue会进行调用\n\n组件的嵌套以及书写规范详见-&gt;第57集\n&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;//定义student组件const student = Vue.extend(&#123;//定义school组件，嵌套了studentconst school = Vue.extend(&#123;    template:`    &lt;div&gt;        &lt;h2&gt;学校名称：&#123;&#123;schoolname&#125;&#125;&lt;/h2&gt;            &lt;h2&gt;学校地址: &#123;&#123;address&#125;&#125;&lt;/h2&gt;        &lt;student&gt;&lt;/student&gt;    &lt;/div&gt;    `,    data()&#123;        return &#123;            schoolname:&#x27;gdip&#x27;,            address:&#x27;foshan&#x27;        &#125;    &#125;,    components:&#123;        student    &#125; &#125;) //定义了hello组件，与school平级const hello = Vue.extend(&#123;    template:`    &lt;h2&gt;欢迎来到Linzepore的博客&lt;/h2&gt;    `&#125;)const app = Vue.extend(&#123;    template:`    &lt;div&gt;    &lt;hello&gt;&lt;/hello&gt;    &lt;school&gt;&lt;/school&gt;    &lt;/div&gt;    `,    components:&#123;        hello,        school    &#125;&#125;)new Vue(&#123;    template:`&lt;app&gt;&lt;/app&gt;`,    el: &#x27;#root&#x27;,    components:&#123;        app    &#125;&#125;)\n\n一个bug————忘记把标签包裹成为一个根标签Vue报错：[Vue warn]: Error compiling template:Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-25","url":"/2023/03/25/2023-03-25.html/","content":"Vue2 - 23-03-25书接上回\n但是有个东西还没搞懂：VueComponent与VueComponent实例、函数与原型对象之间的关系，明天更新\n\nVueComponent与VueComponent实例  \n函数与原型对象之间的关系参考博文-&gt;HERE，隐式原型在ES6之前是不能够通过实例调用的，也就是说只能通过原型进行添加，ES6赋予了操作原型属性的权力，这点跟Java区别就很大了\nexport没仔细学习ES6，所以这时候涉及到模块化，还是得看看-&gt;理解JS ES6中的模块化（export和import）\n单文件组件\n管理员方式打开cmd，首先要先换一下镜像源npm config set registry https://registry.npmmirror.com/  \n\n全局安装vue-clinpm install -g @vue/cli  \n\n切换到工作目录，进行初始化vue create vue_test  \n\n切换进去vue_test，然后启动npm run serve\n\n根据目录结构，分成App连接各个组件，main.js引入App，因为是脚手架模块化的方式进行构建，所以Vue并非完整的包，没有办法在Vue实例配置模板，只能通过渲染或者更换引入的vue\n\n\n脚手架文件结构.文件目录├── node_modules├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   └── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件├── README.md: 应用描述文件└── package-lock.json: 包版本控制文件\n\nrender函数\n使用了render函数之后，不单单是解决了template插件的问题，js中Vue实例的components也无须再配置了，这一点视频中没有提到\n\n\n查看npm模块中的Vue包的配置，当用ES6模块化语法进行引用的时候，具体到第六行的js文件\n\n两种解决方式：一——在main.js中引入完整版的vue：&#96;import Vue from ‘vue&#x2F;dist&#x2F;vue’二——使用默认runtime版本，使用render解析模板\n\nrender函数怎么写\n\nrender函数会接受一个参数，该参数是函数类型，复杂点写就像这样子render(createElement) &#123;return createElement(&#x27;h1&#x27;,&#x27;你好啊&#x27;)&#125;\n因为没有用到this，可以写成箭头函数，这是逐渐进化的过程render:(createElement)=&gt;&#123;  return createElement(&#x27;h1&#x27;,&#x27;你好啊&#x27;)&#125;-----//只有一个句的时候render:(createElement)=&gt;createElement(&#x27;h1&#x27;,&#x27;你好啊&#x27;)-----//把名字简化render:h=&gt;h(&#x27;h1&#x27;,&#x27;你好啊&#x27;)-----//已经引入的App组件拿来用render:h=&gt;h(App)\n\n\n.vue文件里面标签化的template，vue有专门的编译器库\n\n\n默认配置放个链接，后面有需要的时候，在重新看一遍吧-&gt;【064_尚硅谷Vue技术_修改默认配置】官方文档vue.config.jsvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue&#x2F;cli-service 自动加载该export使用的是common，因为webpack基于node.js\n关掉语法检查\nref属性\n&lt;div&gt;  &lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;  &lt;button @click=&quot;showDom&quot; ref=&quot;btn&quot;&gt;点我输出上方的dom元素&lt;/button&gt;  &lt;School ref=&quot;sch&quot;/&gt;&lt;/div&gt;showDom() &#123;  console.log(this.$refs.title);  console.log(this.$refs.btn);  console.log(this.$refs.sch);&#125;\n\n注册错误？？看看component是不是写错了┭┮﹏┭┮，谢谢bing\n创建组件时候，通过父容器传输参数props优先级比data更高，所以data里面可以出现myAge = this.age\n\n父容器（App.vue）\n&lt;template&gt;&lt;div&gt;  &lt;!-- 如果要使用数字类型，使用v-bind传入js --&gt;  &lt;Student name=&quot;李四&quot; :age=&quot;21&quot;/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &quot;./components/Student.vue&quot;export default &#123;    name:&#x27;App&#x27;,    components:&#123;        Student    &#125;&#125;&lt;/script&gt;\n子组件有三种形式，从简到繁，但是可用性完整性变强\n//简单声明接收props:[&#x27;name&#x27;,&#x27;age&#x27;] //接受并检查类型props:&#123;        name:String,        age:Number    &#125;    // 接收的同时对类型进行限制+默认值的指定+必要性的限制props:&#123;        // 接受的同时对类型进行限制+默认值的指定+必要性的限制        // 正常情况下required跟default不同时存在        name:&#123;            type:String,            required:true        &#125;,        age:&#123;            type:Number,            default:99        &#125;    &#125;\n\nmixin 混入什么是混入？简单来说就是姜公有的东西提取出来，可以复用，同时data、methods等冲突的时候以自身的为主（生命周期钩子除外）\nmixin文件\nexport const hunhe = &#123;    methods: &#123;        showName() &#123;            alert(this.name)        &#125;    &#125;&#125;export const hunhe2 = &#123;    data() &#123;        return &#123;            x: 100        &#125;    &#125;&#125;\n局部混入\n//在Student.vue中&lt;script&gt;import &#123;hunhe&#125; from &#x27;../mixin.js&#x27;export default &#123;    name:&#x27;Student&#x27;,    data() &#123;        return &#123;            msg:&#x27;Hello&#x27;,            name:&#x27;linzepore&#x27;,            age:21        &#125;    &#125;,    mixins:[hunhe]&#125;&lt;/script&gt;//在School.vue中&lt;script&gt;import &#123;hunhe,hunhe2&#125; from &#x27;../mixin.js&#x27;export default &#123;    name:&#x27;School&#x27;,    data() &#123;        return &#123;            msg:&#x27;Hello&#x27;,            name:&#x27;gdip&#x27;,            address:&#x27;foshan&#x27;,            x:777        &#125;    &#125;,    mixins:[hunhe,hunhe2]&#125;&lt;/script&gt;\n全局混入：在main.js中写上\nimport &#123;hunhe,hunhe2&#125; from &#x27;./mixin.js&#x27;Vue.config.productionTip = falseVue.mixins = [hunhe,hunhe2]\n\n插件定义插件插件是一个对象，需要包含install函数\nexport const plugin = &#123;    install() &#123;        //...    &#125;    //其他函数...&#125;\n插件的使用：先引入后使用import plugin from &#x27;./plugin.js&#x27;Vue.use(plugin)\n插件install函数的参数\n插件里面第一个参数是Vue构造器，也就是vm原型，拿到vm原型我们就可以做很多事情了\ninstall方法后面还可以在main.js文件的Vue.use方法中第二个开始向install方法进行传参\n\n\nexport const plugin = &#123;    install(Vue) &#123;        console.log(&quot;安装插件喽&quot;,Vue);        //添加全局过滤器        Vue.filter(&#x27;mySlice&#x27;, function(value)&#123;            return value.slice(0,4);        &#125;)        //添加全局指令        Vue.directive(&#x27;bigg&#x27;,function(element, binding)&#123;            element.innerText = binding.value*10        &#125;)        //配置全局混入        Vue.mixin(&#123;            data() &#123;                return &#123;                    x: 100                &#125;            &#125;        &#125;)        //添加实例方法        Vue.prototype.hello = ()=&gt;alert(&#x27;你好啊&#x27;)    &#125;&#125;\n\n脚手架中编写样式的技巧&lt;style scoped&gt;在不同组件里写的样式最终都被汇总到一起了，这就会导致样式冲突（会按引入顺序覆盖而非标签顺序），解决办法就是给style加上scoped原理是根据模板div自动生成的data-v-XXX，结合属性选择器app不能加scoped，会导致子组件用scoped无效\n如果使用less，lang=&quot;less&quot;需要安装less-loader，安装的时候需要留意版本；不写lang默认是css\nToDoList案例组件化编码笔记来源：Here\n1.组件化编码流程:\n(1).拆分静态组件:组件要按照功能点拆分，命名不要与html元素冲突。\n(2).实现动态组件:考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用:\n1).一个组件在用:放在组件自身即可。\n2).一些组件在用:放在他们共同的父组件上(状态提升)。\n\n\n(3).实现交互:从绑定事件开始。\n\n2.props适用于:\n(1).父组件&#x3D;&#x3D;&gt;子组件通信\n(2).子组件&#x3D;&#x3D;&gt;父组件通信(要求父先给子一个函数)\n\n3.使用v-model时要切记:v-model绑定的值不能是props传过来的值，因为props是不可以修改的!\n4.props传过来的若是对象类型的值props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-26","url":"/2023/03/26/2023-03-26.html/","content":"Vue2 - 23-03-26一个错误ERROR in ./src/components/MyList.vue?vue&amp;type=script&amp;lang=js&amp; (./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/MyList.vue?vue&amp;type=script&amp;lang=js&amp;)Module build failed (from ./node_modules/babel-loader/lib/index.js):SyntaxError: D:\\CODE_VsCode\\VUE\\vue_study\\脚手架之后的内容\\vue_test\\src\\components\\MyList.vue: Legacy octal literals are not allowed in strict mode. (7:16)   5 |         data()&#123;   6 |           todos[&gt;  7 |             &#123;id:001, title:抽烟, done: true&#125;,     |                 ^   8 |             &#123;id:002, title:喝酒, done: false&#125;,   9 |             &#123;id:003, title:开车, done: false&#125;  10 |           ]\n\n\n记得serve之前保存文件！！！\n\n另一个错误卡在这里不动了。。。\n npm run serve&gt; vue_test@0.1.0 serve&gt; vue-cli-service serve INFO  Starting development server...[24%] building (12/33 modules)\n\n检查template里面是不是有错误，编译失败\n\n子组件向父组件传数据实现方式：父组件先向子组件传函数，子组件在合适的时候将数据通过调用父组件的函数，将数据传给父组件\ncss中父元素被hover的时候触发子元素的属性li:hover button &#123;  display: block;&#125;\n\n获取点击事件的元素e.target.value&#x2F;e.target.checked\nv-on:click(funName)funName(e) &#123;    log(e.target.value)/log(e.target.checked)&#125;\n\n自行练习了一遍App.vue&lt;template&gt;  &lt;div class=&quot;todo-container&quot;&gt;    &lt;div class=&quot;todo-wrap&quot;&gt;        &lt;MyHeader            :addTodo=&quot;addTodo&quot;/&gt;        &lt;MyList            :todos=&quot;todoList&quot;            :changeDone=&quot;changeDone&quot;            :deleteTodo=&quot;deleteTodo&quot;        /&gt;        &lt;MyFooter            :todos=&quot;todoList&quot;            :checkAll=&#x27;checkAll&#x27;            :clearDone=&quot;clearDone&quot;        /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import MyHeader from &quot;./components/MyHeader.vue&quot;    import MyList from &quot;./components/MyList.vue&quot;    import MyFooter from &quot;./components/MyFooter.vue&quot;    export default &#123;        name:&#x27;App&#x27;,        components:&#123;MyHeader, MyList, MyFooter&#125;,        data() &#123;            return &#123;                todoList:[                    &#123;id:&#x27;001&#x27;, title:&#x27;抽烟&#x27;, done:false&#125;,                    &#123;id:&#x27;002&#x27;, title:&#x27;喝酒&#x27;, done:true&#125;,                    &#123;id:&#x27;003&#x27;, title:&#x27;吃饭&#x27;, done:false&#125;,                ]            &#125;        &#125;,        methods:&#123;            addTodo(todo) &#123;                // console.log(&#x27;收到了todo&#x27;,todo);                this.todoList.unshift(todo)            &#125;,            changeDone(id) &#123;                this.todoList.forEach(todo =&gt; &#123;                    if(todo.id === id) todo.done = !todo.done                &#125;);            &#125;,            deleteTodo(id) &#123;                this.todoList = this.todoList.filter((todo)=&gt;&#123;                    return todo.id!=id                &#125;)            &#125;,            checkAll(value) &#123;                                    this.todoList.forEach((todo)=&gt;&#123;                    todo.done = value                &#125;)            &#125;,            clearDone() &#123;                if(confirm(&quot;将要清除所有已完成项&quot;) )&#123;                    this.todoList=this.todoList.filter(todo=&gt; !todo.done)                  &#125;                   &#125;        &#125;    &#125;&lt;/script&gt;&lt;style&gt;/*base*/body &#123;  background: #fff;&#125;.btn &#123;  display: inline-block;  padding: 4px 12px;  margin-bottom: 0;  font-size: 14px;  line-height: 20px;  text-align: center;  vertical-align: middle;  cursor: pointer;  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  border-radius: 4px;&#125;.btn-danger &#123;  color: #fff;  background-color: #da4f49;  border: 1px solid #bd362f;&#125;.btn-danger:hover &#123;  color: #fff;  background-color: #bd362f;&#125;.btn:focus &#123;  outline: none;&#125;.todo-container &#123;  width: 600px;  margin: 0 auto;&#125;.todo-container .todo-wrap &#123;  padding: 10px;  border: 1px solid #ddd;  border-radius: 5px;&#125;&lt;/style&gt;\nHeader.vue&lt;template&gt;    &lt;div class=&quot;todo-header&quot;&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; @keyup.enter=&quot;addATodo&quot;/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import &#123;nanoid&#125; from &#x27;nanoid&#x27;    export default &#123;        name:&#x27;MyHeader&#x27;,        props:[&quot;addTodo&quot;],        methods:&#123;            addATodo(e)&#123;                const todo = &#123;id:nanoid(),title:e.target.value,done:false&#125;                this.addTodo(todo)                e.target.value=&#x27;&#x27;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;/*header*/.todo-header input &#123;  width: 560px;  height: 28px;  font-size: 14px;  border: 1px solid #ccc;  border-radius: 4px;  padding: 4px 7px;&#125;.todo-header input:focus &#123;  outline: none;  border-color: rgba(82, 168, 236, 0.8);  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);&#125;&lt;/style&gt;\n\nMyList.vue&lt;template&gt;    &lt;ul class=&quot;todo-main&quot;&gt;        &lt;!-- 每一份都是独一无二的vc --&gt;        &lt;MyItem         v-for=&quot;todo in todos&quot;         :key=&quot;todo.id&quot;        :todoItem=&quot;todo&quot;        :changeDone=&#x27;changeDone&#x27;        :deleteTodo=&#x27;deleteTodo&#x27;        /&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    import MyItem from &#x27;./MyItem.vue&#x27;    export default &#123;        name:&#x27;MyList&#x27;,        components:&#123;MyItem&#125;,        props:[&#x27;todos&#x27;,&#x27;changeDone&#x27;,&#x27;deleteTodo&#x27;]    &#125;&lt;/script&gt;&lt;style scoped&gt;/*main*/.todo-main &#123;  margin-left: 0px;  border: 1px solid #ddd;  border-radius: 2px;  padding: 0px;&#125;.todo-empty &#123;  height: 40px;  line-height: 40px;  border: 1px solid #ddd;  border-radius: 2px;  padding-left: 5px;  margin-top: 10px;&#125;&lt;/style&gt;\n\nMyItem.vue&lt;template&gt;    &lt;li&gt;        &lt;label&gt;        &lt;input type=&quot;checkbox&quot; :checked=&quot;todoItem.done&quot; @change=&quot;handleDone&quot;/&gt;        &lt;span&gt;&#123;&#123;todoItem.title&#125;&#125;&lt;/span&gt;        &lt;/label&gt;        &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete&quot;&gt;删除&lt;/button&gt;    &lt;/li&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;MyItem&#x27;,        props:[&#x27;todoItem&#x27;,&#x27;changeDone&#x27;,&#x27;deleteTodo&#x27;],        methods:&#123;            handleDone()&#123;                // console.log(&#x27;点了&#x27;);                this.changeDone(this.todoItem.id)            &#125;,            handleDelete()&#123;                if(confirm(&quot;确认要删除这一项吗？？&quot;)) this.deleteTodo(this.todoItem.id)            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;/*item*/li &#123;  list-style: none;  height: 36px;  line-height: 36px;  padding: 0 5px;  border-bottom: 1px solid #ddd;&#125;li:hover &#123;    background-color: #ebebeb;&#125;li:hover button &#123;    display: block;&#125;li label &#123;  float: left;  cursor: pointer;&#125;li label li input &#123;  vertical-align: middle;  margin-right: 6px;  position: relative;  top: -1px;&#125;li button &#123;  float: right;  display: none;  margin-top: 3px;&#125;li:before &#123;  content: initial;&#125;li:last-child &#123;  border-bottom: none;&#125;&lt;/style&gt;\n\nMyFooter.vue&lt;template&gt;&lt;div class=&quot;todo-footer&quot; v-show=&quot;todoTotal&gt;0&quot;&gt;  &lt;label&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;  &lt;/label&gt;  &lt;span&gt;    &lt;span&gt;已完成&#123;&#123;todoDone&#125;&#125;&lt;/span&gt; / 全部&#123;&#123;todoTotal&#125;&#125;  &lt;/span&gt;  &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearDone&quot;&gt;清除已完成任务&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&#x27;MyFooter&#x27;,        props:[&#x27;todos&#x27;,&#x27;checkAll&#x27;,&#x27;clearDone&#x27;],        computed:&#123;            todoTotal()&#123;                return this.todos.length;            &#125;,            todoDone()&#123;                return this.todos.reduce((pre,todo)=&gt;&#123;                    return pre += todo.done? 1: 0                &#125;,0)            &#125;,            isAll:&#123;                get()&#123;                    return this.todoDone === this.todoTotal                &#125;,                set(checked)&#123;                    this.checkAll(checked)                &#125;            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped&gt;/*footer*/.todo-footer &#123;  height: 40px;  line-height: 40px;  padding-left: 6px;  margin-top: 5px;&#125;.todo-footer label &#123;  display: inline-block;  margin-right: 20px;  cursor: pointer;&#125;.todo-footer label input &#123;  position: relative;  top: -1px;  vertical-align: middle;  margin-right: 5px;&#125;.todo-footer button &#123;  float: right;  margin-top: 5px;&#125;&lt;/style&gt;\n\nWebStorage\n增(window.)localStorage/sessionStorage . setItem([key],[value])查(window.)localStorage/sessionStorage . getItem([key])单删(window.)localStorage/sessionStorage . removeItem([key])全删(window.)localStorage/sessionStorage . clear  \n转字符串JSON.stringify &#x2F; 恢复对象JSON.parse\nTodoList新增本地存储功能防止初始的时候key不存在todoList: JSON.parse(localStorage.getItem(&quot;todos&quot;)) || []\n实现watch:&#123;  todoList:&#123;    deep:true,    handler(value) &#123;      localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value))    &#125;  &#125;&#125;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-27","url":"/2023/03/27/2023-03-27.html/","content":"Vue2 - 23-03-27组件的自定义事件在父组件中定义自定义事件以及方法（父组件），然后子组件在需要的地方进行触发该事件，可以在第二个以后参数传入子组件的相关东西  \n触发事件之后调用的方法是父组件的方法，父组件给子组件绑定上的自定义事件，然后由子组件触发该事件，进而调用了父组件的方法\nApp.vue\n&lt;template&gt;&lt;div&gt;  &lt;h1 class=&quot;apph&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;  &lt;!-- 通过标签v-on的形式 --&gt;  &lt;Student v-on:getStudentNameEvent=&quot;getStudentName&quot;/&gt;  &lt;hr&gt;  &lt;!-- 使用ref+生命周期钩子进行绑定 --&gt;  &lt;Student ref=&quot;student&quot;/&gt;  &lt;hr&gt;  &lt;!-- 通过v-bind单向绑定进行传入，子组件props进行接收 --&gt;  &lt;School :getSchoolName=&#x27;getSchoolName&#x27;/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &quot;./components/Student.vue&quot;import School from &quot;./components/School.vue&quot;export default &#123;    name:&#x27;App&#x27;,    components:&#123;        Student,        School    &#125;,    data()&#123;      return &#123;        msg:&#x27;你好啊！&#x27;      &#125;    &#125;,    methods:&#123;      getSchoolName(name) &#123;        console.log(&#x27;App得到了学校名称：&#x27;+name);      &#125;,      getStudentName(name)&#123;        console.log(&#x27;App得到了学生姓名：&#x27;+name);      &#125;    &#125;,    mounted()&#123;      this.$refs.student.$on(&#x27;getStudentNameEvent&#x27;, this.getStudentName)    &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;  .apph&#123;    background-color: pink;  &#125;&lt;/style&gt;\n\nStudent.vue\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&#x27;sendStudentName&#x27;&gt;点我发送学生名给父组件&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;Student&#x27;,    data() &#123;        return &#123;            name:&#x27;linzepore&#x27;,            age:21        &#125;    &#125;,    methods:&#123;        sendStudentName()&#123;            //触发tudent实例的zepoevent事件            this.$emit(&#x27;getStudentNameEvent&#x27;,this.name)        &#125;    &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;    .demo &#123;        background-color: gray;    &#125;&lt;/style&gt;\n\n自定义组件的两种绑定方式：\nv-on/@ + 自定义事件名称\n标签上加ref属性，在mounted钩子上调用获取的子组件，然后进行绑定，this.$refs + .ref属性值 + .$on &#x2F; $once\n\nref属性忘了？参考这篇文章：HERE  \n\nref 属性被用来给元素或子组件注册引用信息（id的替代者），相当于对页面元素或子组件标识，使用 ref 属性标识页面元素或子组件之后，被标识的元素或子组件会被所在的组件实例对象收集，挂载在所在组件实例对象的$ref属性上\nref 属性应用在 html 标签元素上，获取的是对应的真实DOM元素；ref 属性应用在组件标签上，获取的是对应组件实例对象\n\n还可以加上修饰符this.$refs.student.$once(&#39;eventName&#39;,params) &#x2F;@eventName.once=&#39;methodsName&#39;\n注意事项在父组件给子组件标签实例绑定的事件都会被视为自定义事件，如果定义为原生的，可以这样写@click.native\n自定义事件在子组件的触发以及在父组件的接收假如父组件给子组件绑定v-on:eventA=&quot;getParams&quot;，  \n子组件可以通过这种方式触发事件this.$emit(&#39;eventA&#39;,param1,param2,param3,...)，  \n那么父组件可以通过定义这种方式进行接收：getParams(a, ...params) &#123;&#125;\n解绑自定义事件this.$off(&#x27;eventName&#x27;)//解绑一个this.$off([&#x27;eventName1&#x27;,&#x27;eventName2&#x27;])//解绑多个this.off()//解绑所有\n\n通过ref传递的时候，回调函数注意事项通过ref绑定自定义事件的时候，回调函数要写成箭头函数，要么就得写在methods里，不应该写成普通函数（this的指向变成vc实例）\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-28","url":"/2023/03/28/2023-03-28.html/","content":"Vue2 - 23-03-28回顾昨日回调函数在谁身上，谁就可以收到数据；子给父传数据的两种方式：props传函数、在父中给子绑定自定义事件，回调函数为父组件。而绑定自定义事件有两种方式：ref+$refs.xx.$on(事件名称,箭头函数&#x2F;this.methods里的函数)\n事件总线事件总线能实现兄弟组件之间的通信关于能实现事件总线特性的分析，视频里面讲的很绕，反正到最后结论就是往构建的Vue实例对象上，向Vue原型追加一个属性，值为Vue实例本身（视频里面演示了实际上追加一个组件实例也能实现同样的效果，但是步骤繁琐不推荐）有点向在Java里的被追加的（虽然Java实现不了），但是多少能够帮助像我这样的后端理解吧\npublic class Vue&#123;    private Object object;    //Vue vm;//这就是追加后的样子，Java实现不了    Vue(Object object)&#123;this.object = object;&#125;    public static void extends(Object object)&#123;        reutrn new VueComponent(object);    &#125;&#125;class VueComponent&#123;    private Object object;    VueComponent(Object object)&#123;this.object = object;&#125;&#125;Vue vm = new Vue(...);vm.prototype.$bus=vm;//追加的过程，Java实现不了\n\n事件总线实现方式在main.js（创建vm的入口）中创建vue实例的时候，调用生命周期钩子beforeCreate，通过Vue.prototype的方式往Vue原型追加实例vm自身\nnew Vue(&#123;    Vue.prototype.$bus = this&#125;)\n事件总线的使用事件总线可以通过组件实例.$bus.$on(&#39;事件名&#39;,回调方法)进行定义，在通过组件实例.$emit(&#39;事件名&#39;,数据)进行触发，建议在定义事件的地方消亡之前调用组件实例.$off(&#39;事件名&#39;)进行销毁\n\npubsub.js订阅发布库：pub——publish，sub——subscribe使用方式：分别在发布端跟接收端引入，然后在发布端作为触发方法体中可供使用的函数：pubsub.publish(&#39;订阅名称&#39;,数据)；在订阅端（一般在mounted）使用pubsub.subscribe(&#39;订阅名称&#39;,回调函数)，其中回调函数第一个参数为订阅名称，第二个参数为数据\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-30","url":"/2023/03/30/2023-03-30.html/","content":"Vue2 - 23-03-30回顾了一下$set在视频案例里面，up主使用的方式修改了传过来的props，所以应该重点是为了提一下$set导致的疏忽吧如果在this.$set(todo,&#39;isEdited&#39;,true)中写成todo.isEdited=true，就没办法做到响应式，数据不会同步到App.vue\n关于dom未更新不存在input不能触发focus的问题可以使用this.$nextTick(function()&#123;&#125;)让下一次更新（也就是说如果本次涉及修改数据的话就是紧接着这次），再去执行回调函数\n动画及过度【视频地址p91-p95】，因为这部分内容很容易忘，之前学习css的时候就练过，都还回去了…后面需要在进行补充吧  \nvue 动画的理解\n1.操作 css 的 trasition 或 animation\n2.vue 会给目标元素添加&#x2F;移除特定的 class\n3.过渡的相关类名：\n1.xxx-enter-active: 指定显示的 transition\n2.xxx-leave-active: 指定隐藏的 transition\n3.xxx-enter&#x2F;xxx-leave-to: 指定隐藏时的样式\n\n\n\n  \n基本过渡动画的编码\n1.在目标元素外包裹\n2.定义 class 样式\na)指定过渡样式: transition\nb)指定隐藏时的样式: opacity&#x2F;其它\n\n\n\n使用第三方动画库animate.cssanimate.css官网已经给出了相对详细的使用方式了\n贴出完整Test.vue\n&lt;template&gt;    &lt;div&gt;        &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏文字&lt;/button&gt;    &lt;!-- 前两个使用的是默认名称 --&gt;    &lt;transition&gt;        &lt;h1 v-show=&quot;isShow&quot; class=&quot;test&quot;&gt;你好，这是&#123;&#123;name&#125;&#125;！！(一样)&lt;/h1&gt;    &lt;/transition&gt;    &lt;transition&gt;        &lt;h1 v-show=&quot;!isShow&quot; class=&quot;test&quot;&gt;你好，这是&#123;&#123;name.toUpperCase()&#125;&#125;！！(一样)&lt;/h1&gt;    &lt;/transition&gt;    &lt;hr&gt;    &lt;!-- 这是自定义名称动画效果 --&gt;    &lt;transition name=&quot;test2&quot;&gt;        &lt;h1 v-show=&quot;isShow&quot; class=&quot;test2&quot;&gt;你好，这是&#123;&#123;name&#125;&#125;！！（二）&lt;/h1&gt;    &lt;/transition&gt;    &lt;!-- 使用过渡效果 --&gt;    &lt;transition name=&quot;test3&quot;&gt;        &lt;h1 v-show=&quot;!isShow&quot; class=&quot;test3&quot;&gt;你好，这是&#123;&#123;name.toUpperCase()&#125;&#125;！！（三）&lt;/h1&gt;    &lt;/transition&gt;    &lt;hr&gt;    &lt;transition        appear        name=&quot;animate__animated animate__bounce&quot;        enter-active-class=&quot;animate__backInRight&quot;        leave-active-class=&quot;animate__backOutRight&quot;    &gt;        &lt;h1 v-show=&quot;isShow&quot; class=&quot;test4&quot;&gt;你好啊&lt;/h1&gt;    &lt;/transition&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import &#x27;animate.css&#x27;    export default &#123;        data()&#123;            return &#123;                name:&#x27;linzepore&#x27;,                isShow:true            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style&gt;    .test &#123;        background-color: orange;        color: black;        width: 500px;    &#125;    .v-enter-active &#123;        animation: testAni 0.5s;    &#125;    .v-leave-active &#123;        animation: testAni reverse 0.5s    &#125;    @keyframes testAni &#123;        from &#123;            transform: translateX(-100%);        &#125;        to &#123;            transform: translateX(0%);        &#125;    &#125;    .test2 &#123;        background-color: green;        color: black;        width: 500px;    &#125;    .test2-enter-active &#123;        animation: testAni2 .5s;    &#125;    .test-leave-active &#123;        animation: testAni2 reverse .5s;    &#125;    @keyframes testAni2 &#123;        from &#123;            transform: translateX(-100%);        &#125;        to &#123;            transform: translateX(0%);        &#125;    &#125;    .test3 &#123;        background-color: blue;        color: black;        width: 500px;        /* transition: 0.5s; 不破坏结构，可以写成动画：active */    &#125;    .test3-enter &#123;        transform: translateX(-100%);    &#125;    .test3-enter-to &#123;        transform: translateX(0%);    &#125;    .test3-leave &#123;        transform: translateX(0%);    &#125;    .test3-leave-to &#123;        transform: translateX(-100%);    &#125;    .test3-enter-active, .test3-leave-active &#123;        transition: .5s;    &#125;    .test4 &#123;        background-color: blueviolet;    &#125;&lt;/style&gt;\n\n给todoList进行补充动画效果，只修改了List.vue\n&lt;template&gt;      &lt;ul class=&quot;todo-main&quot;&gt;          &lt;!-- 每一份都是独一无二的vc --&gt;      &lt;transition-group name=&#x27;todo&#x27; &gt;          &lt;MyItem           appear          v-for=&quot;todo in todos&quot;           :key=&quot;todo.id&quot;          :todoItem=&quot;todo&quot;          /&gt;      &lt;/transition-group&gt;      &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    import MyItem from &#x27;./MyItem.vue&#x27;    export default &#123;        name:&#x27;MyList&#x27;,        components:&#123;MyItem&#125;,        props:[&#x27;todos&#x27;]    &#125;&lt;/script&gt;&lt;style scoped&gt;/*main*/.todo-main &#123;  margin-left: 0px;  border: 1px solid #ddd;  border-radius: 2px;  padding: 0px;  overflow: hidden;&#125;.todo-empty &#123;  height: 40px;  line-height: 40px;  border: 1px solid #ddd;  border-radius: 2px;  padding-left: 5px;  margin-top: 10px;&#125;@keyframes todoAni &#123;    from &#123;        transform: translateX(100%);    &#125;    to &#123;        transform: translateX(0%);    &#125;&#125;.todo-enter-active &#123;  animation: todoAni 0.5s;&#125;.todo-leave-active &#123;  animation: todoAni reverse 0.5s;&#125;&lt;/style&gt;\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-03-31","url":"/2023/03/31/2023-03-31.html/","content":"Vue2 - 23-03-31几种常见的前后端发送接收方式\nXHR\nJQuery\naxios （鱿鱼须推荐）\nfetch\n\n\nAxiosaxios配合Vue使用，简单的get请求就是\n\nimport axios from &#39;axios&#39;\naxios.get(xxx).then(func1,func2,...)\n\n代理服务器接收跨域请求使用代理服务器进行跨域请求有两种常见的方式：\n\nNginx\nVue-cli\n\nVue-cli配置代理服务器vue-cli中通过 vue.config.js 中的 devServer.proxy 选项来配置，将 API 请求代理到 API 服务器vue-cli文档-&gt;【HERE】单个代理：  \nmodule.exports = &#123;  devServer: &#123;    proxy: &#x27;http://localhost:4000&#x27;  &#125;&#125;\n不同路径多个代理：  \nodule.exports = &#123;  devServer: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;&lt;url&gt;&#x27;,        ws: true,        changeOrigin: true      &#125;,      &#x27;/foo&#x27;: &#123;        target: &#x27;&lt;other_url&gt;&#x27;      &#125;    &#125;  &#125;&#125;\n\n笔记&amp;练习代码App.vue\n&lt;template&gt;  &lt;div&gt;      &lt;button @click=&quot;getStusInfo&quot;&gt;接收学生信息&lt;/button&gt;      &lt;button @click=&quot;getCarsInfo&quot;&gt;接收汽车信息&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import axios from &#x27;axios&#x27;    export default &#123;        name:&#x27;App&#x27;,        data() &#123;            return &#123;                name:&#x27;zepore&#x27;            &#125;        &#125;,        methods: &#123;          getStusInfo()&#123;            axios.get(&#x27;http://localhost:8080/s1/students&#x27;).then(              response=&gt;&#123;                console.log(&#x27;请求成功：&#x27;, response.data);              &#125;,              error=&gt;&#123;                console.log(&#x27;请求失败：&#x27;, error.message);              &#125;            )          &#125;,          getCarsInfo()&#123;            axios.get(&#x27;http://localhost:8080/s2/cars&#x27;).then(              response =&gt; &#123;                console.log(&#x27;请求成功：&#x27; , response.data);              &#125;,              error =&gt; &#123;                console.log(&#x27;请求失败：&#x27; , error.message);              &#125;            )          &#125;        &#125;    &#125;&lt;/script&gt;\n\nvue.config.js\nconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true,  lintOnSave: false,  devServer: &#123;    proxy:&#123;      &#x27;/s1&#x27;: &#123;        target: &#x27;http://localhost:5000&#x27;,        pathRewrite: &#123;&#x27;^/s1&#x27;: &#x27;&#x27;&#125;,        ws: true,        changeOrigin: true      &#125;,      &#x27;/s2&#x27;: &#123;        target: &#x27;http://localhost:5001&#x27;,        pathRewrite: &#123;&#x27;^/s2&#x27;: &#x27;&#x27;&#125;,        ws: true,        changeOrigin:true      &#125;    &#125;  &#125;&#125;)\n\nGitHub搜索案例为何不放asset？引入静态资源，会进行严格检查，没有的字体文件会报错\n技术难点&#x2F;坑使用模板进行拼接链接https://api.github.com/search/users?q=$&#123;this.inputVal&#125; 里的 $&#123;this.inputVal&#125;\n代码练习MyHeader.vue\n&lt;template&gt;    &lt;section class=&quot;jumbotron&quot;&gt;      &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;      &lt;div&gt;        &lt;input         type=&quot;text&quot;         placeholder=&quot;enter the name you search&quot;         v-model=&quot;inputVal&quot;         @keyup.enter=&quot;searchViaLogin&quot;         /&gt;&amp;nbsp;        &lt;button @click=&quot;searchViaLogin&quot;&gt;Search&lt;/button&gt;      &lt;/div&gt;    &lt;/section&gt;&lt;/template&gt;&lt;script&gt;    import axios from &#x27;axios&#x27;    export default &#123;        name:&#x27;MyHeader&#x27;,        data() &#123;          return &#123;            inputVal:&#x27;&#x27;,          &#125;        &#125;,        methods: &#123;          searchViaLogin()&#123;            this.$bus.$emit(&#x27;userList&#x27;,&#123;isFirst:false, isLoading:true, users:[], errMsg:&#x27;&#x27;&#125;)            axios.get(`https://api.github.com/search/users?q=$&#123;this.inputVal&#125;`).then(              receive =&gt;&#123;                  // console.log(receive.data);                  this.$bus.$emit(&#x27;userList&#x27;,&#123;isLoading:false, users:receive.data.items, errMsg:&#x27;&#x27;&#125;)              &#125;,              error =&gt; &#123;                console.log(error.message);                this.$bus.$emit(&#x27;userList&#x27;,&#123;isLoading:false, users:[], errMsg:error.message&#125;)              &#125;            )          &#125;        &#125;    &#125;&lt;/script&gt;\nMyList.vue\n&lt;template&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;!-- 发送成功之后 --&gt;      &lt;div class=&quot;card&quot; v-for=&quot;user in info.users&quot; :key=&quot;user.login&quot;&gt;        &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;          &lt;img :src=&quot;user.avatar_url&quot; style=&#x27;width: 100px&#x27;/&gt;        &lt;/a&gt;        &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;user.login&#125;&#125;&lt;/p&gt;      &lt;/div&gt;      &lt;!-- 第一次展示欢迎词 --&gt;      &lt;div v-show=&quot;info.isFirst&quot;&gt;        &lt;h1&gt;欢迎使用&lt;/h1&gt;      &lt;/div&gt;      &lt;!-- 搜索过程展示加载中 --&gt;      &lt;div v-show=&quot;info.isLoading&quot;&gt;        &lt;h1&gt;加载中...&lt;/h1&gt;      &lt;/div&gt;      &lt;!-- 搜索错误展示错误信息 --&gt;      &lt;div v-show=&quot;info.errMsg&quot;&gt;        &lt;h1&gt;&#123;&#123;info.errMsg&#125;&#125;&lt;/h1&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name: &#x27;MyList&#x27;,        data() &#123;          return &#123;            info: &#123;              isFirst:true,              isLoading:false,              users:[],              errMsg:&#x27;&#x27;            &#125;          &#125;        &#125;,        mounted() &#123;          this.$bus.$on(&#x27;userList&#x27;, (info)=&gt;&#123;            console.log(&#x27;List这边收到了&#x27;,info);            // this.users = users;            this.info = info          &#125;)        &#125;,    &#125;&lt;/script&gt;&lt;style&gt;.album &#123;    min-height: 50rem; /* Can be removed; just added for demo purposes */    padding-top: 3rem;    padding-bottom: 3rem;    background-color: #f7f7f7;  &#125;  .card &#123;    float: left;    width: 33.333%;    padding: .75rem;    margin-bottom: 2rem;    border: 1px solid #efefef;    text-align: center;  &#125;  .card &gt; img &#123;    margin-bottom: .75rem;    border-radius: 100px;  &#125;  .card-text &#123;    font-size: 85%;  &#125;&lt;/style&gt;\nApp.vue\n&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;MyHeader /&gt;    &lt;MyList/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import MyHeader from &#x27;./components/MyHeader.vue&#x27;  import MyList from &#x27;./components/MyList.vue&#x27;    export default &#123;        name:&#x27;App&#x27;,        data() &#123;            return &#123;                name:&#x27;zepore&#x27;            &#125;        &#125;,        components:&#123;MyHeader,MyList&#125;    &#125;&lt;/script&gt;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-04-02","url":"/2023/04/02/2023-04-02.html/","content":"Vue2 - 23-04-02插槽\n作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 。\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式：\n\n默认插槽：\n父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n具名插槽：\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n作用域插槽：\n\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n\n具体编码：\n父组件中：        &lt;Category&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script&gt;            export default &#123;                name:&#x27;Category&#x27;,                props:[&#x27;title&#x27;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;\n\n\n\n\n\nVuex官方文档-&gt;与 Vue 2 匹配的 Vuex 3 的文档  \nVuex的引入为什么不在Vue的入口文件引入？\n\n会出现报错，因为是插件，要引入并使用，使用的时候ES6会把import放到前面，参考视频说法：【尚硅谷vuejs从入门到精通】 【精准空降到 23:03】\n\n在vuex/store.js或store/index.js(官方推荐)这样写\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)// new不能丢export default new Vuex.Store(&#123;    actions:&#123;        ...    &#125;,    mutations:&#123;        ...    &#125;,    state:&#123;        ...    &#125;&#125;)\n在入口函数引入  \nimport store from &#x27;../store&#x27;new Vue(&#123;    //...    store    //...&#125;)\n使用vuex搞清楚vuex，要清楚vuex是干嘛的，vuex是插件，插件的使用参考之前的文章我们可以在组件实例中通过this.$store.dispatch(params)操作store的actions，也可以通过this.$store.commit(params)操作store的mutations，当然也可以通过this.$store.state.xxx查看状态变量xxx。在配置index的时候，actions中接收到的参数第一个是context，一个迷你版的store，第二个参数是在dispatch传入的值；配置mutations的时候，第一个参数是状态变量，第二个参数是调用commit的时候传入的参数\nvuex基础总结\n1.概念\n在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。\n\n2.何时使用？\n多个组件需要共享数据时\n\n3.搭建vuex环境\n创建文件：src/store/index.js\n//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate&#125;)\n\n在main.js中创建vm时传入store配置项\n......//引入storeimport store from &#x27;./store&#x27;......//创建vmnew Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App),\tstore&#125;)\n\n4.基本使用\n初始化数据、配置actions、配置mutations，操作文件store.js\n//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123;    //响应组件中加的动作\tjia(context,value)&#123;\t\t// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)\t\tcontext.commit(&#x27;JIA&#x27;,value)\t&#125;,&#125;const mutations = &#123;    //执行加\tJIA(state,value)&#123;\t\t// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)\t\tstate.sum += value\t&#125;&#125;//初始化数据const state = &#123;   sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\n组件中读取vuex中的数据：$store.state.sum\n\n组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或 $store.commit(&#39;mutations中的方法名&#39;,数据)\n\n 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\n\n\n\nvuex的getters配置项vuex的getters配置项类似于vm、vc中的computed，接收到的第一个参数是state，第二个参数是getters\ngetters:&#123;    puls10(state,b)&#123;        console.log(state,b);        return state.sum*10;    &#125;&#125;\n\nmapState和mapGetters在使用vuex的时候，前面那一坨重复的this.$store.state、this.$store.getters很烦人？鱿鱼须也想到了这一点，然后就有了mapXXX  \n使用方式import &#123;mapState,mapGetters&#125; from &#39;vuex&#39;...mapState([&#39;stateName&#39;,...]), &#x2F; ...mapState(&#123;computedName:&#39;stateName&#39;,...&#125;)...mapGetters([&#39;gettersName&#39;,...]), &#x2F; ...mapGetters(&#123;computedName:&#39;gettersName&#39;,...&#125;)\n&lt;script&gt;    import &#123;mapState,mapGetters&#125; from &#x27;vuex&#x27;    export default &#123;        name:&#x27;Count&#x27;,        data() &#123;            return &#123;                num:1            &#125;        &#125;,        computed:&#123;            /*自己写计算属性            sum()&#123;                return this.$store.state.sum            &#125;,            schoolName()&#123;                return this.$store.state.schoolName            &#125;,            schoolAddr()&#123;                return this.$store.state.schoolAddr            &#125;,*/            /* 使用mapState自动生成计算属性：对象（前面为属性名，后为状态名）            ...mapState(&#123;sum:&#x27;sum&#x27;,schoolName:&#x27;schoolName&#x27;,schoolAddr:&#x27;schoolAddr&#x27;&#125;),*/            // 使用mapState自动生成计算属性：数组（属性名、状态名重合的时候对象可缺省）            ...mapState([&#x27;sum&#x27;,&#x27;schoolName&#x27;,&#x27;schoolAddr&#x27;]),            // ================================================================================            /* 自己写计算属性的getters            puls10()&#123;                return this.$store.getters.puls10            &#125;,*/            ...mapGetters([&#x27;plus10&#x27;])        &#125;,        methods:&#123;            increment() &#123;                this.$store.commit(&#x27;increment&#x27;,this.num)                console.log(this);            &#125;,            decrement() &#123;                this.$store.commit(&#x27;decrement&#x27;,this.num)            &#125;,            incrementOdd()&#123;                this.$store.dispatch(&#x27;incrementOdd&#x27;,this.num)            &#125;,            incrementWait() &#123;                // setTimeout(()=&gt;&#123;                //     this.$store.dispatch(&#x27;incrementWait&#x27;,this.num)                // &#125;,3000)                this.$store.dispatch(&#x27;incrementWait&#x27;,this.num)            &#125;        &#125;    &#125;&lt;/script&gt;","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-04-03","url":"/2023/04/03/2023-04-03.html/","content":"Vue2 - 23-04-03mapMutations和mapActionsmapMutations和mapActions 跟 mapState和mapGetters 很像写法：  \n\n...mapMutations(&#123;methodName:&#39;mutationName&#39;,methodName:&#39;mutationName&#39;,...&#125;) &#x2F; ...mapMutations([&#39;mutationName(==methodName)&#39;,&#39;mutationName(==methodName)&#39;,...])  \n...mapActions(&#123;methodName:&#39;actionName&#39;,methodName:&#39;actionName&#39;,...&#125;) &#x2F; ...mapActions([&#39;actionName(==methodName)&#39;,&#39;actionName(==methodName)&#39;,...])\n\nmethods:&#123;            // 自己写mutations调用者方法            /*increment() &#123;                this.$store.commit(&#x27;increment&#x27;,this.num)                console.log(this);            &#125;,            decrement() &#123;                this.$store.commit(&#x27;decrement&#x27;,this.num)            &#125;,*/            // mapMutations写法：对象            // ...mapMutations(&#123;increment:&#x27;increment&#x27;,decrement:&#x27;decrement&#x27;&#125;),            // mapMutations写法：数组            ...mapMutations([&#x27;increment&#x27;,&#x27;decrement&#x27;]),            // 自己写actions调用者方法            /*            incrementOdd()&#123;                this.$store.dispatch(&#x27;incrementOdd&#x27;,this.num)            &#125;,            incrementWait() &#123;                // setTimeout(()=&gt;&#123;                //     this.$store.dispatch(&#x27;incrementWait&#x27;,this.num)                // &#125;,3000)                this.$store.dispatch(&#x27;incrementWait&#x27;,this.num)            */            // mapActions写法：对象            // ...mapActions(&#123;incrementOdd:&#x27;incrementOdd&#x27;,incrementWait:&#x27;incrementWait&#x27;&#125;)            // mapActions写法：数组            ...mapActions([&#x27;incrementOdd&#x27;,&#x27;incrementWait&#x27;])&#125;\n\nvuex模块化写法与namespaced属性引入并配置首先要把独立配置项组合（标配四大件：actions、mutations、state、getters）的对象分开写，导入index.js，之后在配置Vuex.Store的时候，传入modules对象，每对key-value分别对应namespace:模块对象的名字\n使用方式在computed&#x2F;methods中，使用mapXX的话与前面非模块化写法类似：\nimport &#123;mapXXX,...&#125; from &#x27;vuex&#x27;computed() &#123;    ...mapState(&#x27;namespace&#x27;,[&#x27;stateName1&#x27;,&#x27;stateName2&#x27;,...]),    ...mapGetters(&#x27;namespace&#x27;,[&#x27;gettersName1&#x27;,&#x27;gettersNames2&#x27;,...])&#125;methods() &#123;    ...mapActions(&#x27;namespace&#x27;,[&#x27;actionsName1&#x27;,&#x27;actionsName2&#x27;,...])    ...mapMutations(&#x27;namespace&#x27;,[&#x27;mutationsName1&#x27;,&#x27;mutationsName2&#x27;,...])&#125;\n手动写的话会麻烦很多\ncomputed() &#123;    stateName1() &#123;        return this.$store.state.namespace.stateName1    &#125;    gettersName1() &#123;        return this.$store.getters[namespace/gettersName1]    &#125;&#125;methods() &#123;    actionsName1() &#123;        this.$store.dispatch(&#x27;namespace/actionsName1&#x27;,param)    &#125;    mutationsName1() &#123;        this.$store.commit(&#x27;namespace/mutationsName1&#x27;,param)    &#125;&#125;\n\n总结以及笔记四个map方法的使用\nmapState方法：用于帮助我们映射state中的数据为计算属性\ncomputed: &#123;    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;,\n\nmapGetters方法：用于帮助我们映射getters中的数据为计算属性\ncomputed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters([&#x27;bigSum&#x27;])&#125;,\n\nmapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\nmethods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125;\n\nmapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\nmethods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125;\n\n\n备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n\n模块化+命名空间\n目的：让代码更好维护，让多种数据分类更加明确。\n\n修改store.js\nconst countAbout = &#123;  namespaced:true,//开启命名空间  state:&#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123;       return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced:true,//开启命名空间  state:&#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n\n开启命名空间后，组件中读取state数据：\n//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),\n\n开启命名空间后，组件中读取getters数据：\n//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])\n\n开启命名空间后，组件中调用dispatch\n//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n\n开启命名空间后，组件中调用commit\n//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n路由\n理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件，后端路由value是函数\n\n配置并引入路由//.../router/index.jsimport VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;import VC from &#x27;xxx/xxx&#x27;Vue.use(VueRouter)const vr = new VueRouter(&#123;   routes:[      &#123;path: &#x27;/path&#x27;, component: VC&#125;,   ]&#125;)export default vr//.../main.jsimport vr from &#x27;.../router&#x27;new Vue(&#123;   router:vr&#125;)\n路由的使用可以配合&lt;router-view&gt;&lt;/router-view&gt;和&lt;router-link&gt;&lt;/router-link&gt;一起使用，&lt;router-view&gt;&lt;/router-view&gt;为路由到的组件之后会插入的地方，&lt;router-link&gt;&lt;/router-link&gt;最后会解析成&lt;a&gt;标签\n路由基本使用——总结1.基本使用\n安装vue-router，命令：npm i vue-router\n\n应用插件：Vue.use(VueRouter)\n\n编写router配置项:\n//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)//暴露routerexport default router\n\n实现切换（active-class可配置高亮样式）\n&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\n指定展示位置\n&lt;router-view&gt;&lt;/router-view&gt;\n\n2.几个注意点\n路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route属性，里面存储着自己的路由信息。\n整个应用只有一个router，可以通过组件的$router属性获取到。\n\n多级路由（多级路由）\n配置路由规则，使用children配置项：\nroutes:[\t&#123;\t\tpath:&#x27;/about&#x27;,\t\tcomponent:About,\t&#125;,\t&#123;\t\tpath:&#x27;/home&#x27;,\t\tcomponent:Home,\t\tchildren:[ //通过children配置子级路由\t\t\t&#123;\t\t\t\tpath:&#x27;news&#x27;, //此处一定不要写：/news\t\t\t\tcomponent:News\t\t\t&#125;,\t\t\t&#123;\t\t\t\tpath:&#x27;message&#x27;,//此处一定不要写：/message\t\t\t\tcomponent:Message\t\t\t&#125;\t\t]\t&#125;]\n\n跳转（要写完整路径）：\n&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-04-04","url":"/2023/04/04/2023-04-04.html/","content":"Vue2 - 23-04-04路由query传参第一种写法：模板字符串+路径直接写&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;msg.id&#125;&amp;title=$&#123;msg.title&#125;&amp;content=$&#123;msg.content&#125;`&quot;&gt;\n第二种写法：对象式写法  \n&lt;router-link    :to=&quot;&#123;     path:&#x27;/home/message/detail&#x27;,     query:&#123;       title:msg.title,       id:msg.id,       content:msg.content     &#125;   &#125;&quot;&gt;\n使用：在路由组件找到$route.queryeg.&#123;&#123;$route.query.id&#125;&#125;\n路由命名路由命名要在路由处配置name属性，在使用的时候，给to选项用上name就不用path，可以避免把自己写乱了\n路由params传参要先到路由配置的地方进行占位\n路由params传参:路径写法&lt;router-link :to=&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;${msg.id}&#x2F;${msg.title}&#x2F;${msg.content}&quot;&gt;  \n路由params传参:对象写法&lt;router-link :to=&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;${msg.id}&#x2F;${msg.title}&#x2F;${msg.content}&quot;&gt;\n两种传参方式总结路由的query参数\n传递参数\n&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tpath:&#x27;/home/message/detail&#x27;,\t\tquery:&#123;\t\t   id:666,            title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数：\n$route.query.id$route.query.title\n\n命名路由\n作用：可以简化路由的跳转。\n\n如何使用\n\n给路由命名：\n&#123;    path:&#x27;/demo&#x27;,    component:Demo,    children:[        &#123;            path:&#x27;test&#x27;,            component:Test,            children:[                &#123;                      name:&#x27;hello&#x27; //给路由命名                    path:&#x27;welcome&#x27;,                    component:Hello,                &#125;            ]        &#125;    ]&#125;\n\n简化跳转：\n&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link     :to=&quot;&#123;        name:&#x27;hello&#x27;,        query:&#123;           id:666,            title:&#x27;你好&#x27;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n\n\n路由的params参数\n配置路由，声明接收params参数\n&#123;\tpath:&#x27;/home&#x27;,\tcomponent:Home,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;news&#x27;,\t\t\tcomponent:News\t\t&#125;,\t\t&#123;\t\t\tcomponent:Message,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiangqing&#x27;,\t\t\t\t\tpath:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n传递参数\n&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t   id:666,            title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n\n特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n\n接收参数：\n$route.params.id$route.params.title\n\n使用props提高接收参数的效率// 第一种写法：对象式，只能写死数据// props:&#123;a:&quot;xxx&quot;,b:&quot;yyy&quot;&#125;//第二种写法：能接收到所有的params// props:true//第三种写法：函数式，返回值会给到路由组件的propsprops(route)&#123;    return &#123;        title:route.params.title,        id:route.params.id,        content:route.params.content    &#125;&#125;\n\n作用：让路由组件更方便的收到参数\n\n&#123;\tname:&#x27;xiangqing&#x27;,\tpath:&#x27;detail/:id&#x27;,\tcomponent:Detail,\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\t// props:&#123;a:900&#125;\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\t// props:true\t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\tprops(route)&#123;\t\treturn &#123;\t\t\tid:route.query.id,\t\t\ttitle:route.query.title\t\t&#125;\t&#125;&#125;\n\nrouter-link的replace模式router-link的replace属性相对于默认的压栈出栈式模式  \n\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push\n如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt;\n\n编程式路由导航\n作用：不借助&lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活\n\n具体编码：\n//$router的两个APIthis.$router.push(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.replace(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退，正负数值决定\n\n路由缓存\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n具体编码：\n&lt;keep-alive include=&quot;News&quot;&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n&lt;!-- 缓存所有 --&gt;&lt;!-- &lt;keep-alive&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; --&gt;&lt;!-- 缓存指定单个 --&gt;&lt;!-- &lt;keep-alive&gt;&lt;router-view include=&quot;News&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; --&gt;&lt;!-- 缓存指定多个 --&gt;&lt;keep-alive&gt;  &lt;router-view :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n使用了keep-alive之后才有两个生命周期！配合keep-alive标签时候，有了这两个新的生命周期钩子，不会重新create组件，但会监测激活状态\n\n作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n具体名字：\nactivated路由组件被激活时触发。\ndeactivated路由组件失活时触发。\n\n\n\n路由守卫路由守卫有三大类：全局守卫、独享守卫、组件内守卫。全局守卫分前后守卫，beforeEach((to,from,next)=&gt;&#123;&#125;)、afterEach((to,from,next)=&gt;&#123;&#125;)独享守卫只有beforeEnter((to,from,next)=&gt;&#123;&#125;)组件内守卫分两种：beforeRouterEnter((to,from,next)=&gt;&#123;&#125;)、beforeRouterLeave((to,from,next)=&gt;&#123;&#125;)，要注意只有被路由的时候才会触发，作为组件不会触发\n\n作用：对路由进行权限控制\n\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫:\n//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123;\tconsole.log(&#x27;beforeEach&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则\t\t\tnext() //放行\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext() //放行\t&#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;afterEach&#x27;,to,from)\tif(to.meta.title)&#123; \t\tdocument.title = to.meta.title //修改网页的title\t&#125;else&#123;\t\tdocument.title = &#x27;vue_test&#x27;\t&#125;&#125;)\n\n独享守卫:\nbeforeEnter(to,from,next)&#123;\tconsole.log(&#x27;beforeEnter&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;\t\t\tnext()\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext()\t&#125;&#125;\n\n组件内守卫：\n//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\n\n路由器的两种工作模式\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\nhash模式：\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory模式：\n地址干净，美观 。\n兼容性和hash模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n\n\n\n","categories":["Learning","Vue2"],"tags":["learning","GDIP","Vue2"]},{"title":"Vue2 - 23-04-05","url":"/2023/04/05/2023-04-05.html/","content":"uniapp - 23-04-05配置相关condition配置项\npages配置项的第一个顺序为默认的首页\n//list[0]==&#123;&quot;name&quot;: &quot;详情页&quot;,&quot;path&quot;: &quot;pages/detail/detail&quot;,&quot;query&quot;: &quot;id=80&quot;&#125;&quot;condition&quot;: &#123;\t\t&quot;current&quot;: 0,\t\t&quot;list&quot;: [\t\t\t&#123;\t\t\t\t&quot;name&quot;: &quot;详情页&quot;,\t\t\t\t&quot;path&quot;: &quot;pages/detail/detail&quot;,\t\t\t\t&quot;query&quot;: &quot;id=80&quot;\t\t\t&#125;\t\t]\t&#125;\n\n微信开发者工具启动方式\n缓存数据的异步方法与同步方法//异步写法uni.setStorage(&#123;\tkey: &#x27;id&#x27;,\tdata: 80,\tsuccess(res) &#123;\t\tconsole.log(&#x27;存储成功&#x27;,res);\t&#125;&#125;)//同步写法uni.setStorageSync(&#x27;id&#x27;,80)//异步写法uni.getStorage(&#123;\tkey: &#x27;id&#x27;,\tsuccess(res) &#123;\t\tconsole.log(&#x27;获取成功&#x27;,res);\t&#125;&#125;)//同步写法console.log(uni.getStorageSync(&#x27;id&#x27;));//异步写法uni.removeStorage(&#123;\tkey:&#x27;id&#x27;,\tsuccess(res) &#123;\t\tconsole.log(&#x27;移除成功&#x27;,res);\t&#125;&#125;)//同步写法uni.removeStorageSync(&#x27;id&#x27;);\n上传图片以及预览&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;chooseImg&quot;&gt;上传图片&lt;/button&gt;\t\t&lt;image\t\tv-for=&quot;(img,index) in imgArr&quot;\t\t:key=&quot;index&quot;\t\t:src=&quot;img&quot;\t\tmode=&quot;aspectFit&quot;\t\t@click=&quot;previewImg(img)&quot;\t\t&gt;&lt;/image&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata()&#123;\t\t\treturn &#123;\t\t\t\timgArr:[]\t\t\t&#125;\t\t&#125;,\t\tmethods:&#123;\t\t\tchooseImg() &#123;\t\t\t\tuni.chooseImage(&#123;\t\t\t\t\tcount:5,//实际上很多时候控制不了\t\t\t\t\tsuccess:(imgs)=&gt;&#123;\t\t\t\t\t\tconsole.log(imgs);\t\t\t\t\t\tthis.imgArr = imgs.tempFilePaths\t\t\t\t\t&#125;//使用this的时候要改用箭头函数\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tpreviewImg(img) &#123;\t\t\t\tuni.previewImage(&#123;\t\t\t\t\tcurrent:img,\t\t\t\t\turls:this.imgArr,\t\t\t\t\tloop:true\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n多平台注释编译参考官方文档-&gt;条件编译\n#ifdef#endif\n\n声明式跳转及编程式跳转声明式跳转（组件）编程式跳转（API）\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;view&gt;导航跳转学习&lt;/view&gt;\t\t&lt;navigator url=&quot;/pages/detail/detail?id=80&amp;age=19&quot;&gt;跳转到详情页(默认可以返回)&lt;/navigator&gt;\t\t&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;跳转到信息页&lt;/navigator&gt;\t\t&lt;navigator url=&quot;/pages/detail/detail&quot; open-type=&quot;redirect&quot;&gt;跳转到详情页（redirect不可返回）&lt;/navigator&gt;\t\t&lt;button @click=&quot;directToDetail&quot;&gt;跳转到详情页&lt;/button&gt;\t\t&lt;button @click=&quot;directToMsg&quot;&gt;跳转到tab页面，并关闭所有非tab页面&lt;/button&gt;\t\t&lt;button @click=&quot;redirectToDetail&quot;&gt;跳转非tab但仅关闭当前页面&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tonUnload() &#123;\t\t\tconsole.log(&#x27;导航页面卸载了&#x27;);\t\t&#125;,\t\tmethods:&#123;\t\t\tdirectToDetail() &#123;\t\t\t\tuni.navigateTo(&#123;\t\t\t\t\turl:&quot;/pages/detail/detail&quot;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tdirectToMsg() &#123;\t\t\t\tuni.switchTab(&#123;\t\t\t\t\turl:&quot;/pages/message/message&quot;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tredirectToDetail()&#123;\t\t\t\tuni.redirectTo(&#123;\t\t\t\t\turl:&quot;/pages/detail/detail&quot;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n传参的形式：query+onLoad(options)\n","categories":["Learning","uni-app"],"tags":["learning","GDIP","uni-app"]},{"title":"uCharts - 23-04-09","url":"/2023/04/09/2023-04-09.html/","content":"uniapp - 23-04-09uCharts与eCharts为什么会做这个？eCharts不香吗\n\n呃呃，eCharts因为涉及大量dom操作，微信小程序上会报错，uCharts对小程序兼容性较好\n\n食用方式先看看官方的例子，后面再以一个菜鸟的角度分解\n&lt;template&gt;  &lt;view&gt;    &lt;canvas canvas-id=&quot;column&quot; id=&quot;column&quot; class=&quot;charts&quot; @touchend=&quot;tap&quot;/&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import uCharts from &#x27;../../../js/uCharts-master/uni-app/uCharts-原生/u-charts.min.js&#x27;var uChartsInstance = &#123;&#125;;export default &#123;  data() &#123;    return &#123;      cWidth: 750,      cHeight: 500    &#125;;  &#125;,  onReady() &#123;    //这里的 750 对应 css .charts 的 width    this.cWidth = uni.upx2px(750);    //这里的 500 对应 css .charts 的 height    this.cHeight = uni.upx2px(500);    this.getServerData();  &#125;,  methods: &#123;    getServerData() &#123;      //模拟从服务器获取数据时的延时      setTimeout(() =&gt; &#123;        //模拟服务器返回数据，如果数据格式和标准格式不同，需自行按下面的格式拼接        let res = &#123;            categories: [&quot;2016&quot;,&quot;2017&quot;,&quot;2018&quot;,&quot;2019&quot;,&quot;2020&quot;,&quot;2021&quot;],            series: [              &#123;                name: &quot;目标值&quot;,                data: [35,36,31,33,13,34]              &#125;,              &#123;                name: &quot;完成量&quot;,                data: [18,27,21,24,6,28]              &#125;            ]          &#125;;        this.drawCharts(&#x27;column&#x27;, res);      &#125;, 500);    &#125;,    drawCharts(id,data)&#123;      const ctx = uni.createCanvasContext(id, this);      uChartsInstance[id] = new uCharts(&#123;        type: &quot;column&quot;,        context: ctx,        width: this.cWidth,        height: this.cHeight,        categories: data.categories,        series: data.series,        animation: true,        background: &quot;#FFFFFF&quot;,        padding: [15,15,0,5],        xAxis: &#123;          disableGrid: true        &#125;,        yAxis: &#123;          data: [&#123;min: 0&#125;]        &#125;,        extra: &#123;          column: &#123;            type: &quot;group&quot;          &#125;        &#125;      &#125;);    &#125;,    tap(e)&#123;      uChartsInstance[e.target.id].touchLegend(e);      uChartsInstance[e.target.id].showToolTip(e);    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;  .charts&#123;    width: 750rpx;    height: 500rpx;  &#125;&lt;/style&gt;\n涉及到的方法有：getServerData()模拟从服务器获取数据的时间延时，同时会调用drawChart(canvasID)，drawChart(canvasID)的逻辑是先创建canvas画布实例（canvasId+this），在创建uCharts实例，uCharts实例引用至canvasId索引的uCharts对象，创建实例的配置里面给定表格类型type、绑定画布实例context、width、height、categories （同一series不同category间的颜色一样）、series （同一categorie不同series间的颜色不同）、extra&gt;column&gt;type:”group”（实测在多个series的时候不能缺少）\n关于样式的必要性首先，vc的data中宽高有必要吗？答案是：不写不影响效果的呈现但是写了就有了Vue的数据代理（响应式的数据）uni.upx2px的作用？答案是：将rpx单位值转换成px，参考uni.upx2px()最后最后，style也不能缺需要赋予同等宽高（方便记忆，也许不一定要一样）\n关于categories与seriescategories （同一series不同category间的颜色一样），series （同一categorie不同series间的颜色不同）  \n去掉图例以及扩大间距图例配置 opts.legend、扩展配置&gt;柱状图\n//图例legend:&#123;\tshow:false&#125;,extra:&#123;\tcolumn:&#123;\t\ttype:&#x27;group&#x27;,\t\t//多属性间距\t\tseriesGap:20,\t\t//柱的宽度\t\twidth:140\t&#125;&#125;\n\n\n下溢出的处理\n手动加上y轴的值：多Y轴配置 opts.yAxis.data[i]\n\nyAxis:&#123;\tdata:[\t\t&#123;min:0,max:90&#125;\t]&#125;\n\n附上样题的柱状图复现代码&lt;template&gt;\t&lt;canvas class=&quot;uctest&quot; id=&quot;uctest&quot; canvas-id=&quot;uctest&quot; @touchend=&quot;tap&quot;&gt;&lt;/canvas&gt;&lt;/template&gt;&lt;script&gt;\timport uCharts from &#x27;../../../js/uCharts-master/uni-app/uCharts-原生/u-charts&#x27;\tvar uChartsInstances = &#123;&#125;\texport default &#123;\t\tonReady() &#123;\t\t\tthis.cWidth = uni.upx2px(750)\t\t\tthis.cHeight = uni.upx2px(500)\t\t\tthis.getServerData()\t\t&#125;,\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\tchartData:&#123;&#125;,\t\t\t\tcWidth:750,\t\t\t\tcHeight:500\t\t\t&#125;\t\t&#125;,\t\tmethods:&#123;\t\t\tgetServerData() &#123;\t\t\t\tsetTimeout(()=&gt;&#123;\t\t\t\t\tlet res = &#123;\t\t\t\t\t\tcategories:[&#x27;&#x27;],//不写就不会显示\t\t\t\t\t\tseries:[\t\t\t\t\t\t\t&#123;\t\t\t\t\t\t\t\tname:&#x27;第一种&#x27;,\t\t\t\t\t\t\t\tdata:[82]\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t,\t\t\t\t\t\t\t&#123;\t\t\t\t\t\t\t\tname:&#x27;第二种&#x27;,\t\t\t\t\t\t\t\tdata:[63]\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t]\t\t\t\t\t&#125;\t\t\t\tthis.chartData = JSON.parse(JSON.stringify(res))\t\t\t\tthis.drawChart(&#x27;uctest&#x27;)\t\t\t\t&#125;\t\t\t\t,300)\t\t\t&#125;,\t\t\tdrawChart(id,data) &#123;\t\t\t\tconst canvasInstance = uni.createCanvasContext(id,this)\t\t\t\tuChartsInstances[id] = new uCharts(&#123;\t\t\t\t\ttype:&#x27;column&#x27;,\t\t\t\t\tcontext:canvasInstance,\t\t\t\t\twidth:this.cWidth,\t\t\t\t\theight:this.cHeight,\t\t\t\t\tcategories:this.chartData.categories,\t\t\t\t\tseries:this.chartData.series,\t\t\t\t\tanimation:true,\t\t\t\t\tpadding:[15,15,0,5],\t\t\t\t\tlegend:&#123;\t\t\t\t\t\tshow:false\t\t\t\t\t&#125;,\t\t\t\t\tyAxis:&#123;\t\t\t\t\t\tdata:[\t\t\t\t\t\t\t&#123;min:0,max:90&#125;\t\t\t\t\t\t]\t\t\t\t\t&#125;,\t\t\t\t\textra:&#123;\t\t\t\t\t\tcolumn:&#123;\t\t\t\t\t\t\ttype:&#x27;group&#x27;,\t\t\t\t\t\t\tseriesGap:20,\t\t\t\t\t\t\twidth:140\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\ttap(e)&#123;\t\t\t\tconsole.log(uChartsInstances[e.target.id]);\t\t\t\tuChartsInstances[e.target.id].touchLegend(e)\t\t\t\tuChartsInstances[e.target.id].showToolTip(e)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;\t.uctest&#123;\t\twidth: 750rpx;\t\theight: 500rpx;\t&#125;&lt;/style&gt;\n\n以上，uCharts新手的原生方式探索之路昨天其实已经试过uCharts的组件方式跟eCharts的原生方式，感觉uCharts的组件方式特别适合小程序，而eCharts的原生方式比uCharts的原生方式更友好一些\n","categories":["Learning","uCharts"],"tags":["learning","GDIP","uCharts"]},{"title":"查漏补缺 - 23-04-11","url":"/2023/04/11/2023-04-11.html/","content":"查漏补缺 - 23-04-11solidity - struct的赋值在mapping(uint256 =&gt; ProductData) private _product;中，  \n知道所有值的时候\n_product[traceNumber] = ProductData(&#123;xxx:xxx,...&#125;)\n只知道一部分值的时候\n_product[traceNumber].tracenumber = xxx;_product[traceNumber].product.XXX = xxx;","categories":["Learning","Vue2","solidity"],"tags":["learning","solidity","GDIP","Vue2"]},{"title":"Vue网课笔记","url":"/2023/03/30/Vue%E8%A7%86%E9%A2%91%E8%80%81%E5%B8%88%E7%AC%94%E8%AE%B0.html/","content":"笔记脚手架文件结构├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n\n关于不同版本的Vue\nvue.js与vue.runtime.xxx.js的区别：\nvue.js是完整版的Vue，包含：核心功能 + 模板解析器。\nvue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。\n\n\n因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\nvue.config.js配置文件\n使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。\n使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\nref属性\n被用来给元素或子组件注册引用信息（id的替代者）\n应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\n使用方式：\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\nprops配置项\n功能：让组件接收外部传过来的数据\n\n传递数据：&lt;Demo name=&quot;xxx&quot;/&gt;\n\n接收数据：\n\n第一种方式（只接收）：props:[&#39;name&#39;] \n\n第二种方式（限制类型）：props:&#123;name:String&#125;\n\n第三种方式（限制类型、限制必要性、指定默认值）：\n props:&#123;\tname:&#123;\ttype:String, //类型\trequired:true, //必要性\tdefault:&#x27;老王&#x27; //默认值\t&#125;&#125;\n\n\n备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\n\n\n\nmixin(混入)\n功能：可以把多个组件共用的配置提取成一个混入对象\n\n使用方式：\n 第一步定义混合：\n &#123;    data()&#123;....&#125;,    methods:&#123;....&#125;    ....&#125;\n\n 第二步使用混入：\n ​\t全局混入：Vue.mixin(xxx) ​\t局部混入：mixins:[&#39;xxx&#39;]\t\n\n\n插件\n功能：用于增强Vue\n\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n定义插件：\n 对象.install = function (Vue, options) &#123;    // 1. 添加全局过滤器    Vue.filter(....)    // 2. 添加全局指令    Vue.directive(....)    // 3. 配置全局混入(合)    Vue.mixin(....)    // 4. 添加实例方法    Vue.prototype.$myMethod = function () &#123;...&#125;    Vue.prototype.$myProperty = xxxx&#125;\n\n使用插件：Vue.use()\n\n\nscoped样式\n作用：让样式在局部生效，防止冲突。\n写法：&lt;style scoped&gt;\n\n总结TodoList案例\n组件化编码流程：\n ​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n ​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n ​\t\t\t1).一个组件在用：放在组件自身即可。\n ​\t\t\t2). 一些组件在用：放在他们共同的父组件上（状态提升）。\n ​\t(3).实现交互：从绑定事件开始。\n\nprops适用于：\n ​\t(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信\n ​\t(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）\n\n使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\n\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n\n\nwebStorage\n存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n相关API：\n\nxxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\nxxxxxStorage.getItem(&#39;person&#39;);\n ​\t\t该方法接受一个键名作为参数，返回键名对应的值。\n\nxxxxxStorage.removeItem(&#39;key&#39;);\n ​\t\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n xxxxxStorage.clear()\n ​\t\t该方法会清空存储中的所有数据。\n\n\n\n备注：\n\nSessionStorage存储的内容会随着浏览器窗口关闭而消失。\nLocalStorage存储的内容，需要手动清除才会消失。\nxxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。\nJSON.parse(null)的结果依然是null。\n\n\n\n组件的自定义事件\n一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件\n\n使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n\n绑定自定义事件：\n\n第一种方式，在父组件中：&lt;Demo @atguigu=&quot;test&quot;/&gt;  或 &lt;Demo v-on:atguigu=&quot;test&quot;/&gt;\n\n第二种方式，在父组件中：\n &lt;Demo ref=&quot;demo&quot;/&gt;......mounted()&#123;   this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test)&#125;\n\n若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n\n\n\n触发自定义事件：this.$emit(&#39;atguigu&#39;,数据)\t\t\n\n解绑自定义事件this.$off(&#39;atguigu&#39;)\n\n组件上也可以绑定原生DOM事件，需要使用native修饰符。\n\n注意：通过this.$refs.xxx.$on(&#39;atguigu&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n\n\n全局事件总线（GlobalEventBus）\n一种组件间通信的方式，适用于任意组件间通信。\n\n安装全局事件总线：\nnew Vue(&#123;\t......\tbeforeCreate() &#123;\t\tVue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\t&#125;,    ......&#125;) \n\n使用事件总线：\n\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。\nmethods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125;\n\n提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据)\n\n\n\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n\n\n消息订阅与发布（pubsub）\n一种组件间通信的方式，适用于任意组件间通信。\n\n使用步骤：\n\n安装pubsub：npm i pubsub-js\n\n引入: import pubsub from &#39;pubsub-js&#39;\n\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\nmethods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息&#125;\n\n提供数据：pubsub.publish(&#39;xxx&#39;,数据)\n\n最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。\n\n\n\n\nnextTick\n语法：this.$nextTick(回调函数)\n作用：在下一次 DOM 更新结束后执行其指定的回调。\n什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。\n\nVue封装的过度与动画\n作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n\n图示：\n\n写法：\n\n准备好样式：\n\n元素进入的样式：\nv-enter：进入的起点\nv-enter-active：进入过程中\nv-enter-to：进入的终点\n\n\n元素离开的样式：\nv-leave：离开的起点\nv-leave-active：离开过程中\nv-leave-to：离开的终点\n\n\n\n\n使用&lt;transition&gt;包裹要过度的元素，并配置name属性：\n&lt;transition name=&quot;hello&quot;&gt;\t&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt;\n\n备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定key值。\n\n\n\n\nvue脚手架配置代理方法一​\t在vue.config.js中添加如下配置：\ndevServer:&#123;  proxy:&quot;http://localhost:5000&quot;&#125;\n\n说明：\n\n优点：配置简单，请求资源时直接发给前端（8080）即可。\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）\n\n方法二​\t编写vue.config.js配置具体代理规则：\nmodule.exports = &#123;\tdevServer: &#123;      proxy: &#123;      &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径        target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125;      &#125;,      &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径        target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/\n\n说明：\n\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n缺点：配置略微繁琐，请求资源时必须加前缀。\n\n插槽\n作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 。\n\n分类：默认插槽、具名插槽、作用域插槽\n\n使用方式：\n\n默认插槽：\n父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n具名插槽：\n父组件中：        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\n\n作用域插槽：\n\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n\n具体编码：\n父组件中：\t\t&lt;Category&gt;\t\t\t&lt;template scope=&quot;scopeData&quot;&gt;\t\t\t\t&lt;!-- 生成的是ul列表 --&gt;\t\t\t\t&lt;ul&gt;\t\t\t\t\t&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;\t\t\t\t&lt;/ul&gt;\t\t\t&lt;/template&gt;\t\t&lt;/Category&gt;\t\t&lt;Category&gt;\t\t\t&lt;template slot-scope=&quot;scopeData&quot;&gt;\t\t\t\t&lt;!-- 生成的是h4标题 --&gt;\t\t\t\t&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;\t\t\t&lt;/template&gt;\t\t&lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;\t\t        &lt;script&gt;            export default &#123;                name:&#x27;Category&#x27;,                props:[&#x27;title&#x27;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;\n\n\n\n\n\nVuex1.概念​\t\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。\n2.何时使用？​\t\t多个组件需要共享数据时\n3.搭建vuex环境\n创建文件：src/store/index.js\n//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate&#125;)\n\n在main.js中创建vm时传入store配置项\n......//引入storeimport store from &#x27;./store&#x27;......//创建vmnew Vue(&#123;\tel:&#x27;#app&#x27;,\trender: h =&gt; h(App),\tstore&#125;)\n\n4.基本使用\n初始化数据、配置actions、配置mutations，操作文件store.js\n//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123;    //响应组件中加的动作\tjia(context,value)&#123;\t\t// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)\t\tcontext.commit(&#x27;JIA&#x27;,value)\t&#125;,&#125;const mutations = &#123;    //执行加\tJIA(state,value)&#123;\t\t// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)\t\tstate.sum += value\t&#125;&#125;//初始化数据const state = &#123;   sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\tactions,\tmutations,\tstate,&#125;)\n\n组件中读取vuex中的数据：$store.state.sum\n\n组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或 $store.commit(&#39;mutations中的方法名&#39;,数据)\n\n 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\n\n\n\n5.getters的使用\n概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n\n在store.js中追加getters配置\n......const getters = &#123;\tbigSum(state)&#123;\t\treturn state.sum * 10\t&#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;\t......\tgetters&#125;)\n\n组件中读取数据：$store.getters.bigSum\n\n\n6.四个map方法的使用\nmapState方法：用于帮助我们映射state中的数据为计算属性\ncomputed: &#123;    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;,\n\nmapGetters方法：用于帮助我们映射getters中的数据为计算属性\ncomputed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters([&#x27;bigSum&#x27;])&#125;,\n\nmapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\nmethods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125;\n\nmapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\nmethods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125;\n\n\n备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n\n7.模块化+命名空间\n目的：让代码更好维护，让多种数据分类更加明确。\n\n修改store.js\nconst countAbout = &#123;  namespaced:true,//开启命名空间  state:&#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123;       return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced:true,//开启命名空间  state:&#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)\n\n开启命名空间后，组件中读取state数据：\n//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),\n\n开启命名空间后，组件中读取getters数据：\n//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])\n\n开启命名空间后，组件中调用dispatch\n//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)\n\n开启命名空间后，组件中调用commit\n//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),\n\n路由\n理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件。\n\n1.基本使用\n安装vue-router，命令：npm i vue-router\n\n应用插件：Vue.use(VueRouter)\n\n编写router配置项:\n//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/about&#x27;,\t\t\tcomponent:About\t\t&#125;,\t\t&#123;\t\t\tpath:&#x27;/home&#x27;,\t\t\tcomponent:Home\t\t&#125;\t]&#125;)//暴露routerexport default router\n\n实现切换（active-class可配置高亮样式）\n&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n\n指定展示位置\n&lt;router-view&gt;&lt;/router-view&gt;\n\n2.几个注意点\n路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route属性，里面存储着自己的路由信息。\n整个应用只有一个router，可以通过组件的$router属性获取到。\n\n3.多级路由（多级路由）\n配置路由规则，使用children配置项：\nroutes:[\t&#123;\t\tpath:&#x27;/about&#x27;,\t\tcomponent:About,\t&#125;,\t&#123;\t\tpath:&#x27;/home&#x27;,\t\tcomponent:Home,\t\tchildren:[ //通过children配置子级路由\t\t\t&#123;\t\t\t\tpath:&#x27;news&#x27;, //此处一定不要写：/news\t\t\t\tcomponent:News\t\t\t&#125;,\t\t\t&#123;\t\t\t\tpath:&#x27;message&#x27;,//此处一定不要写：/message\t\t\t\tcomponent:Message\t\t\t&#125;\t\t]\t&#125;]\n\n跳转（要写完整路径）：\n&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n\n4.路由的query参数\n传递参数\n&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tpath:&#x27;/home/message/detail&#x27;,\t\tquery:&#123;\t\t   id:666,            title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n接收参数：\n$route.query.id$route.query.title\n\n5.命名路由\n作用：可以简化路由的跳转。\n\n如何使用\n\n给路由命名：\n&#123;\tpath:&#x27;/demo&#x27;,\tcomponent:Demo,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;test&#x27;,\t\t\tcomponent:Test,\t\t\tchildren:[\t\t\t\t&#123;                      name:&#x27;hello&#x27; //给路由命名\t\t\t\t\tpath:&#x27;welcome&#x27;,\t\t\t\t\tcomponent:Hello,\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n简化跳转：\n&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;hello&#x27;,\t\tquery:&#123;\t\t   id:666,            title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n\n\n6.路由的params参数\n配置路由，声明接收params参数\n&#123;\tpath:&#x27;/home&#x27;,\tcomponent:Home,\tchildren:[\t\t&#123;\t\t\tpath:&#x27;news&#x27;,\t\t\tcomponent:News\t\t&#125;,\t\t&#123;\t\t\tcomponent:Message,\t\t\tchildren:[\t\t\t\t&#123;\t\t\t\t\tname:&#x27;xiangqing&#x27;,\t\t\t\t\tpath:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数\t\t\t\t\tcomponent:Detail\t\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;\n\n传递参数\n&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;\t\t\t\t&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link \t:to=&quot;&#123;\t\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t   id:666,            title:&#x27;你好&#x27;\t\t&#125;\t&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n\n特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n\n\n接收参数：\n$route.params.id$route.params.title\n\n7.路由的props配置​\t作用：让路由组件更方便的收到参数\n&#123;\tname:&#x27;xiangqing&#x27;,\tpath:&#x27;detail/:id&#x27;,\tcomponent:Detail,\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\t// props:&#123;a:900&#125;\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\t// props:true\t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\tprops(route)&#123;\t\treturn &#123;\t\t\tid:route.query.id,\t\t\ttitle:route.query.title\t\t&#125;\t&#125;&#125;\n\n8.&lt;router-link&gt;的replace属性\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push\n如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt;\n\n9.编程式路由导航\n作用：不借助&lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活\n\n具体编码：\n//$router的两个APIthis.$router.push(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.replace(&#123;\tname:&#x27;xiangqing&#x27;,\t\tparams:&#123;\t\t\tid:xxx,\t\t\ttitle:xxx\t\t&#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退\n\n10.缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n具体编码：\n&lt;keep-alive include=&quot;News&quot;&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n11.两个新的生命周期钩子\n作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n具体名字：\nactivated路由组件被激活时触发。\ndeactivated路由组件失活时触发。\n\n\n\n12.路由守卫\n作用：对路由进行权限控制\n\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫:\n//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123;\tconsole.log(&#x27;beforeEach&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则\t\t\tnext() //放行\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext() //放行\t&#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123;\tconsole.log(&#x27;afterEach&#x27;,to,from)\tif(to.meta.title)&#123; \t\tdocument.title = to.meta.title //修改网页的title\t&#125;else&#123;\t\tdocument.title = &#x27;vue_test&#x27;\t&#125;&#125;)\n\n独享守卫:\nbeforeEnter(to,from,next)&#123;\tconsole.log(&#x27;beforeEnter&#x27;,to,from)\tif(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\t\tif(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123;\t\t\tnext()\t\t&#125;else&#123;\t\t\talert(&#x27;暂无权限查看&#x27;)\t\t\t// next(&#123;name:&#x27;guanyu&#x27;&#125;)\t\t&#125;\t&#125;else&#123;\t\tnext()\t&#125;&#125;\n\n组件内守卫：\n//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;\n\n13.路由器的两种工作模式\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\nhash模式：\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory模式：\n地址干净，美观 。\n兼容性和hash模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n\n\n\n","categories":["Learning","Vue2","Vue3"],"tags":["learning","GDIP","Vue2","Vue3"]},{"title":"Hello World","url":"/2023/02/19/hello-world.html/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"校易班技术部第一次授课","url":"/2023/03/02/%E6%8A%80%E6%9C%AF%E9%83%A8%E6%8E%88%E8%AF%BE.html/","content":"校易班技术部第一次授课html文档结构与基本语法html5基本结构如下\n&lt;html&gt;&lt;head&gt;    &lt;!--头部信息，如&lt;title&gt;标签定义的网页标题--&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--主体信息，包含网页显示的内容--&gt;&lt;/body&gt;&lt;/html&gt;\n头部页面标题及字符集的收集（1）title标签&lt;title&gt;个人网页&lt;/title&gt;\n双标签，开始和结束标签之间的内容就是要设置的页面标题\n\n注意：\n一个网页只能有一个标题\n标题名称的长度不超过64个字符数\n标题标记对之间不允许有其它的标签存在\n\n（2）charset属性通过meta标签的charset属性设置页面的字符编码格式。\n如：ISO-8859-1，utf-8：Unicode ，gb2312\n\n\n元信息的设置meta标签的作用\n\n对页面：\n\n&lt;meta http-equiv=&quot;名称&quot; content=&quot;值&quot;/&gt;\n\n对搜索引擎：\n\n&lt;meta name=&quot;名称&quot; content=&quot;值&quot;/&gt;\nlink标签&lt;link href=&quot;&quot; rel=&quot;&quot; type=&quot;&quot; /&gt;\n\nhref设置外部文档的地址\nrel设置当前文档与引用的外部文档的关系\ntype设置外部文档的类型。\n\n作用：\n\n指定引用外部文档的地址\n指定当前文档与引用的外部文档的关系\n说明引用外部文档的类型\n\n主体元素功能元素常见的有：&lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;video&gt;&lt;/video&gt; &lt;span&gt;&lt;/span&gt; &lt;img /&gt;\n结构元素\n内容元素\n修饰元素\n表单元素\n双标签以&lt;/xxx&gt;结束，单标签（如&lt;br/&gt;）需要以&lt;xxx/&gt;结束\n属性标签有其自己的属性，大部分元素拥有核心元素class id style，不同元素不同，可见-&gt;手册查看相关特性及用法\n核心属性\nclass：定义类名\nid：定义元素的唯一标识\nstyle：定义元素的样式\n\n内容属性\nalt：定义元素的替代文本\ntitle：定义元素的提示文本\n\n&lt;img src=&quot; &quot; alt=&quot;替代文字&quot; title=&quot;提示文本&quot;/&gt;\n链接属性\nhref：规定链接的目标\ntarget：定义被链接的文档在何处显示\nname：规定锚（anchor）的名称\n\n&lt;a href=&quot;https://blog.zepo.re/&quot; target=&quot;_blank&quot;&gt;Hello world!&lt;/a&gt;\n&lt;a href=&quot;#tips&quot;&gt;跳转指向name为tip的位置&lt;/a&gt;\n\n表单属性\nrequire：提交时要求要有内容\nplaceholder：对用户的输入进行提示\nmultiple：允许多文件上传\n···\n\n编辑器快捷键像HBuilder这种文本编辑器一般会内置有html模板，html + ENTER可以快速创建html文件\n\n设置宽高 w500+h300 + TAB\n\n标签名称 + TAB\n\n\n作业查看手册，完成简单作业\n\n对基本元素及其属性进行熟悉\n写一个三行两列的表格\n尝试detail+summary的方式做一个缩略文本\n将练习整合到一个页面打包发送到linzepore@qq.com\n\n下次课：css基础（会相对复杂），可先行预习\n","categories":["Teaching","HTML","前端","GDIP"],"tags":["GDIP","teach"]},{"title":"网课文档 | uni-app的基本使用","url":"/2023/04/05/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html/","content":"uni-app的基本使用课程介绍：\n基础部分：\n\n环境搭建\n页面外观配置\n数据绑定\nuni-app的生命周期\n组件的使用\nuni-app中样式学习\n在uni-app中使用字体图标和开启scss\n条件注释跨端兼容\nuni中的事件\n导航跳转\n组件创建和通讯，及组件的生命周期\nuni-app中使用uni-ui库\n\n项目：黑马商城项目\nuni-app介绍 官方网页uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;头条&#x2F;QQ&#x2F;钉钉）等多个平台。\n即使不跨端，uni-app同时也是更好的小程序开发框架。\n具有vue和微信小程序的开发经验，可快速上手uni-app\n为什么要去学习uni-app？\n相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。\n环境搭建安装编辑器HbuilderX  下载地址\nHBuilderX是通用的前端开发工具，但为uni-app做了特别强化。\n下载App开发版，可开箱即用\n安装微信开发者工具 下载地址\n利用HbuilderX初始化项目\n点击HbuilderX菜单栏文件&gt;项目&gt;新建\n\n选择uni-app,填写项目名称，项目创建的目录\n\n\n\n运行项目在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行\n在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app\n在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到手机或模拟器 -&gt; 选择调式的手机\n注意：\n\n如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功\n微信开发者工具在设置中安全设置，服务端口开启\n\n介绍项目目录和文件作用pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等\nmanifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。\nApp.vue是我们的跟组件，所有页面都是在App.vue下进行切换的，是页面入口文件，可以调用应用的生命周期函数。\nmain.js是我们的项目入口文件，主要作用是初始化vue实例并使用需要的插件。\nuni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。\n就是打包目录，在这里有各个平台的打包文件```pages``` 所有的页面存放目录```static``` 静态资源目录，例如图片等```components``` 组件存放目录为了实现多端兼容，综合考虑编译速度、运行性能等因素，`uni-app` 约定了如下开发规范：- 页面文件遵循 [Vue 单文件组件 (SFC) 规范](https://vue-loader.vuejs.org/zh/spec.html)- 组件标签靠近小程序规范，详见[uni-app 组件规范](https://uniapp.dcloud.io/component/README)- 接口能力（JS API）靠近微信小程序规范，但需将前缀 `wx` 替换为 `uni`，详见[uni-app接口规范](https://uniapp.dcloud.io/api/README)- 数据绑定及事件处理同 `Vue.js` 规范，同时补充了App及页面的生命周期- 为兼容多端运行，建议使用flex布局进行开发#### 全局配置和页面配置##### 通过globalStyle进行全局配置用于设置应用的状态栏、导航条、标题、窗口背景色等。[详细文档](https://uniapp.dcloud.io/collocation/pages?id=globalstyle)| 属性                           | 类型       | 默认值     | 描述                                       || ---------------------------- | -------- | ------- | ---------------------------------------- || navigationBarBackgroundColor | HexColor | #F7F7F7 | 导航栏背景颜色（同状态栏背景色）                         || navigationBarTextStyle       | String   | white   | 导航栏标题颜色及状态栏前景颜色，仅支持 black/white          || navigationBarTitleText       | String   |         | 导航栏标题文字内容                                || backgroundColor              | HexColor | #ffffff | 窗口的背景色                                   || backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 dark / light          || enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f)。 || onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f) |##### 创建新的message页面右键pages新建message目录，在message目录下右键新建.vue文件,并选择基本模板```html&lt;template&gt;\t&lt;view&gt;\t\t这是信息页面\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n通过pages来配置页面\n\n\n属性\n类型\n默认值\n描述\n\n\n\npath\nString\n\n配置页面路径\n\n\nstyle\nObject\n\n配置页面窗口表现，配置项参考 pageStyle\n\n\npages数组数组中第一项表示应用启动页\n&quot;pages&quot;: [ \t\t&#123;\t\t\t&quot;path&quot;:&quot;pages/message/message&quot;\t\t&#125;,\t\t&#123;\t\t\t&quot;path&quot;: &quot;pages/index/index&quot;,\t\t\t&quot;style&quot;: &#123;\t\t\t\t&quot;navigationBarTitleText&quot;: &quot;uni-app&quot;\t\t\t&#125;\t\t&#125;\t]\n\n通过style修改页面的标题和导航栏背景色，并且设置h5下拉刷新的特有样式\n&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\t\t&#123;\t\t\t&quot;path&quot;:&quot;pages/message/message&quot;,\t\t\t&quot;style&quot;: &#123;\t\t\t\t&quot;navigationBarBackgroundColor&quot;: &quot;#007AFF&quot;,\t\t\t\t&quot;navigationBarTextStyle&quot;: &quot;white&quot;,\t\t\t\t&quot;enablePullDownRefresh&quot;: true,\t\t\t\t&quot;disableScroll&quot;: true,\t\t\t\t&quot;h5&quot;: &#123;\t\t\t\t\t&quot;pullToRefresh&quot;: &#123;\t\t\t\t\t\t&quot;color&quot;: &quot;#007AFF&quot;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t]\n配置tabbar如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。\nTips\n\n当设置 position 为 top 时，将不会显示 icon\ntabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。\n\n属性说明：\n\n\n\n属性\n类型\n必填\n默认值\n描述\n平台差异说明\n\n\n\ncolor\nHexColor\n是\n\ntab 上的文字默认颜色\n\n\n\nselectedColor\nHexColor\n是\n\ntab 上的文字选中时的颜色\n\n\n\nbackgroundColor\nHexColor\n是\n\ntab 的背景色\n\n\n\nborderStyle\nString\n否\nblack\ntabbar 上边框的颜色，仅支持 black&#x2F;white\nApp 2.3.4+ 支持其他颜色值\n\n\nlist\nArray\n是\n\ntab 的列表，详见 list 属性说明，最少2个、最多5个 tab\n\n\n\nposition\nString\n否\nbottom\n可选值 bottom、top\ntop 值仅微信小程序支持\n\n\n其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：\n\n\n\n属性\n类型\n必填\n说明\n\n\n\npagePath\nString\n是\n页面路径，必须在 pages 中先定义\n\n\ntext\nString\n是\ntab 上按钮文字，在 5+APP 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标\n\n\niconPath\nString\n否\n图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标\n\n\nselectedIconPath\nString\n否\n选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效\n\n\n案例代码：\n&quot;tabBar&quot;: &#123;\t\t&quot;list&quot;: [\t\t\t&#123;\t\t\t\t&quot;text&quot;: &quot;首页&quot;,\t\t\t\t&quot;pagePath&quot;:&quot;pages/index/index&quot;,\t\t\t\t&quot;iconPath&quot;:&quot;static/tabs/home.png&quot;,\t\t\t\t&quot;selectedIconPath&quot;:&quot;static/tabs/home-active.png&quot;\t\t\t&#125;,\t\t\t&#123;\t\t\t\t&quot;text&quot;: &quot;信息&quot;,\t\t\t\t&quot;pagePath&quot;:&quot;pages/message/message&quot;,\t\t\t\t&quot;iconPath&quot;:&quot;static/tabs/message.png&quot;,\t\t\t\t&quot;selectedIconPath&quot;:&quot;static/tabs/message-active.png&quot;\t\t\t&#125;,\t\t\t&#123;\t\t\t\t&quot;text&quot;: &quot;我们&quot;,\t\t\t\t&quot;pagePath&quot;:&quot;pages/contact/contact&quot;,\t\t\t\t&quot;iconPath&quot;:&quot;static/tabs/contact.png&quot;,\t\t\t\t&quot;selectedIconPath&quot;:&quot;static/tabs/contact-active.png&quot;\t\t\t&#125;\t\t]\t&#125;\n\ncondition启动模式配置启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。\n属性说明：\n\n\n\n属性\n类型\n是否必填\n描述\n\n\n\ncurrent\nNumber\n是\n当前激活的模式，list节点的索引值\n\n\nlist\nArray\n是\n启动模式列表\n\n\nlist说明：\n\n\n\n属性\n类型\n是否必填\n描述\n\n\n\nname\nString\n是\n启动模式名称\n\n\npath\nString\n是\n启动页面路径\n\n\nquery\nString\n否\n启动参数，可在页面的 onLoad 函数里获得\n\n\n组件的基本使用uni-app提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼接称自己的应用\nuni-app中的组件，就像 HTML 中的 div 、p、span 等标签的作用一样，用于搭建页面的基础结构\ntext文本组件的用法001 - text 组件的属性\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\nselectable\nboolean\nfalse\n否\n文本是否可选\n\n\nspace\nstring\n.\n否\n显示连续空格，可选参数：ensp、emsp、nbsp\n\n\ndecode\nboolean\nfalse\n否\n是否解码\n\n\n\ntext 组件相当于行内标签、在同一行显示\n除了文本节点以外的其他节点都无法长按选中\n\n002 - 代码案例&lt;view&gt;  &lt;!-- 长按文本是否可选 --&gt;  &lt;text selectable=&#x27;true&#x27;&gt;来了老弟&lt;/text&gt;&lt;/view&gt;&lt;view&gt;  &lt;!-- 显示连续空格的方式 --&gt;  &lt;view&gt;    &lt;text space=&#x27;ensp&#x27;&gt;来了  老弟&lt;/text&gt;  &lt;/view&gt;  &lt;view&gt;    &lt;text space=&#x27;emsp&#x27;&gt;来了  老弟&lt;/text&gt;  &lt;/view&gt;  &lt;view&gt;    &lt;text space=&#x27;nbsp&#x27;&gt;来了  老弟&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;&lt;view&gt;  &lt;text&gt;skyblue&lt;/text&gt;&lt;/view&gt;&lt;view&gt;  &lt;!-- 是否解码 --&gt;  &lt;text decode=&#x27;true&#x27;&gt;&amp;nbsp; &amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;ensp; &amp;emsp;&lt;/text&gt;&lt;/view&gt;\n\nview视图容器组件的用法\nView 视图容器， 类似于 HTML 中的 div\n\n001 - 组件的属性\n002 - 代码案例&lt;view class=&quot;box2&quot; hover-class=&quot;box2_active&quot;&gt;  &lt;view class=&#x27;box1&#x27; hover-class=&#x27;active&#x27; hover-stop-propagation :hover-start-time=&quot;2000&quot; :hover-stay-time=&#x27;2000&#x27;&gt;  &lt;/view&gt;&lt;/view&gt;\n\nbutton按钮组件的用法001 - 组件的属性\n\n\n属性名\n类型\n默认值\n说明\n\n\n\nsize\nString\ndefault\n按钮的大小\n\n\ntype\nString\ndefault\n按钮的样式类型\n\n\nplain\nBoolean\nfalse\n按钮是否镂空，背景色透明\n\n\ndisabled\nBoolean\nfalse\n是否按钮\n\n\nloading\nBoolean\nfalse\n名称是否带 loading t图标\n\n\n\nbutton 组件默认独占一行，设置 size 为 mini 时可以在一行显示多个\n\n002 - 案例代码&lt;button size=&#x27;mini&#x27; type=&#x27;primary&#x27;&gt;前端&lt;/button&gt;&lt;button size=&#x27;mini&#x27; type=&#x27;default&#x27; disabled=&#x27;true&#x27;&gt;前端&lt;/button&gt;&lt;button size=&#x27;mini&#x27; type=&#x27;warn&#x27; loading=&#x27;true&#x27;&gt;前端&lt;/button&gt;\n\nimage组件的使用image图片。\n\n\n\n属性名\n类型\n默认值\n说明\n平台差异说明\n\n\n\nsrc\nString\n\n图片资源地址\n\n\n\nmode\nString\n‘scaleToFill’\n图片裁剪、缩放的模式\n\n\n\nTips\n\n&lt;image&gt; 组件默认宽度 300px、高度 225px；\nsrc 仅支持相对路径、绝对路径，支持 base64 码；\n页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 image&#123;will-change: transform&#125; ,可优化此问题。\n\nuni-app中的样式\nrpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。\n\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束\n\n支持基本常用的选择器class、id、element等\n\n在 uni-app 中不能使用 * 选择器。\n\npage 相当于 body 节点\n\n定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。\n\nuni-app 支持使用字体图标，使用方式与普通 web 项目相同，需要注意以下几点：\n\n字体文件小于 40kb，uni-app 会自动将其转化为 base64 格式；\n\n字体文件大于等于 40kb， 需开发者自己转换，否则使用将不生效；\n\n字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。\n@font-face &#123;    font-family: test1-icon;    src: url(&#x27;~@/static/iconfont.ttf&#x27;);&#125;\n\n\n如何使用scss或者less\n\n\nuni-app中的数据绑定在页面中需要定义数据，和我们之前的vue一摸一样，直接在data中定义数据即可\nexport default &#123;  data () &#123;    return &#123;      msg: &#x27;hello-uni&#x27;    &#125;  &#125;&#125;\n\n插值表达式的使用\n利用插值表达式渲染基本数据\n&lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;\n\n在插值表达式中使用三元运算\n&lt;view&gt;&#123;&#123; flag ? &#x27;我是真的&#x27;:&#x27;我是假的&#x27; &#125;&#125;&lt;/view&gt;\n\n基本运算\n&lt;view&gt;&#123;&#123;1+1&#125;&#125;&lt;/view&gt;\n\nv-bind动态绑定属性在data中定义了一张图片，我们希望把这张图片渲染到页面上\nexport default &#123;  data () &#123;    return &#123;      img: &#x27;http://destiny001.gitee.io/image/monkey_02.jpg&#x27;    &#125;  &#125;&#125;\n\n利用v-bind进行渲染\n&lt;image v-bind:src=&quot;img&quot;&gt;&lt;/image&gt;\n\n还可以缩写成:\n&lt;image :src=&quot;img&quot;&gt;&lt;/image&gt;\n\nv-for的使用data中定以一个数组，最终将数组渲染到页面上\ndata () &#123;  return &#123;    arr: [      &#123; name: &#x27;刘能&#x27;, age: 29 &#125;,      &#123; name: &#x27;赵四&#x27;, age: 39 &#125;,      &#123; name: &#x27;宋小宝&#x27;, age: 49 &#125;,      &#123; name: &#x27;小沈阳&#x27;, age: 59 &#125;    ]  &#125;&#125;\n\n利用v-for进行循环\n&lt;view v-for=&quot;(item,i) in arr&quot; :key=&quot;i&quot;&gt;名字：&#123;&#123;item.name&#125;&#125;---年龄：&#123;&#123;item.age&#125;&#125;&lt;/view&gt;\n\nuni中的事件事件绑定在uni中事件绑定和vue中是一样的，通过v-on进行事件的绑定，也可以简写为@\n&lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt;\n\n事件函数定义在methods中\nmethods: &#123;  tapHandle () &#123;    console.log(&#x27;真的点我了&#x27;)  &#125;&#125;\n\n事件传参\n默认如果没有传递参数，事件函数第一个形参为事件对象\n// template&lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123;  tapHandle (e) &#123;    console.log(e)  &#125;&#125;\n\n如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据\n// template&lt;button @click=&quot;tapHandle(1)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123;  tapHandle (num) &#123;    console.log(num)  &#125;&#125;\n\n如果获取事件对象也想传递参数\n// template&lt;button @click=&quot;tapHandle(1,$event)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: &#123;  tapHandle (num,e) &#123;    console.log(num,e)  &#125;&#125;\n\nuni的生命周期应用的生命周期生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。\n生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数\nuni-app 支持如下应用生命周期函数：\n\n\n\n函数名\n说明\n\n\n\nonLaunch\n当uni-app 初始化完成时触发（全局只触发一次）\n\n\nonShow\n当 uni-app 启动，或从后台进入前台显示\n\n\nonHide\n当 uni-app 从前台进入后台\n\n\nonError\n当 uni-app 报错时触发\n\n\n页面的生命周期uni-app 支持如下页面生命周期函数：\n\n\n\n函数名\n说明\n平台差异说明\n最低版本\n\n\n\nonLoad\n监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考示例\n\n\n\n\nonShow\n监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面\n\n\n\n\nonReady\n监听页面初次渲染完成。\n\n\n\n\nonHide\n监听页面隐藏\n\n\n\n\nonUnload\n监听页面卸载\n\n\n\n\n下拉刷新开启下拉刷新在uni-app中有两种方式开启下拉刷新\n\n需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh\n通过调用uni.startPullDownRefresh方法来开启下拉刷新\n\n通过配置文件开启创建list页面进行演示\n&lt;template&gt;\t&lt;view&gt;\t\t杭州学科\t\t&lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;\t\t\t&#123;&#123;item&#125;&#125;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tarr: [&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;]\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n通过pages.json文件中找到当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh\n&#123;  &quot;path&quot;:&quot;pages/list/list&quot;,    &quot;style&quot;:&#123;      &quot;enablePullDownRefresh&quot;: true    &#125;&#125;\n\n通过API开启api文档\nuni.startPullDownRefresh()\n\n监听下拉刷新通过onPullDownRefresh可以监听到下拉刷新的动作\nexport default &#123;  data () &#123;    return &#123;      arr: [&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;]    &#125;  &#125;,  methods: &#123;    startPull () &#123;      uni.startPullDownRefresh()    &#125;  &#125;,  onPullDownRefresh () &#123;    console.log(&#x27;触发下拉刷新了&#x27;)  &#125;&#125;\n\n关闭下拉刷新uni.stopPullDownRefresh()\n停止当前页面下拉刷新。\n案例演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;startPull&quot;&gt;开启下拉刷新&lt;/button&gt;\t\t杭州学科\t\t&lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;\t\t\t&#123;&#123;item&#125;&#125;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tarr: [&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;]\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tstartPull () &#123;\t\t\t\tuni.startPullDownRefresh()\t\t\t&#125;\t\t&#125;,\t\t\t\tonPullDownRefresh () &#123;\t\t\tthis.arr = []\t\t\tsetTimeout(()=&gt; &#123;\t\t\t\tthis.arr = [&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;]\t\t\t\tuni.stopPullDownRefresh()\t\t\t&#125;, 1000);\t\t&#125;\t&#125;&lt;/script&gt;\n\n上拉加载通过在pages.json文件中找到当前页面的pages节点下style中配置onReachBottomDistance可以设置距离底部开启加载的距离，默认为50px\n通过onReachBottom监听到触底的行为\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;startPull&quot;&gt;开启下拉刷新&lt;/button&gt;\t\t杭州学科\t\t&lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;\t\t\t&#123;&#123;item&#125;&#125;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tarr: [&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;,&#x27;前端&#x27;,&#x27;java&#x27;,&#x27;ui&#x27;,&#x27;大数据&#x27;]\t\t\t&#125;\t\t&#125;,\t\tonReachBottom () &#123;\t\t\tconsole.log(&#x27;触底了&#x27;)\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;\tview&#123;\t\theight: 100px;\t\tline-height: 100px;\t&#125;&lt;/style&gt;\n\n网络请求在uni中可以调用uni.request方法进行请求网络请求\n需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。\n发送get请求\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button @click=&quot;sendGet&quot;&gt;发送请求&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tsendGet () &#123;\t\t\t\tuni.request(&#123;\t\t\t\t\turl: &#x27;http://localhost:8082/api/getlunbo&#x27;,\t\t\t\t\tsuccess(res) &#123;\t\t\t\t\t\tconsole.log(res)\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n发送post请求\n数据缓存uni.setStorage官方文档\n将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;setStor&quot;&gt;存储数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tsetStor () &#123;\t\t\t\tuni.setStorage(&#123;\t\t\t\t \tkey: &#x27;id&#x27;,\t\t\t\t \tdata: 100,\t\t\t\t \tsuccess () &#123;\t\t\t\t \t\tconsole.log(&#x27;存储成功&#x27;)\t\t\t\t \t&#125;\t\t\t\t &#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\nuni.setStorageSync将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;setStor&quot;&gt;存储数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tsetStor () &#123;\t\t\t\tuni.setStorageSync(&#x27;id&#x27;,100)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\nuni.getStorage从本地缓存中异步获取指定 key 对应的内容。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;getStorage&quot;&gt;获取数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tid: &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tgetStorage () &#123;\t\t\t\tuni.getStorage(&#123;\t\t\t\t\tkey: &#x27;id&#x27;,\t\t\t\t\tsuccess:  res=&gt;&#123;\t\t\t\t\t\tthis.id = res.data\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\nuni.getStorageSync从本地缓存中同步获取指定 key 对应的内容。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;getStorage&quot;&gt;获取数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tgetStorage () &#123;\t\t\t\tconst id = uni.getStorageSync(&#x27;id&#x27;)\t\t\t\tconsole.log(id)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\nuni.removeStorage从本地缓存中异步移除指定 key。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;removeStorage&quot;&gt;删除数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tremoveStorage () &#123;\t\t\t\tuni.removeStorage(&#123;\t\t\t\t\tkey: &#x27;id&#x27;,\t\t\t\t\tsuccess: function () &#123;\t\t\t\t\t\tconsole.log(&#x27;删除成功&#x27;)\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\nuni.removeStorageSync从本地缓存中同步移除指定 key。\n代码演示\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button type=&quot;primary&quot; @click=&quot;removeStorage&quot;&gt;删除数据&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tmethods: &#123;\t\t\tremoveStorage () &#123;\t\t\t\tuni.removeStorageSync(&#x27;id&#x27;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n上传图片、预览图片上传图片uni.chooseImage方法从本地相册选择图片或使用相机拍照。\n案例代码\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;button @click=&quot;chooseImg&quot; type=&quot;primary&quot;&gt;上传图片&lt;/button&gt;\t\t&lt;view&gt;\t\t\t&lt;image v-for=&quot;item in imgArr&quot; :src=&quot;item&quot; :key=&quot;index&quot;&gt;&lt;/image&gt;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\timgArr: []\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tchooseImg () &#123;\t\t\t\tuni.chooseImage(&#123;\t\t\t\t\tcount: 9,\t\t\t\t\tsuccess: res=&gt;&#123;\t\t\t\t\t\tthis.imgArr = res.tempFilePaths\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n预览图片结构\n&lt;view&gt;\t&lt;image v-for=&quot;item in imgArr&quot; :src=&quot;item&quot; @click=&quot;previewImg(item)&quot; :key=&quot;item&quot;&gt;&lt;/image&gt;&lt;/view&gt;\n\n预览图片的方法\npreviewImg (current) &#123;  uni.previewImage(&#123;    urls: this.imgArr,    current  &#125;)&#125;\n\n条件注释实现跨段兼容条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。\n写法：以 #ifdef 加平台标识 开头，以 #endif 结尾。\n平台标识\n\n\n\n值\n平台\n参考文档\n\n\n\nAPP-PLUS\n5+App\nHTML5+ 规范\n\n\nH5\nH5\n\n\n\nMP-WEIXIN\n微信小程序\n微信小程序\n\n\nMP-ALIPAY\n支付宝小程序\n支付宝小程序\n\n\nMP-BAIDU\n百度小程序\n百度小程序\n\n\nMP-TOUTIAO\n头条小程序\n头条小程序\n\n\nMP-QQ\nQQ小程序\n（目前仅cli版支持）\n\n\nMP\n微信小程序&#x2F;支付宝小程序&#x2F;百度小程序&#x2F;头条小程序&#x2F;QQ小程序\n\n\n\n组件的条件注释代码演示\n&lt;!-- #ifdef H5 --&gt;&lt;view&gt;  h5页面会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef MP-WEIXIN --&gt;&lt;view&gt;  微信小程序会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef APP-PLUS --&gt;&lt;view&gt;  app会显示&lt;/view&gt;&lt;!-- #endif --&gt;\n\napi的条件注释代码演示\nonLoad () &#123;  //#ifdef MP-WEIXIN  console.log(&#x27;微信小程序&#x27;)  //#endif  //#ifdef H5  console.log(&#x27;h5页面&#x27;)  //#endif&#125;\n\n样式的条件注释\n代码演示\n/* #ifdef H5 */view&#123;  height: 100px;  line-height: 100px;  background: red;&#125;/* #endif *//* #ifdef MP-WEIXIN */view&#123;  height: 100px;  line-height: 100px;  background: green;&#125;/* #endif */\n\nuni中的导航跳转利用navigator进行跳转navigator详细文档：文档地址\n跳转到普通页面\n&lt;navigator url=&quot;/pages/about/about&quot; hover-class=&quot;navigator-hover&quot;&gt;  &lt;button type=&quot;default&quot;&gt;跳转到关于页面&lt;/button&gt;&lt;/navigator&gt;\n\n跳转到tabbar页面\n&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;  &lt;button type=&quot;default&quot;&gt;跳转到message页面&lt;/button&gt;&lt;/navigator&gt;\n\n利用编程式导航进行跳转导航跳转文档\n利用navigateTo进行导航跳转\n保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。\n&lt;button type=&quot;primary&quot; @click=&quot;goAbout&quot;&gt;跳转到关于页面&lt;/button&gt;\n\n通过navigateTo方法进行跳转到普通页面\ngoAbout () &#123;  uni.navigateTo(&#123;    url: &#x27;/pages/about/about&#x27;,  &#125;)&#125;\n\n通过switchTab跳转到tabbar页面\n跳转到tabbar页面\n&lt;button type=&quot;primary&quot; @click=&quot;goMessage&quot;&gt;跳转到message页面&lt;/button&gt;\n\n通过switchTab方法进行跳转\ngoMessage () &#123;  uni.switchTab(&#123;    url: &#x27;/pages/message/message&#x27;  &#125;)&#125;\n\nredirectTo进行跳转 \n关闭当前页面，跳转到应用内的某个页面。\n&lt;!-- template --&gt;&lt;button type=&quot;primary&quot; @click=&quot;goMessage&quot;&gt;跳转到message页面&lt;/button&gt;&lt;!-- js --&gt;goMessage () &#123;  uni.switchTab(&#123;    url: &#x27;/pages/message/message&#x27;  &#125;)&#125;\n\n通过onUnload测试当前组件确实卸载\nonUnload () &#123;  console.log(&#x27;组件卸载了&#x27;)&#125;\n\n导航跳转传递参数在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收\n传递参数的页面\ngoAbout () &#123;  uni.navigateTo(&#123;    url: &#x27;/pages/about/about?id=80&#x27;,  &#125;);&#125;\n\n接收参数的页面\n&lt;script&gt;\texport default &#123;\t\tonLoad (options) &#123;\t\t\tconsole.log(options)\t\t&#125;\t&#125;&lt;/script&gt;\n\nuni-app中组件的创建在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过impot的方式导入，在通过components进行注册即可\n\n创建login组件，在component中创建login目录，然后新建login.vue文件\n&lt;template&gt;\t&lt;view&gt;\t\t这是一个自定义组件\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n在其他组件中导入该组件并注册\nimport login from &quot;@/components/test/test.vue&quot;\n\n注册组件\ncomponents: &#123;test&#125;\n\n使用组件\n&lt;test&gt;&lt;/test&gt;\n\n组件的生命周期函数\n\n\nbeforeCreate\n在实例初始化之后被调用。详见\n\n\n\n\n\ncreated\n在实例创建完成后被立即调用。详见\n\n\n\n\nbeforeMount\n在挂载开始之前被调用。详见\n\n\n\n\nmounted\n挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档\n\n\n\n\nbeforeUpdate\n数据更新时调用，发生在虚拟 DOM 打补丁之前。详见\n仅H5平台支持\n\n\n\nupdated\n由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。详见\n仅H5平台支持\n\n\n\nbeforeDestroy\n实例销毁之前调用。在这一步，实例仍然完全可用。详见\n\n\n\n\ndestroyed\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。详见\n\n\n\n\n组件的通讯父组件给子组件传值通过props来接受外界传递到组件内部的值\n&lt;template&gt;\t&lt;view&gt;\t\t这是一个自定义组件 &#123;&#123;msg&#125;&#125;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tprops: [&#x27;msg&#x27;]\t&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n其他组件在使用login组件的时候传递值\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;test :msg=&quot;msg&quot;&gt;&lt;/test&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport test from &quot;@/components/test/test.vue&quot;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tmsg: &#x27;hello&#x27;\t\t\t&#125;\t\t&#125;,\t\t\t\tcomponents: &#123;test&#125;\t&#125;&lt;/script&gt;\n\n子组件给父组件传值通过$emit触发事件进行传递参数\n&lt;template&gt;\t&lt;view&gt;\t\t这是一个自定义组件 &#123;&#123;msg&#125;&#125;\t\t&lt;button type=&quot;primary&quot; @click=&quot;sendMsg&quot;&gt;给父组件传值&lt;/button&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tstatus: &#x27;打篮球&#x27;\t\t\t&#125;\t\t&#125;,\t\tprops: &#123;\t\t\tmsg: &#123;\t\t\t\ttype: String,\t\t\t\tvalue: &#x27;&#x27;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tsendMsg () &#123;\t\t\t\tthis.$emit(&#x27;myEvent&#x27;,this.status)\t\t\t&#125;\t\t&#125;\t&#125;&lt;/script&gt;\n\n父组件定义自定义事件并接收参数\n&lt;template&gt;\t&lt;view&gt;\t\t&lt;test :msg=&quot;msg&quot; @myEvent=&quot;getMsg&quot;&gt;&lt;/test&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport test from &quot;@/components/test/test.vue&quot;\texport default &#123;\t\tdata () &#123;\t\t\treturn &#123;\t\t\t\tmsg: &#x27;hello&#x27;\t\t\t&#125;\t\t&#125;,\t\tmethods: &#123;\t\t\tgetMsg (res) &#123;\t\t\t\tconsole.log(res)\t\t\t&#125;\t\t&#125;,\t\t\t\tcomponents: &#123;test&#125;\t&#125;&lt;/script&gt;\n\n兄弟组件通讯uni-ui的使用uni-ui文档\n1、进入Grid宫格组件\n2、使用HBuilderX导入该组件\n3、导入该组件\nimport uniGrid from &quot;@/components/uni-grid/uni-grid.vue&quot;import uniGridItem from &quot;@/components/uni-grid-item/uni-grid-item.vue&quot;\n\n4、注册组件\ncomponents: &#123;uniGrid,uniGridItem&#125;\n\n5、使用组件\n&lt;uni-grid :column=&quot;3&quot;&gt;  &lt;uni-grid-item&gt;    &lt;text class=&quot;text&quot;&gt;文本&lt;/text&gt;  &lt;/uni-grid-item&gt;  &lt;uni-grid-item&gt;    &lt;text class=&quot;text&quot;&gt;文本&lt;/text&gt;  &lt;/uni-grid-item&gt;  &lt;uni-grid-item&gt;    &lt;text class=&quot;text&quot;&gt;文本&lt;/text&gt;  &lt;/uni-grid-item&gt;&lt;/uni-grid&gt;\n\n","categories":["Learning","uni-app"],"tags":["learning","GDIP","uni-app"]},{"title":"VMware虚拟机安装银河麒麟系统简易教程","url":"/2023/03/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E7%B3%BB%E7%BB%9F.html/","content":"虚拟机安装银河麒麟系统安装VMware来源：[Windows] VMware Workstation Pro 15.5.0 中文版 \n各版本序列号\n\n10.x：1Z0G9-67285-FZG78-ZL3Q2-234JG\n11.x：YG74R-86G1M-M8DLP-XEQNT-XAHW2\n12.x：ZC3TK-63GE6-481JY-WWW5T-Z7ATA\n14.x：AU108-FLF9P-H8EJZ-7XMQ9-XG0U8\n15.x：FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6\n\n下载地址\n\n10.0.7：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe\n12.5.9：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe\n14.1.5：http://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.5-10950780.exe\n15.5.0：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe\n\n安装银河麒麟镜像的步骤如下：下载银河麒麟镜像文件镜像文件通常是一个 ISO 文件\n下载群里百度网盘链接中飞腾天固开发板资料/ISO/银河麒麟/XXX.iso文件（由于群里链接是飞腾版本可能不太兼容，所以补充相关镜像）\n镜像来源：试用版下载链接申请、试用版下载链接\n银河麒麟高级服务器操作系统V10兆芯版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/BdfgsWOJhuyRY2vxw30q9NIj7HFcVG6X提取码：NA\n海光版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/BdfgsWOJhuyRY2vxw30q9NIj7HFcVG6X提取码：NA\n飞腾版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/5VA1WXIp3HsaM28c7lOTSGwqxyRQg4b9提取码：NA\n鲲鹏版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/5VA1WXIp3HsaM28c7lOTSGwqxyRQg4b9提取码：NA\n龙芯-MIPS64el\n下载地址： http://distro-images.kylinos.cn:8802/web_pungi/download/share/aru2QCiVKcZYlHpfnqX4AzLJBxNGsUvt提取码：NA\n兼容版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/HCrXv9VIWec4hwopd62Oukz7UsZBtL03提取码：NA\nAMD64\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/5VA1WXIp3HsaM28c7lOTSGwqxyRQg4b9提取码：NA\n银河麒麟桌面操作系统V10兆芯版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/9nl7ve2CSfEaQyqXYt8bRWUFdTBgj5hJ提取码：NA\n海光版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/9nl7ve2CSfEaQyqXYt8bRWUFdTBgj5hJ提取码：NA\n飞腾版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/tXbGgIYCdQEv5z0lPypmKTqAse2rojJx提取码：NA\n鲲鹏版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/tXbGgIYCdQEv5z0lPypmKTqAse2rojJx提取码：NA\n龙芯3a4000版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/EKvckinmNw1p9HXAsxLhB5Mf3eDUJ0VW提取码：NA\n龙芯3a5000版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/wrmC6ciOgptjAn5eMy1uhxfN8B7q9XRK提取码：NA\nAMD64版(*)\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/HXDYtGjZm3daA4UvOTLkiPl1nB9ErM0c提取码：NA\nintel版(*)\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/HXDYtGjZm3daA4UvOTLkiPl1nB9ErM0c提取码：NA\n海思麒麟990版\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/oI85Vq7lgY1UHNPTrs4Ea2dAhcBZ0WMG提取码：NA\n银河麒麟高级服务器操作系统（Host版）V10X86_64\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/NIwinvA70azCSRHGQocr4eqx8FhX2d1V提取码：NA\nARM64\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/7dCLXwuncSaTWezRyth4Gfv2bl9EqQMx提取码：NA\n\n中标麒麟高级服务器操作系统软件 V7.0X86_64\n下载地址：http://distro-images.kylinos.cn:8802/web_pungi/download/share/Mh9mgvwj3zSKpJ6WPZtTarGfbFkCOu2i提取码：NA\n\n开源系统openKylinopenKylin 开源操作系统\n“新建虚拟机”打开 VMware 虚拟机软件，点击 “新建虚拟机”。\n选择 “典型 (推荐)”选择 “典型 (推荐)”，点击 “下一步”。\n选择 “安装操作系统”选择 “安装操作系统”，点击 “下一步”。\n选择银河麒麟镜像在 “安装媒介” 中选择 “使用 ISO 映像文件”，点击 “浏览” 并选择之前下载的银河麒麟镜像文件。\n选择Linux - Ubuntu 64 位在 “操作系统” 中选择 “Linux”，在 “版本” 中选择 “Ubuntu”，因为银河麒麟基于 Ubuntu，则选择 “Ubuntu 64 位”。\n命名虚拟机给虚拟机起一个名字并选择一个存放位置，点击 “下一步”。\n设置内存容量设置虚拟机的存储容量大小，勾选“将虚拟磁盘拆分成多个文件”，点击 “下一步”。安装银河麒麟的话最好要给足50G存储!!\n选择“NAT“网络适配器选项\n\n完成创建点击 “完成” 创建虚拟机，银河麒麟镜像将被安装在虚拟机上。\n系统设置安装完成之后需要设置用户名及密码，参考官方视频-&gt;粉丝们期待的银河麒麟操作系统2203版本安装教程来啦！！！\n安装问题启动后黑屏安装openKylin进入之后，选择安装系统然后黑屏只剩下指针可移动\n\n增加内核数量\n\n问题解决\n\n","categories":["Teaching","vm","GDIP"],"tags":["tech","GDIP"]},{"title":"Spring学习笔记","url":"/2023/07/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html/","content":"Spring学习笔记源代码托管在GitHub上\n简介Spring 是一个轻量级的控制反转（IOC）和面向切面（AOP）的框架\n\n开源的、免费的\n轻量级的、非入侵式的\n控制反转、面向切面编程\n支持事务处理\n\n组成\n核心容器（Spring Core）\n　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。\n应用上下文（Spring Context）\n　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。\nSpring面向切面编程（Spring AOP）\n　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\nJDBC和DAO模块（Spring DAO）\n　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。\n对象实体映射（Spring ORM）\n　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。\nWeb模块（Spring Web）\n　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\nMVC模块（Spring Web MVC）\n　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。\n拓展现代化的Java开发，就是基于Spring开发~\n\n\nSpring Boot\n一个快速开发的脚手架\n基于SpringBoot可以快速开发单个微服务\n约定大于配置\n\n\nSpring Cloud\n基于SpringBoot实现\n\n\n\n弊端：配置繁琐，“配置地狱”\nIOC理论推导共同的部分：Dao+多个DaoImpl，Service+多个ServiceImpl\n原本的方式：Service靠程序创建实例（主动性在程序员身上）\npublic class UserServiceImpl implements UserService&#123;    private UserDao userDao = new UserDaoImpl();    @Override    public void getUser() &#123;        userDao.getUser();    &#125;&#125;\n\n\n成本高，每一次都需要手动修改源代码\n需求不能做到动态变化\n\n\nIOC的方式：Service靠set注入，由用户来创建实例（主动性在用户身上）\nprivate UserDao userDao;public void setUserDao(UserDao userDao) &#123;    this.userDao = userDao;&#125;\n\n\nIOC的本质总结来说就是依赖对象的生成方式反转，主动权来到用户手上\n\n\nDI（依赖注入）只是IOC（控制反转）的一种实现方式\nSpring中实例来自于配置或者注解\nHelloSpring使用Spring容器创建管理输出实例，具体步骤：\n\n保证原型的属性具有getter、setter\n编写配置文件或者注解（配置文件的写法：Container Overview :: Spring Framework）\n使用ClassPathXmlApplicationContext获取Java实例（其他的Bean有其相应的获取方法，比如注解对应的AnnotationConfigApplicationContext，文件对应的Filexxx）\n\n# Hello类package re.zepo;public class Hello &#123;    private String str;    public String getStr() &#123;        return str;    &#125;    public void setStr(String str) &#123;        this.str = str;    &#125;    @Override    public String toString() &#123;        return &quot;Hello&#123;&quot; +                &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n# beans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\t\thttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;hello&quot; class=&quot;re.zepo.Hello&quot; &gt;        &lt;property name=&quot;str&quot; value=&quot;Spring&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n# Test类import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class myTest &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        System.out.println(context.getBean(&quot;hello&quot;));    &#125;&#125;\n\nIOC创建对象的方式1、 通过无参构造的方式\n2、 通过有参构造的方式\n​\t1、 通过index\n​\t2、 通过类型，但是有相同的时候不适用\n​\t3、 通过参数名字\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;user&quot; class=&quot;re.zepo.pojo.User&quot;&gt;        &lt;constructor-arg index=&quot;0&quot; value=&quot;LINZEPORE&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;user2&quot; class=&quot;re.zepo.pojo.User&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;LINZEPORE&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userT&quot; class=&quot;re.zepo.pojo.UserT&quot;&gt;        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;LINZEPORE-TEST&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nIOC何时创建对象在导入配置文件的时候就已经创建了对象，何以见得呢\n可以从配置文件中配置了但是没有get出来的UserT对象得出\n#Test测试类public class zeporeTest &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        User user = (User) context.getBean(&quot;user&quot;);    &#125;&#125;# 输出结果创建了User实例~~User二号生成了实例\n\n\n另外：多个getBean也得到的同一个对象\n\nSpring配置别名alias起别名其实很简单，name-&gt;alias\n&lt;alias name=&quot;user&quot; alias=&quot;user1&quot;/&gt;\n\nbeanbean的id就是bean实例的唯一标识，class为bean对应的原型类（包名+类型），name也是别名且可以同时取多个别名\n&lt;bean id=&quot;userT&quot; class=&quot;re.zepo.pojo.UserT&quot; name=&quot;user2 u2,ut1;ut&quot;&gt;\t&lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;LINZEPORE2&quot;/&gt;&lt;/bean&gt;\n\nimport用于团队，可以导入多个配置文件，使用的时候可以使用导入的app就行\napplicationContext.xml+beans1.xml+beans2.xml+beans3.xml\n&lt;import resource=&quot;beans1.xml&quot;&gt;\n\n依赖注入（DI）首先理解依赖注入，依赖指的是配置好容器创建对象时候的必要参数（如有参构造等），注入指的就是容器创建对象的时候将这些必要的参数赋予实例。可以参考[官方的解释](Dependency Injection :: Spring Framework)：\n\nDependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean.\n\n通过Student类进行一系列简单、Bean、复杂类型（所有的类型包括：bean | ref | idref | list | set | map | props | value | null）的注入方式进行演示\nsetter注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean id=&quot;name&quot; class=&quot;re.zepo.pojo.Name&quot;&gt;        &lt;property name=&quot;CN&quot; value=&quot;林泽坡尔&quot;/&gt;        &lt;property name=&quot;EN&quot; value=&quot;Linzepore&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;address&quot; class=&quot;re.zepo.pojo.Address&quot; name=&quot;addr&quot;&gt;        &lt;property name=&quot;addr&quot; value=&quot;广轻工&quot;/&gt;        &lt;property name=&quot;zipcode&quot; value=&quot;111111&quot;/&gt;    &lt;/bean&gt;            &lt;bean id=&quot;student&quot; class=&quot;re.zepo.pojo.Student&quot;&gt;        &lt;property name=&quot;name&quot; ref=&quot;name&quot;/&gt;        &lt;property name=&quot;address&quot; ref=&quot;addr&quot; /&gt;        &lt;property name=&quot;books&quot;&gt;            &lt;array&gt;                &lt;value&gt;《CSS新世界》&lt;/value&gt;                &lt;value&gt;《Java从入门到精通》&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=&quot;hobbies&quot;&gt;            &lt;set&gt;                &lt;value&gt;唱歌&lt;/value&gt;                &lt;value&gt;跳舞&lt;/value&gt;                &lt;value&gt;写代码&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=&quot;games&quot;&gt;            &lt;list&gt;                &lt;value&gt;原神&lt;/value&gt;                &lt;value&gt;崩坏&lt;/value&gt;                &lt;value&gt;农药&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;cards&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;ID&quot; value=&quot;111111111111111111&quot;/&gt;                &lt;entry key=&quot;BANK&quot; value=&quot;12121212121212&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;info&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;school&quot;&gt;GDIP&lt;/prop&gt;                &lt;prop key=&quot;sid&quot;&gt;232323232&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;        &lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nidref是什么？一开始我以为是把对象引用的形式作为参数传入，后面一直报错：Property of &#39;re.zepo.pojo.Address&#39; type cannot be injected by &#39;String&#39;，我就纳闷了，我格式也没写错呀。。。原来人家传的是Bean的id，是bean的id名称不是bean对象实例！！！！我猜测应该是可以在Bean出现别名的时候寻找真实Bean的id吧\n拓展注入引入p命名空间(Dependencies and Configuration in Detail :: Spring Framework)：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;user&quot; class=&quot;re.zepo.pojo.User&quot; p:age=&quot;20&quot; p:name=&quot;Linzepore&quot;/&gt;&lt;/beans&gt;\n\n引入c命名空间（Dependencies and Configuration in Detail :: Spring Framework）:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;user&quot; class=&quot;re.zepo.pojo.User&quot; c:age=&quot;20&quot; c:name=&quot;Linzepore&quot;/&gt;&lt;/beans&gt;\n\nbean的作用域\n\n\nScope\nDescription\n\n\n\nsingleton\n(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nsession\nScopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\napplication\nScopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nwebsocket\nScopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\n单例模式（默认）\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot;/&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;\n\n原型模式，每次getBean都是新对象\n&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;\n\nBean的自动装配\n自动装配是Spring满足bean依赖的一种方式\nSpring会在上下文自动寻找并自动给bean装配属性\n\n在Spring有三种装配方式：\n\n在xml中显示配置【前面的例子】\njava中显式配置【后面会提】\n隐式配置中的自动装配【此处演示】\n\n隐式配置有两种方式，一种是通过名字，通过匹配参数名字与beanId，需要保证beanId唯一；另一种通过类型，需要保证需要注入的属性类型对应的bean唯一\n&lt;bean id=&quot;cat&quot; class=&quot;re.zepo.pojo.Cat&quot; /&gt;&lt;bean id=&quot;dog&quot; class=&quot;re.zepo.pojo.Dog&quot; /&gt;&lt;bean id=&quot;p1&quot; class=&quot;re.zepo.pojo.People&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;LINZEPORE&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;cat&quot; class=&quot;re.zepo.pojo.Cat&quot; /&gt;&lt;bean id=&quot;dog&quot; class=&quot;re.zepo.pojo.Dog&quot; /&gt;&lt;bean id=&quot;p1&quot; class=&quot;re.zepo.pojo.People&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;LINZEPORE&quot; /&gt;&lt;/bean&gt;\n\n使用注解实现自动装配注解在JAVA1.5，Spring2.5就开始支持了\n前提\n配置文件需要加入注解约束\n\n​\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd、xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n\n配置文件需要加入注解支持\n\n​\t&lt;context:annotation-config/&gt;\n@Autowired参考文章【Spring注解装配：@Autowired和@Resource使用及原理详解 - 知乎 (zhihu.com)】、文档【Using @Autowired :: Spring Framework】\n\n直接在属性上使用，需要已经在xml中存在该类型的bean\n在setter、constructor方法上使用，因为通过反射实现setter可以省略了\n可以@Autowired(required&#x3D;false)来允许属性为空\n当有多个类型的bean的时候\n如果有配合@Qualifier使用，会按照这个名字指定byName\n如果没有，则按照变量名进行匹配，查找name为xxx的bean\n\n\n\n弹幕提示：Autowire优先按类型，找不到就报错，找到多个则按名字，Qualifier则是在有多个类型的情况下按名字\n@Nullable表示字段可以为空\n@Autowiredpublic void setCat(@Nullable Cat cat) &#123;    this.cat = cat;&#125;\n\n\n\n@Resourcejdk11之后需要手动配置依赖导包，@Resource默认按byName自动注入，也提供按照byType 注入\n当需要指定名字的时候，可以@Resource(name=&quot;bc&quot;)\n使用注解进行开发前提准备在spring4以后要使用注解开发，要检查aop是否导入\n\n前面注解需要增加注解的支持可以换成指定包下的组件扫描（这个包下的注解支持自然就开启了）\n# 原来&lt;context:annotation-config/&gt;# 换成&lt;context:component-scan base-package=&quot;re.zepo&quot;/&gt;\n\nbean\n@Component，放在类上，说明该类受Spring管理，容器也会创建Bean，相当于&lt;bean /&gt;\n\n类名的小写会默认视为bean的id\n\n\n属性如何注入@Value，相当于&lt;property&gt;或者constructor-arg\n衍生的注解@Component有几个衍生注解，比如web开发中分层架构中对应的三个：\n\ndao：@Repository\nservice：@Service\ncontroller：@Controller\n\n自动装配@Autowired，查找现有bean进行注入\n作用域回忆在配置文件中是配置在bean字段中的，所以同样的@Scope要配在@Component附近，表示该bean受spring管理，然后注明存在的地方\n小结package re.zepo.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Scope(&quot;prototype&quot;)@Componentpublic class User &#123;    @Value(&quot;Linzepore&quot;)    public String name;    public int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    @Value(&quot;20&quot;)    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;# 测试@Testpublic void test01() &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);     User user1 = (User) context.getBean(&quot;user&quot;);    User user2 = (User) context.getBean(&quot;user&quot;);    System.out.println(user1);    System.out.println(user2);    System.out.println(user1 == user2);&#125;# 输出User&#123;name=&#x27;Linzepore&#x27;, age=20&#125;User&#123;name=&#x27;Linzepore&#x27;, age=20&#125;false\n\nxml比较万能，使用所有场合，为何方便\n注解 不是自己类使用不了，维护复杂\nxml与注解一起的最佳实践\n\nxml用来管理bean\n注解只负责完成属性的注入\n\nJavaConfig完全使用注解的方式使用spring，全权交给Java来做\n\n@Configuration相当于&lt;beans /&gt;，在&lt;beans /&gt;中可以有bean，这里的bean来自于注解下方方法的返回，相当于&lt;bean /&gt;\n\n使用配置类进行spring的配置的时候，要搭配AnnotationConfigApplicationContext进行获取上下文对象\nApplicationContext context = new AnnotationConfigApplicationContext(ZeporeConfig.class);User user = context.getBean(&quot;user&quot;, User.class);\n\n【全注解】@ComponentScan + @Component 等价于 @Configuration + @Bean（【注解加xml】&lt;context:component-scan base-package=&quot;xxx&quot;/&gt; + @Component  等价于 &lt;beans&gt;&lt;bean/&gt;&lt;/beans&gt;）\n\n@Import注解用于导入其他的配置类\n\n\n@Bean跟@Component的区别参考文章：Spring @bean 和 @component 注解有什么区别？ - 掘金 (juejin.cn)\n\n作用对象不同：@Component 注解作用于类，而 @Bean 注解作用于方法\n@Component 通常是通过路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我们需要用它的时候还给我。\n@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，只能通过 @Bean 来实现。（最重要的一点！）\n\n@Primary+@Bean@Primary用在有多个同类型Bean的时候，赋予@Atuwired的优先权\n@Configuration + @Bean@Configuration等价于&lt;beans/&gt;，@Bean等价于&lt;bean/&gt;\nUsing the @Bean Annotation :: Spring Framework；\n@ComponentScan + @Component@ComponentScan等价于&lt;context:component-scan base-package=&quot;xxx&quot;/&gt;，@Component就依然是@Component\n总结先浅浅这样理解吧，在官网看到逆天的操作，但仔细思考了很久，我就觉得是因为**@Configuration本身就是@Component、@Bean和@Component近乎同样处于低层**的缘故，但考虑到太绕，不继续深究，按照前面的理解就行，后面回来考古吧（链接：Classpath Scanning and Managed Components :: Spring Framework），附上一篇拓展的官方Java配置注解开发文档【Composing Java-based Configurations :: Spring Framework】\n静态代理代理类的要求：需要能做租客的功能，在租客功能的基础上增强，相当于套了一层，而真实业务以组合的形式由代理来决定调用（实现原业务类的实现接口 + 组合上原业务）\n我的理解代理就是要能跟真实角色能做一样的内容（实现），同时对真实角色的方法做增强（组合）\n房子租赁接口pulic interface Rent&#123;    public void rent();    &#125;\n\n房东实体public class Landlord implements Rent &#123;    @Override    public void rent() &#123;        //房东其他事务        sout(&quot;房东租出房子&quot;);        //房东其他事务    &#125;&#125;\n\n开发商实体public class Devoloper implements Rent &#123;    @Override    public void rent() &#123;        //开发商其他事务        sout(&quot;开发商租出房子&quot;);        //开发商其他事务    &#125;&#125;\n\n中介public class Proxy implements Rent &#123;    private Rent host;    public void setHost(Rent host) &#123;        this.host = host;    &#125;    @Override    public void rent() &#123;        //代理其他事务        host.rent();        //代理其他事务    &#125;&#125;\n\n测试样例@Testpublic void test01() &#123;    Rent host = new Landlord();    Proxy proxy = new Proxy();    proxy.setsetHost(host);    proxy.rent();&#125;\n\n强制代理强制代理中，可以从要实现的结果倒推类的写法，我们需要实现一种结果：客户找房东必须通过中介，没有的话会有提示。也就说明房东类中需要判断调用者是否为中介。\n房子租赁接口public interface iRent&#123;    public boolean getProxy();    public Rent rentHouse();&#125;\n\n房东类public Landlord implements iRent &#123;    private iRent proxy = null;    public boolean getProxy()&#123;        Proxy proxy_ = new Proxy();        proxy_.setProxy(this);        this.proxy = proxy_;        return this.proxy;    &#125;    public Rent rentHouse()&#123;        if(isProxy()) &#123;            sout(&quot;房东出租了房子&quot;)；        &#125; else &#123;            sout(&quot;请找中介吧&quot;)        &#125;    &#125;    public boolean isProxy() &#123;        return proxy != null;    &#125;&#125;\n\n中介类public class Proxy implements iRent &#123;    priavte iRent host;    public void setHost(iRent host) &#123;        this.host = host;    &#125;    public boolean getProxy()&#123;        return this;    &#125;;    public Rent rentHouse()&#123;        //代理其他事务        host.rentHouse();        //代理其他事务    &#125;;&#125; \n\n客户租房测试public class Client &#123;    psvm&#123;        iRent host = new Landlord();        host.rentHouse();                iRent proxy = host.getProxy();        proxy.rentHouse();    &#125;&#125;请找中介中介推销房东出租了房子中介签合同\n\n动态代理\n动态代理的代理是动态生成的，不是直接写好的\n动态代理分两大类：基于接口的动态代理、基于类的动态代理\n基于接口——jdk动态代理\n基于类——cglib\njava字节码实现\n\n\n\n动态代理主要通过Proxy.newProxyInstance实现，而其需要的三个参数分别是ClassLoader loader 、Class&lt;?&gt;[] interfaces、InvocationHandler h，代表了类加载器（InvocationHandler对象&#x2F;被代理对象 的 classLoader）、被代理对象的实现接口（new Class[]&#123;被代理对象的接口1.class, 被代理对象的接口1.class&#125; &#x2F; 被代理对象.getClass().getInterfaces()）、自己重写的InvocationHandler实例\n在使用代理模式时，需要谨慎选择类加载器，以确保代理类和被代理类能够正确加载并且能够相互访问，要保证代理对象和被代理对象在同一个类加载器中加载，ClassLoader可以是InvocationHandler对象的，也可以是被代理对象的。\n\n在实践中，可以将创建代理的过程一并写进InvocationHandler中，提供一个方法直接返回一个代理，这样在用户测试类中简洁很多，并且代理利用率高；也可以单纯重写InvocationHandler的invoke方法，这样做有助于加深理解\n演示两种方式：\n房屋租赁类\npublic interface iRent &#123;    public void rentHouse();&#125;\n\n房东类\npublic class landlord implements iRent &#123;    public void rentHouse() &#123;        sout(&quot;房东租出了房子&quot;)    &#125;;&#125;\n\n直接返回代理ProxyInvocationHandler类\npublic class ProxyInvocationHandler implements InvocationHandler &#123;    private iRent host;    public void setHost(iRent host) &#123;        this.host = host;    &#125;    public Object invoke (...) &#123;        return method.invoke(host, args);    &#125;    public Proxy getProxy() &#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(), this.host.getClass().getInterfaces(), this);    &#125;&#125;\n\n用户测试类\npublic class Client &#123;    main&#123;        iRent landlord = new Landlord();        ProxyInvocationHandler proxyInvocationHandler = new InvocationHandler();        proxyInvocationHandler.setHost(landlord);        iRent proxy = (iRent)proxyInvocationHandler.getProxy();        proxy.rentHouse();    &#125;&#125;\n\n仅做好invoke的重写ProxyInvocationHandler类\npublic proxyInvocationHandler implements InvocationHandler &#123;    private iRent host;    public void setRent(iRent host) &#123;        this.host = host;    &#125;    public Object invoke(...) &#123;        System.out.println(&quot;代理前&quot;);        Object result = method.invoke(host, args);        System.out.println(&quot;代理后&quot;);        return result;    &#125;&#125;\n\n用户测试类\npublic class Client &#123;    main&#123;        iRent landlord = new Landlord();        ProxyHandler proxyHandler = new ProxyHandler();        proxyHandler.setObj(landlord);                ClassLoader classLoader = landlord.getClass().getClassLoader();        iRent proxy = (iRent) Proxy.newProxyInstance(classLoader, landlord.getClass().getInterfaces(), proxyHandler);        proxy.rentHouse();    &#125;&#125;\n\n代理优缺点代理模式的介绍：设计模式（四）——搞懂什么是代理模式 - 知乎 (zhihu.com)\n好处\n可以是真实角色的操作更加纯粹！不同关注公共业务\n实现业务的分工，代理角色处理琐事\n公共业务发生拓展的时候方便集中管理\n\n缺点\n静态代理一个真实角色就会产生一个代理角色；\n代码量翻倍\n开发效率降低\n\nAOP实现AOP中的名词\n\n切面（Aspect）：一个关注点的模块化。以注解@Aspect的形式放在类上方，声明一个切面。自定义的增强类，也就是动态代理中的代理对象\n连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候都可以是连接点。被代理类所有的方法\n切点（Pointcut）：其实就是筛选出的连接点，匹配连接点的断言，一个类中的所有方法都是连接点，但又不全需要，会筛选出某些作为连接点做为切点。如果说通知定义了切面的动作或者执行时机的话，切点则定义了执行的地点。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。被代理类接受了增强之后的方法，加了增强\n通知（Advice）：通知增强，需要完成的工作叫做通知，就是你写的业务逻辑中需要比如事务、日志等先定义好，然后需要的地方再去用。 主要包括5个注解：Before，After，AfterReturning，AfterThrowing，Around。 @Before：在切点方法之前执行。 @After：在切点方法之后执行 @AfterReturning：切点方法返回后执行 @AfterThrowing：切点方法抛异常执行 @Around：属于环绕增强，能控制切点执行前，执行后，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解自定义的增强类中的方法，也就是横向的增强\n\n其中重要的名词有：切面（Aspect），切点（Pointcut）\n个人理解：- 横切关注点：一种增强行为的类的集合 Logs（Log1+Log2+...）- 切面：这种行为中特定的类 Log1- 通知：特定类中的增强方法- 切入点：被代理的类（接受增强的类）的方法- 连接点：被代理类的所有方法，数量大于等于切入点\n\n\n\n\n实现方式一：通过实现通知接口方式【配置 实现式切入点+增强方式（前后通知在接口实现的时候就已经确定）】\n注意：在拿bean的时候需要用接口\n引入依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n实现环绕类\n\n​\t在Spring中的AOP有6种增强方式，分别是：\n\n前置增强 (org.springframework.aop.MethodBeforeAdvice) 表示在目标方法执行前来实施增强 \n\n后置增强（org.springframework.aop.AfterAdvice）表示在目标方法执行后返回前来实施增强，这个没能用上\n\n# 会报这个错误\nException in thread &quot;main&quot; org.springframework.aop.framework.adapter.UnknownAdviceTypeException: Advice object [log.LogAfter@5ba3f27a] is neither a supported subinterface of [org.aopalliance.aop.Advice] nor an [org.springframework.aop.Advisor]\n- 环绕增强 (org.aopalliance.intercept.MethodInterceptor) 表示在目标方法执行前后同时实施增强 - 最终增强 (org.springframework.aop.AfterReturningAdvice) 表示在目标方法执行并返回后来实施增强 - 异常抛出增强 (org.springframework.aop.ThrowsAdvice) 表示在目标方法抛出异常后来实施增强 - 引介增强 (org.springframework.aop.introductioninterceptor) 表示在目标类中添加一些新的方法和属性3. 注册aop命名空间- `xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;`- `xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;`4. 配置 切入点+增强方式​\t关于pointcut的表达式写法：[spring aop中pointcut表达式完整版 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/63001123)```xml&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* 类名.*(..))&quot; /&gt;\t&lt;!-- pointcut-ref --&gt;        &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;pt&quot; /&gt;\t&lt;!-- 非pointcut-ref --&gt;        &lt;aop:advisor advice-ref=&quot;&quot; pointcut=&quot;execution(* 类名.*(..))&quot;/&gt;    &lt;/aop:config&gt;\n\n\n\n\n\n实现方式二：在配置文件引入自定义切面【切面+增强方法（前后通知在配置文件中的切面进行配置）】\n注意：在拿bean的时候需要用接口缺点是拿不到被代理的参数\n\n引入依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n自定义切面类\n\npackage log;public class LogMany &#123;    public void before() &#123;        System.out.println(&quot;======调用前======&quot;);    &#125;    public void after() &#123;        System.out.println(&quot;======调用后======&quot;);    &#125;&#125;\n\n\n配置切面以及增强通知\n\n&lt;bean id=&quot;us1&quot; class=&quot;service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log-many&quot; class=&quot;log.LogMany&quot; /&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;log-many&quot;&gt;        &lt;aop:pointcut id=&quot;userServicePT&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;userServicePT&quot;/&gt;        &lt;aop:after method=&quot;after&quot; pointcut=&quot;execution(* service.UserServiceImpl.*(..))&quot; /&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n实现方式三：注解引入自定义切面【注解实现+由spring接管bean+开启切面通知支持】\n注意：&lt;aop:aspectj-autoproxy&gt;在&lt;aop:aspectj-autoproxy&gt;的 proxy-target-class属性：JDK(默认 proxy-target-class&#x3D;”false”) cglib (proxy-target-class&#x3D;”true”)\n区别是jdk只能代理接口实现类，而cglib可以代理没有实现接口的类\n\n引入依赖\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.4&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n注解实现自定义切面类\n\n※ 环绕的注解使用\npackage log;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class LogConfig &#123;    @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;)    void before() &#123;        System.out.println(&quot;注解实现方法执行前通知&quot;);    &#125;    @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;)    void after() &#123;        System.out.println(&quot;注解实现方法执行后通知&quot;);    &#125;    @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;)    void around(ProceedingJoinPoint joinPoint) &#123;        System.out.println(&quot;注解、环绕实现方法执行前通知&quot;);        try &#123;            joinPoint.proceed();        &#125; catch (Throwable e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(&quot;注解、环绕实现方法执行后通知&quot;);    &#125;&#125;\n\n\n注册bean并开启注解支持\n\n&lt;!--  注册受代理实例  --&gt;&lt;bean id=&quot;us1&quot; class=&quot;service.UserServiceImpl&quot;/&gt;&lt;!--  加入切面类，注册实例，此时上面受代理的实例都会经过代理了  --&gt;&lt;bean id=&quot;log-config&quot; class=&quot;log.LogConfig&quot; /&gt;&lt;!--  开启注解支持  --&gt;&lt;aop:aspectj-autoproxy /&gt; &lt;!--JDK(默认 proxy-target-class=&quot;false&quot;) cglib (proxy-target-class=&quot;true&quot;)--&gt;\n\n一份参考输出：\n@Aspectpublic class AnnoLogger &#123;    @Before(&quot;execution(* service.ShopServiceImpl.*(..))&quot;)    public void before() &#123;        System.out.println(&quot;注解引入自定义切面，在方式执行前通知&quot;);    &#125;    @After(&quot;execution(* service.ShopServiceImpl.*(..))&quot;)    public void after() &#123;        System.out.println(&quot;注解引入自定义切面，在方法执行后通知&quot;);    &#125;    @Around(&quot;execution(* service.ShopServiceImpl.*(..))&quot;)    public void around(ProceedingJoinPoint proceedingJoinPoint) &#123;        System.out.println(&quot;注解引入自定义切面类，环绕中在方法的前通知&quot;);        try &#123;            Object proceed = proceedingJoinPoint.proceed();            System.out.println(&quot;proceed: &quot; + proceed);            System.out.println(&quot;proceedingJoinPoint&quot; + proceedingJoinPoint);            System.out.println(&quot;proceedingJoinPoint.getSignature&quot; + proceedingJoinPoint.getSignature());        &#125; catch (Throwable e) &#123;            throw new RuntimeException(e);        &#125;        System.out.println(&quot;注解实现自定义切面类，环绕中在方法的后面通知&quot;);    &#125;&#125;&gt;&gt;&gt;注解引入自定义切面类，环绕中在方法的前通知注解引入自定义切面，在方式执行前通知买入注解引入自定义切面，在方法执行后通知proceed: nullproceedingJoinPointexecution(void service.ShopService.buy())proceedingJoinPoint.getSignaturevoid service.ShopService.buy()注解实现自定义切面类，环绕中在方法的后面通知\n\nAOP常见问题切入点实例无法构建\n报错：Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘shopper’ defined in class path resource [ApplicationXMLContext.xml]: BeanPostProcessor before instantiation of bean failed\n\n解决：这个一般来说是因为代理类的依赖没有引入\n\n\ngetBean的时候类型错误\n报错：Exception in thread “main” org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named ‘us1’ is expected to be of type ‘service.UserServiceImpl’ but was actually of type ‘jdk.proxy2.$Proxy3’\n解决：这个是因为一般默认地使用jdk中的代理方式；如果使用注解开发可以选择代理的方式\n\n未知的通知\n报错：Exception in thread “main” org.springframework.aop.framework.adapter.UnknownAdviceTypeException: Advice object [log.LogAfter@5ba3f27a] is neither a supported subinterface of [org.aopalliance.aop.Advice] nor an [org.springframework.aop.Advisor]\n解决：像AfterAdvice这样的接口，没有可重写的，就表明不能用于直接在配置文件中声明通知，常见的第一种方式（实现接口的方式）可用的接口有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice、MethodInterceptor\n\n整合MyBatis回顾MyBatis\n配置依赖：mybatis、junit、jdbc、spring-mvc、spring-aop、mybatis-spring\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.28&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;3.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;6.0.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n配置实体类&#x2F;DAO\n\npublic class User &#123;    private String id;    private String username;    private Integer age;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nMapper接口\n\npublic interface UserMapper &#123;    public List&lt;User&gt; selectByName();&#125;\n\n\nMapper xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;    &lt;!--要跟方法名保持一致--&gt;    &lt;select id=&quot;selectByName&quot; resultType=&quot;User&quot;&gt;        select * from spring_user where username = &#x27;suzume&#x27;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n配置数据库环境相关文件，记得加上mapper\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--以包取别名，默认别名是小写类类名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;po&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_study?useSSL=false&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;pwofmysql&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;        &lt;mappers&gt;        &lt;package name=&quot;mapper&quot;/&gt;&lt;!--        &lt;mapper class=&quot;mapper.UserMapper&quot;/&gt;--&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n加入xml文件扫描支持\n\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;!--     如果加了上面的之后连配置文件都找不到了，就配置下面的       --&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;*&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n\n测试类中的步骤\n\n@Testpublic void test01() &#123;    String resource = &quot;mybatis-config.xml&quot;;    try (InputStream inputStream = Resources.getResourceAsStream(resource)) &#123;        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);        System.out.println(mapper.queryAllTeachers());        sqlSession.close();    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n常见出错找不到xml文件\n\n报错：Invalid bound statement (not found): mapper.UserMapper.selectByName\n解决：pom.xml中加入以下内容\n\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;*&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n没有注册mapper\n\n报错：Exception in thread “main” org.apache.ibatis.binding.BindingException: Type interface mapper.UserMapper is not known to the MapperRegistry.\n解决：在mybatis配置文件中注册mapper\n\n&lt;mappers&gt;    &lt;!--方法一--&gt;    &lt;package name=&quot;mapper&quot;/&gt;    &lt;!--方法二--&gt;    &lt;mapper class=&quot;mapper.UserMapper&quot;/&gt;&lt;/mappers&gt;\n\n驱动找不到\n\n报错：Loading class com.mysql.jdbc.Driver. This is deprecated. The new driver class is com.mysql.cj.jdbc.Driver. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.\n解决：mybatis配置文件中修改一下\n\n&lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;\n\n整合mybatis方法一\n原理上是改装test类，把数据源和SqlSessionFactory改到spring配置文件中，把sqlSession的操作改到接口实现类中\n\n引入依赖spring-jdbc（而不是单纯的jdbc）\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.3.23&lt;/version&gt;&lt;/dependency&gt;\n\n\n在spring配置文件中配置mybatis的DataSource，也就是原本mybatis配置文件中的那部分\n\n&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_study?useSSL=false&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;pwofmysql&quot;/&gt;&lt;/bean&gt;\n\n\n配置SqlSessionFactory（绑定数据源和mybatis位置等在mybatis配置文件的信息）\n- 数据源：`dataSource `&lt;-- `&lt;environments/&gt;`\n- mybatis位置：`configLocation` &lt;-- `Resources.getResourceAsStream()`中的位置参数\n- mapper位置：`mapperLocations` &lt;-- `&lt;mappers/&gt;`\n- 别名配置：`typeAliasesPackage` &lt;-- `&lt;typeAliases/&gt;`\n\n&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;po&quot;/&gt;&lt;/bean&gt;\n\n配置SqlSessionTemplate（等同于SqlSession）\n\n\n&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;        &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n\n检查xml文件是否并且已经接受扫描，实现Mapper接口，记得使用组合形式方便注入SqlSession\n\n​\txml规定了sql怎么写（对应的id），而Impl规定了何时执行sql\npublic class UserMapperImpl implements UserMapper&#123;    private SqlSessionTemplate sqlSessionTemplate;    public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123;        this.sqlSessionTemplate = sqlSessionTemplate;    &#125;    @Override    public List&lt;User&gt; selectByName() &#123;        return sqlSessionTemplate.getMapper(UserMapper.class).selectByName();    &#125;&#125;\n\n\n测试类\n\n&#123;\tApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);\tUserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);\tSystem.out.println(userMapper.selectByName());&#125;\n\n整合mybatis方法二\n\n引入依赖\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.28&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;3.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;6.0.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.3.23&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n编写实体类\npublic class Course &#123;    private String t_id;    private String course_name;    private Integer c_id;    @Override    public String toString() &#123;        return &quot;Course&#123;&quot; +                &quot;t_id=&#x27;&quot; + t_id + &#x27;\\&#x27;&#x27; +                &quot;, course_name=&#x27;&quot; + course_name + &#x27;\\&#x27;&#x27; +                &quot;, c_id=&quot; + c_id +                &#x27;&#125;&#x27;;    &#125;    public String getT_id() &#123;        return t_id;    &#125;    public void setT_id(String t_id) &#123;        this.t_id = t_id;    &#125;    public String getCourse_name() &#123;        return course_name;    &#125;    public void setCourse_name(String course_name) &#123;        this.course_name = course_name;    &#125;    public Integer getC_id() &#123;        return c_id;    &#125;    public void setC_id(Integer c_id) &#123;        this.c_id = c_id;    &#125;&#125;\n\n编写Mapper接口\npublic interface CourseMapper &#123;    public List&lt;Course&gt; queryAllCourses();&#125;\n\n编写Mapper对应sql语句的xml配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;mapper.CourseMapper&quot;&gt;    &lt;select id=&quot;queryAllCourses&quot; resultType=&quot;Course&quot;&gt;        select * from spring_course    &lt;/select&gt;&lt;/mapper&gt;\n\n实现Mapper接口的同时继承SqlSessionDaoSupport\npublic class CourseMapperImpl extends SqlSessionDaoSupport implements CourseMapper &#123;    @Override    public List&lt;Course&gt; queryAllCourses() &#123;        return getSqlSession().getMapper(CourseMapper.class).queryAllCourses();    &#125;&#125;\n\n编写mybatis以及spring-dao配置文件，数据源、SqlSessionFactory\n# mybatis 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--以包取别名，默认别名是小写类类名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;pojo&quot;/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;\n\n# spring-dao 配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;pwofmysql&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_study?useSSL=false&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;courseMapper&quot; class=&quot;mapper.CourseMapperImpl&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\npom文件加上扫描xml路径\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;!--     如果加了上面的之后连配置文件都找不到了，就配置下面的       --&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;*&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n测试类\n@Testpublic void test01() &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);    CourseMapper courseMapper = context.getBean(&quot;courseMapper&quot;, CourseMapper.class);    System.out.println(courseMapper.queryAllCourses());&#125;\n\nSpring声明式事务回顾事务为什么需要事务？\n\n原子性、一致性、持久性、隔离性\n要么都完成，要么都不完成\n\n声明式事务结合AOP实现整合mybatis的基础上\n\n创建事务bean，传入数据源bean\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;\n\n配置事务通知\n关于事务的传播，可以参考 7种事务的传播机制_青鱼入云的博客-CSDN博客：\n\nREQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。\nSUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。\nMANDATORY：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。\nREQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。\nNOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。\nNEVER：无事务执行，如果当前有事务则抛出Exception。\nNESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。\n\n&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;addUser&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;deleteUser&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;modifyUser&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;queryUser&quot; read-only=&quot;true&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n配置切面以及切入点\n&lt;aop:config&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* mapper.*.*(..))&quot;/&gt;&lt;/aop:config&gt;\n\n测试前，制造错误delete语句与制造前对比\n@Testpublic void test01() &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);    UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);    System.out.println(userMapper.queryUser());&#125;\n\n","categories":["SSM","Spring"],"tags":["tech","SSM"]},{"title":"厦门好玩吗","url":"/2023/07/26/%E5%8E%A6%E9%97%A8%E5%A5%BD%E7%8E%A9%E5%90%97.html/","content":"厦门好玩吗前不久去了趟厦门，感受颇深。\n有大海的魅力，有人情的韵味，我们选择跟团去，体验感极佳。\n每趟起床都是早上五六点，健康作息反倒不疲惫。\n旅行社肯定要赚钱，节约成本，剩下的其实就看导游人品了，但是有一点可以肯定：低价团肯定是不好的。\n跟团的有几个高中学生，一路很活跃，随处拍照，溢出的可爱气息让我有总自己融不入的感觉（我才20岁欸&#x2F;(ㄒoㄒ)&#x2F;~~）；导游阿姨身上的正能量让我感受到什么是”干一行爱一行“\n从不善于表达，也自然没有交集的名分，他们是真正旅途上的过客。\n传一些照片吧，以后有时间再细细更新~\n厦门北\n陈嘉庚先生和他的故居\n\n\n老院子\n\n\n\n《闽南传奇》\n\n沙蚕冻\n中山路\n夜游厦门\n\n\n鼓浪屿\n\n\n\n郑成功纪念馆\n\n\n鼓浪屿全景\n郑成功雕像\n拼音之父\n大使馆旧址\n最美转角与周杰伦MV地点\n\n阳光栈道\n一国两制沙滩\n\n\n园林植物园\n\n\n南普陀寺\n其他漂亮的地方\n\n这城市的精彩、旅行的乐趣，让我收获了高中以来丢失的孩时向往，人还是要有所明确的追求才行呀！\n","categories":["Life","XiaMen"],"tags":["life","XiaMen"]},{"title":"推荐一部纪录片《Dream Maker》（造梦者）","url":"/2023/07/28/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%83%A8%E7%BA%AA%E5%BD%95%E7%89%87%E3%80%8ADream%20Maker%E3%80%8B%EF%BC%88%E9%80%A0%E6%A2%A6%E8%80%85%EF%BC%89.html/","content":"推荐一部纪录片《Dream Maker》（造梦者）\n\n虽然还没开始工作，但是深处互联网寒冬，相信工作不会顺利，看完阿里的经历实在给人鼓舞\n我们高中期间也尝试过小型的创业，疫情打破了原来的节奏。在很长一段时间里，开始怀疑自己的未来是普普通通的程序员，还是更平凡的失业者，对未来充满无力感。但是时代就是这样的，哪个时代都有迷茫的时期，找到自己觉得可以努力的方向，不要停下脚步就行了。\n\n \n\nSARS、世贸、互联网、移动互联网、云计算，阿里就如传奇，一直在打破传统限制，银行看不起的5元交易费也促使支付宝的诞生，从纪录片中我看到：那些年，阿里是创业型的、充满活力的。\n“小二”、“亲”、花名，这些都是格局的创新，有洞见的内驱。\n\n\n\n很有味道，历史也可以因为梦想而添上一笔。\n\n","categories":["Life","Movie"],"tags":["life","movie"]},{"title":"Nginx问题解决清单","url":"/2023/08/31/nginx-issuse.html/","content":"nginx问题解决清单静态资源无法读取（403）\n原因：静态资源位于家目录\n\n解决方式：在nginx.conf文件中指定用户进行读取（参考【随笔小杂记(五)——nginx访问静态资源报错403_nginx访问静态资源403_没有顶会的咸鱼的博客-CSDN博客】）\n\n\n\n无法直接用配置文件启动nginx\n原因：没有关闭nginx\n\n解决方式：先关闭nginx\n[root@iZbp17ujkfvkf0nkixzt05Z sbin]# nginx -s stop[root@iZbp17ujkfvkf0nkixzt05Z sbin]# nginx -c /usr/local/nginx/conf/nginx.conf\n\n","categories":["Debug","Nginx"],"tags":["tech","nginx"]},{"title":"Spring Boot项目导入大量Excel数据的解决方案","url":"/2024/02/19/Spring%20Boot%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html/","content":"Spring Boot项目导入大量Excel数据的解决方案需求分析工作的时候出现一个比较特别的需求：一次性导入16万行有着17个字段的Excel表格，原本我维护的代码使用ExcelUtil实现的，但是客户使用的时候反馈：一次性导入1万条数据会直接卡住，并且数据一直增加。\n\n\n后来查看日志、自己在Windows上操作一遍，寻找相关关键词，很可能是发生了内存溢出。\n\n最后也在ExcelUtil的官方文档中得到了进一步证实:\n\n尝试解决流方式读取？一开始想着用最小的改动来完成这个变态需求，后来在写的时候才发现ExcelUtil的流方式虽然能够支持大量数据的读取但是也相应地有个致命缺点：封装性比较差！很难和Web业务结合，所以我果断选择跑路。\nEasyExcel！在网上寻找大量数据导入Excel的方法中，发现了一个神奇宝贝：EasyExcel！\n什么是Easy Excel？\nEasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。\n\n不懂？\nJava解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便\n\n怎么用？说句实话，看官方文档的例子我苦恼了很久\n导入的逻辑都是在Listener中实现的，关于导入的结果应该怎么体现呢，这让我挺困惑的，搜网一圈之后发现一篇类似的issue：\n\n导入的代码业务逻辑都在Listener中实现的，如果想返回成功多少失败多少条，应该怎么返回？\n\n\n自行在构造器传入一些变量来满足业务\n自行插入些成员变量来获得导入情况\n\n根据这个思路，我写了这个Listener\n@Slf4jpublic class DataListener extends AnalysisEventListener&lt;ImportParam&gt; &#123;    /**     *  每隔100条存储数据库，然后清理list，方便内存回收    */    private static final int BATCH_COUNT = 100;    private List&lt;Temp&gt; list = new ArrayList&lt;&gt;();    // 记录成功条数    @Getter    private int successCount;    // 记录错误信息    @Getter    private List&lt;String&gt; errorCount = new ArrayList&lt;&gt;();    private XXXService xxxService;    private HttpServletRequest request; // 根据自己业务需求传    public DataListener(XXXService xxxService, HttpServletRequest request) &#123;        this.xxxService = xxxService;        this.request = request;    &#125;    @Override    public void invoke(ImportParam tempValue, AnalysisContext context ) &#123;        // TODO        // 导入数据字段检验        if (tempValue.getName() == null || Tools.isEmpty(tempValue.getName().toString()) || Tools.isEmpty(tempValue.getName().toString())) &#123;            errorCount.add(&quot;导入数据必填项为空&quot;);            return ;        &#125;        ...                // TODO        // 这里模拟ImportParam二次封装成多个不同对象的过程，Service可能操作多个表\t\ttempValue...&gt;add        log.info(&quot;准备导入&#123;&#125;的数据：data = &#123;&#125;&quot;,add.getDataA().getName(), add.getDataA());        list.add(add);        if (list.size() &gt;= BATCH_COUNT) &#123;            saveData(request, 其他参数);            list.clear();            this.successCount+=100;        &#125;    &#125;    @Override    public void doAfterAllAnalysed(AnalysisContext context) &#123;        // TODO        // 对剩下不足100的数据进行处理        ...        saveData(phoneArray, list, adminId, request);        // 记录成功导入的数量        this.successCount += list.size();    &#125;    public void saveData(HttpServletRequest request, 其他参数)&#123;        try &#123;            Map&lt;String, String&gt; result = xxxService.daoforeachlist(其他参数, request);        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;;&#125;\n\n控制层的写法：\n@ApiOperation(value = &quot;Excel导入&quot;)   @PostMapping(value = &quot;/import&quot;)   public Result api_import_client(MultipartFile file, HttpServletRequest request)throws XXXBusinessException,Exception&#123;       try &#123;           if (EmptyUtils.isEmpty(file)) &#123;               return new Result(&quot;0&quot;, &quot;请传入文件&quot;);           &#125;                      init(request);           InputStream inputStream = file.getInputStream();                      // 构建监听器实例，传入EasyExcel、文件输入流导入数据           DataListener dataListener = new DataListener(clientService, operatorAdminId, adminId, request);           EasyExcel.read(inputStream, ImportParam.class, dataListener).sheet().doRead();                      // 通过监听器实例获取状态           List&lt;String&gt; errorCount = dataListener.getErrorCount();           int successCount = dataListener.getSuccessCount();                      // 返回导入结果           if (errorCount.isEmpty()) &#123;               return new Result&lt;&gt;(&quot;1&quot;, &quot;成功操作了&quot;+successCount+&quot;条记录&quot;);           &#125; else &#123;               log.error(&quot;出错记录：\\n&quot; + errorCount.toString());               return new Result(&quot;0&quot;, &quot;成功操作了&quot;+successCount+&quot;条记录，&quot;+errorCount.size()+&quot;条记录出错&quot;);           &#125;                  &#125; catch (Exception e) &#123;           e.printStackTrace(); return new Result(&quot;0&quot;, &quot;系统出错，操作失败&quot;);       &#125;   &#125;\n\n\n\nEasyExcel 怎么做到“再大的excel也不会出现内存溢出”的呢？我的理解是：\nEasyExcel 的设计挺巧妙的，把Listener设计成自己执行，也可以自行在构造器传入一些变量来满足业务，最重要的是可以自定义BATCH_COUNT，通过每次循环中判断列表数据是否超过了BATCH_COUNT来控制list不会过大，list不会过大，一点一点存，自然不会有内存溢出的问题了，“再大的excel也就不会出现内存溢出”~只是相当于也许会多花点时间（实际上EasyExcel比ExcelUtil快）\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"2月20到21这两天的项目维护","url":"/2024/02/21/2%E6%9C%8820%E5%88%B021%E8%BF%99%E4%B8%A4%E5%A4%A9%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4.html/","content":"2月20到21这两天的项目维护关于Git公司用的是云服务器搭建的GitLab，我遇到一个困扰挺久的问题，就是推送代码上去的时候经常出现报错：\n\n从网上寻找答案得知\n413错误码——http请求实体太大\n这要么是上传时我们这边的git有上传大小的限制，要么就是服务器那边做了限制，尝试修改本地Git上传大小限制无果之后原因就是后者了，而且GitLab大概率使用的是nginx搭建的，出于与搭建者并不熟悉的关系，只能不使用http方式上传，改用ssh。\n原因分析：上传文件太大，超过了最大限制解决方法：nginx传输限制：（nginx.conf）　　　　　　 client_max_body_size 400M;　　　　　git传输限制：　　　　　　　git config --global http.postBuffer 524288000　　　　　　　git config --global https.postBuffer 524288000\n\n关于SSH配置，网上教程很多，无非就是生成Token，然后绑定到GitLab。\n关于日志的打印mybatis日志的打印一般会放在appplication.yml文件里面，而打印级别一般没放在一起，而是放在-dev &#x2F; -prod文件（具体看application.xml的$&#123;spring.profiles.active&#125;）里面的logging项里面\n\n关于打包公司的项目不同于我在学校接触到的小项目，代码通过maven打包之后生成的是一个zip文件，里面包含了配置文件和依赖包，可以直接一键部署到服务器上，特别高效。\n完整的pom文件build配置脱敏如下：\n&lt;build&gt;\t&lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;\t&lt;plugins&gt;\t\t&lt;!-- 设置编译版本 --&gt;\t\t&lt;plugin&gt;\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\t\t\t&lt;configuration&gt;\t\t\t\t&lt;source&gt;1.8&lt;/source&gt;\t\t\t\t&lt;target&gt;1.8&lt;/target&gt;\t\t\t\t&lt;encoding&gt;UTF-8&lt;/encoding&gt;\t\t\t&lt;/configuration&gt;\t\t&lt;/plugin&gt;\t\t&lt;!-- 打包jar文件时，配置manifest文件，加入lib包的jar依赖 --&gt;\t\t&lt;plugin&gt;\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\t\t\t&lt;configuration&gt;\t\t\t\t&lt;archive&gt;\t\t\t\t\t&lt;!-- 清单文件 --&gt;\t\t\t\t\t&lt;manifest&gt;\t\t\t\t\t\t&lt;mainClass&gt;XXXApplication&lt;/mainClass&gt;\t\t\t\t\t\t&lt;!-- 打包时 MANIFEST.MF文件不记录的时间戳版本 父工程开发版本需要加,不然依赖的父工程jar引用不了--&gt;\t\t\t\t\t\t&lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;\t\t\t\t\t\t&lt;addClasspath&gt;true&lt;/addClasspath&gt;\t\t\t\t\t\t&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\t\t\t\t\t&lt;/manifest&gt;\t\t\t\t\t&lt;!-- 给清单文件添加键值对(配置文件外置) --&gt;\t\t\t\t\t&lt;manifestEntries&gt;\t\t\t\t\t\t&lt;Class-Path&gt;config/&lt;/Class-Path&gt;\t\t\t\t\t&lt;/manifestEntries&gt;\t\t\t\t&lt;/archive&gt;\t\t\t\t&lt;classesDirectory&gt;\t\t\t\t&lt;/classesDirectory&gt;\t\t\t&lt;/configuration&gt;\t\t&lt;/plugin&gt;\t\t&lt;!-- 拷贝依赖的jar包到lib目录 --&gt;\t\t&lt;plugin&gt;\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\t\t\t&lt;executions&gt;\t\t\t\t&lt;execution&gt;\t\t\t\t\t&lt;id&gt;copy&lt;/id&gt;\t\t\t\t\t&lt;phase&gt;package&lt;/phase&gt;\t\t\t\t\t&lt;goals&gt;\t\t\t\t\t\t&lt;goal&gt;copy-dependencies&lt;/goal&gt;\t\t\t\t\t&lt;/goals&gt;\t\t\t\t\t&lt;configuration&gt;\t\t\t\t\t\t&lt;outputDirectory&gt;\t\t\t\t\t\t\t$&#123;project.build.directory&#125;/lib\t\t\t\t\t\t&lt;/outputDirectory&gt;\t\t\t\t\t&lt;/configuration&gt;\t\t\t\t&lt;/execution&gt;\t\t\t&lt;/executions&gt;\t\t&lt;/plugin&gt;\t\t&lt;!-- 解决资源文件的编码问题 --&gt;\t\t&lt;plugin&gt;\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\t\t\t&lt;configuration&gt;\t\t\t\t&lt;encoding&gt;UTF-8&lt;/encoding&gt;\t\t\t\t&lt;!-- 过滤后缀文件 --&gt;\t\t\t\t&lt;nonFilteredFileExtensions&gt;\t\t\t\t\t&lt;nonFilteredFileExtension&gt;xlsx&lt;/nonFilteredFileExtension&gt;\t\t\t\t\t&lt;nonFilteredFileExtension&gt;xls&lt;/nonFilteredFileExtension&gt;\t\t\t\t\t&lt;nonFilteredFileExtension&gt;p12&lt;/nonFilteredFileExtension&gt;\t\t\t\t&lt;/nonFilteredFileExtensions&gt;\t\t\t&lt;/configuration&gt;\t\t&lt;/plugin&gt;\t\t&lt;!-- 打包source文件为zip文件 --&gt;\t\t&lt;plugin&gt;\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\t\t\t&lt;configuration&gt;\t\t\t\t&lt;descriptors&gt;\t\t\t\t\t&lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt;\t\t\t\t&lt;/descriptors&gt;\t\t\t&lt;/configuration&gt;\t\t\t&lt;executions&gt;\t\t\t\t&lt;execution&gt;\t\t\t\t\t&lt;id&gt;make-assembly&lt;/id&gt;\t\t\t\t\t&lt;phase&gt;package&lt;/phase&gt;\t\t\t\t\t&lt;goals&gt;\t\t\t\t\t\t&lt;goal&gt;single&lt;/goal&gt;\t\t\t\t\t&lt;/goals&gt;\t\t\t\t&lt;/execution&gt;\t\t\t&lt;/executions&gt;\t\t&lt;/plugin&gt;\t&lt;/plugins&gt;&lt;/build&gt;\n\n\n\n关于数据库出现0000-0000…日期错误\n报错：MySQL:[Err] 1292 - Incorrect datetime value: ‘0000-00-00 00:00:00‘ for column ‘CREATE_TIME‘\n\n在做数据迁移的时候出现了上面这个问题，应该不同的MySQL对日期初始值的设置不一样导致的，为了兼容这个问题，要把全局的sql_mode默认的NO_ZERO_DATE、NO_ZERO_IN_DATE去掉，参考博文\n然后还要记得降级新部署的MySQL版本到5.7及以下\n同时如果是Java项目，使用到jdbc时要在数据库url加上&amp;zeroDateTimeBehavior=CONVERT_TO_NULL\n\n结合 Redis 对文件判重的一个实现\n2024.02.23：今天学习到一个专业术语来描述这个效果：幂等\n\n前面对导入文件进行了优化，项目管理就提了一个问题：\n\n整个系统上传文件都限制在2M以内，调了接口就算离开页面，只要上传结束并不会对导入的数据造成影响，后端会一直处理直到数据全部导入。因此，应该规避的就是用户重复上传。结合自身能力，我选择利用Redis来实现这一简单的功能。\n我的思路是获取收到的文件的哈希值，判断该哈希是否存在于缓存中，如果是新哈希，就将其存储到Reids，缓存时间设置为6分钟，代码实现如下：\nRedis业务层主要有三个功能：判断哈希值是否已经存在、添加文件哈希进缓存、设置缓存时间\nimport java.util.concurrent.TimeUnit;@Servicepublic class FileHashServiceImpl implements FileHashService &#123;    private static final String FILE_HASH_KEY = &quot;file_hashes&quot;;    @Autowired    private RedisTemplate&lt;String, String&gt; redisTemplate;    public boolean isFileHashExists(String hash) &#123;        return Boolean.TRUE.equals(redisTemplate.opsForSet().isMember(FILE_HASH_KEY, hash));    &#125;    public void addFileHash(String hash) &#123;        redisTemplate.opsForSet().add(FILE_HASH_KEY, hash);    &#125;    // 设置文件哈希过期时间 (e.g., 24 hours)    public void setFileHashExpiration(String hash, long timeout, TimeUnit unit) &#123;        redisTemplate.expire(FILE_HASH_KEY, timeout, unit);    &#125;&#125;\n\n控制层\n// 获取文件哈希，判断是否重复上传String sha256Hex = DigestUtil.sha256Hex(file.getInputStream());if(!fileHashService.isFileHashExists(sha256Hex)) &#123;    fileHashService.addFileHash(sha256Hex);    fileHashService.setFileHashExpiration(sha256Hex, 6, TimeUnit.MINUTES);&#125; else &#123;    return new Result(&quot;0&quot;, &quot;请勿重复上传&quot;);&#125;\n\n\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"2月22-23日工作情况","url":"/2024/02/24/2%E6%9C%8822-23%E6%97%A5%E5%B7%A5%E4%BD%9C%E6%83%85%E5%86%B5.html/","content":"2月22-23日工作情况读书摘阅最近开始读一本书，阿里技术团队出的《Java开发手册（黄山版）》，希望对自己Java开发会有所帮助。\n这本书主要是介绍了阿里内部的Java开发规范，用三个级别来区别：强制、推荐、参考。\n\n6.【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 \n正例：”test”.equals(param); \n反例：param.equals(“test”); \n说明：推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b) \n\n\n8.【强制】任何货币金额，均以最小货币单位且为整型类型进行存储。\n\n\n 9.【强制】浮点数之间的等值判断，基本数据类型不能使用 &#x3D;&#x3D; 进行比较，包装数据类型不能使用 equals 进行判断。 \n说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表 示大部分的十进制小数，具体原理参考《码出高效》。 \n反例：\nfloat a &#x3D; 1.0F - 0.9F; \nfloat b &#x3D; 0.9F - 0.8F;\n if (a &#x3D;&#x3D; b) { \n​\t&#x2F;&#x2F; 预期进入此代码块，执行其它业务逻辑 \n​\t&#x2F;&#x2F; 但事实上 a &#x3D;&#x3D; b 的结果为 false \n}\nFloat x &#x3D; Float.valueOf(a); \nFloat y &#x3D; Float.valueOf(b); \nif (x.equals(y)) {\n​\t&#x2F;&#x2F; 预期进入此代码块，执行其它业务逻辑\n​\t &#x2F;&#x2F; 但事实上 equals 的结果为 false \n}\n正例：\n (1)指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的\nfloat a &#x3D; 1.0F - 0.9F;\n float b &#x3D; 0.9F - 0.8F;\n float diff &#x3D; 1e-6F;\n if (Math.abs(a - b) &lt; diff) { \n​\tSystem.out.println(“true”); \n}\n(2)使用 BigDecimal 来定义值，再进行浮点数的运算操作。 \nBigDecimal a &#x3D; new BigDecimal(“1.0”); \nBigDecimal b &#x3D; new BigDecimal(“0.9”); \nBigDecimal c &#x3D; new BigDecimal(“0.8”); \nBigDecimal x &#x3D; a.subtract(b); \nBigDecimal y &#x3D; b.subtract(c); \nif (x.compareTo(y) &#x3D;&#x3D; 0) { \n​\tSystem.out.println(“true”); \n}\n\n\n10.【强制】BigDecimal 的等值比较应使用 compareTo() 方法，而不是 equals() 方法。 \n说明：equals() 方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo() 则会忽略精度。  \n\n\n14.【强制】定义 DO &#x2F; PO &#x2F; DTO &#x2F; VO 等 POJO 类时，不要设定任何属性默认值。 反例：某业务的 DO 的 createTime 默认值为 new Date()；但是这个属性在数据提取时并没有置入具体值，在更新其 它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n\n\n16.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n\n1.【强制】日期格式化时，传入 pattern 中表示年份统一使用小写的 y。 \n说明：日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY 代表是 week in which year（JDK7 之后引入的概念）， 意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY 就是下一年。 \n正例：表示日期和时间的格式如下所示： new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”) \n反例：某程序员因使用 YYYY&#x2F;MM&#x2F;dd 进行日期格式化，2017&#x2F;12&#x2F;31 执行结果为 2018&#x2F;12&#x2F;31，造成线上故障。\n\n\n2.【强制】在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。 \n说明：日期格式中的这两对字母表意如下： \n1）表示月份是大写的 M \n2）表示分钟则是小写的 m \n3）24 小时制的是大写的 H \n4）12 小时制的则是小写的 h\n\n\n7.【强制】Collections 类返回的对象，如：emptyList() &#x2F; singletonList() 等都是 immutable list，不可 对其进行添加或者删除元素的操作。 \n反例：如果查询无结果，返回 Collections.emptyList() 空集合对象，调用方一旦在返回的集合中进行了添加元素的操 作，就会触发 UnsupportedOperationException 异常。\n\n关于注解今天在读到一篇关于幂等校验的文章时候，刚好提到用注解的区分是否进行拦截校验，打通了之前对注解用法的困惑：如果方法/类（在定义时候就已经规定好了）用到了注解，在一些拦截判断的时候就可以根据方法/类有无这个注解执行相应的逻辑了。\n注解的定义：\n\n拦截器通过注解尝试获取方法是否为空来看有没有注解：\n\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"2月26日工作内容","url":"/2024/02/27/2%E6%9C%8826%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9.html/","content":"2月26日工作内容配置代码文档模板\n实现创建新类时候自动添加注释：\n设置里面加入以下内容，位置如图：\n\n\n/** * @description: TODO  * @author $&#123;USER&#125; * @date $&#123;DATE&#125; $&#123;TIME&#125; * @version 1.0 */\n\n\n\n可以手动在旧代码基础上生成注释，按照顺序添加模板组合\n\n在模板组合填充模板信息（上图步骤5），然后编辑模板当中引用的变量（上图步骤6）\n其中，模板信息及相应变量如下：\n\n方法注释(*)\n**  * @description: $description$  * @param: $params$  * @return: $returns$  * @author $USER$ * @date: $date$ $time$ */ \n\n\n\nparams: groovyScript(&quot;def result=&#39;&#39;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#39;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&#39;&#39; + params[i] + ((i &lt; params.size() - 1) ? &#39;\\\\n&#39;:&#39;&#39;)&#125;; return result&quot;, methodParameters()) \n\nreturns: methodReturn Type()\n\nUSER: user()\n\ndate: date\n\ntime: time()\n\n\n\n类注释(**)\n** * @description: TODO * @author $user$ * @date $date$ $time$ * @version 1.0 */\n\n\n\nuser: user()\n\ndate: date\n\ntime: time()\n\n\n\n\n\n\n解决一个客户提出的空表常见问题\n干这行总会遇到客户提出的奇奇怪怪的需求，这个客户在系统刚初始化的时候表里还没有数据，员工业绩没显示出来，就提出一个需求：业绩排行榜要能看到每个人\n经过多次调试SQL语句，发现问题是出在表中初始的时候是空数据，where语句会导致查询结果直接为空\n我的解决方式：\n针对业绩排行榜没有显示每一个人的问题，放宽了SQL查询条件，原本为空的时候会因为where语句限制而查询不到，现加入 IS NULL，跟左连接、COALESCE一起配合使用，达到查询不到的时候就显示为0的效果，脱敏SQL如下：\nSELECT    admin_user_info.admin_id,    admin_user_info.name AS admin_name,    COALESCE(SUM(CASE WHEN client_under_review.del_flag = 0 THEN net_income ELSE 0 END), 0) AS total_net_incomeFROM admin_user_infoLEFT JOIN client_under_review ON client_under_review.admin_id = admin_user_info.admin_idWHERE    (client_under_review.del_flag = 0 OR client_under_review.del_flag IS NULL)\t\tAND admin_user.del_flag = 0    AND (client_under_review.xxx_date BETWEEN &#x27;2024-02-01&#x27; AND &#x27;2024-02-31&#x27; OR client_under_review.xxx_date IS NULL)GROUP BY admin_user_info.admin_id, admin_user_info.name, admin_user_info.create_timeORDER BY COALESCE(SUM(CASE WHEN client_under_review.del_flag = 0 THEN client_under_review.net_income ELSE 0 END), 0) DESC\n\n\n\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"2月27-29日工作内容","url":"/2024/02/29/2%E6%9C%8827-29%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9.html/","content":"2月27-29日工作内容今天（27号）六级放榜开始工作了之后感觉学校的事情有一些距离感了，特别是长期的游戏时间，麻木了我的紧张情绪。\n学生时代，很容易因为一点点成绩而满足，但其实学生时代的成就感，到了工作就啥也不是，在工作、在赚钱面前，并没有太大优势。\n一边工作一边复习，希望自己找回状态吧，时间不多了。\nJava兼容PHP版本加密方式公司的一个老系统原先使用PHP开发的，后来改用Java开发，接口啥的也倒是按照PHP版本的设计的，目前两套系统数据库是共用的，于是就出现了一个问题：\n\n相同的密码，PHP版本的登录得上，Java的就登陆不上\n\n查看Java服务器后台日志，发现了那个时间的错误：\n\n找到对应的行数，发现是解密过程出的错误，Java代码里面采用的是DES加解密方式，奇怪的是我用数据库中的密码尝试进行解密，却出现了跟服务器上面一样的错误。\n经过一翻折腾询问前面的后端开发得知：PHP版本的加解密方式跟Java的不一样，离了个大谱！\n这特喵怎么可能能够共用一套系统的？？\n正所谓前人挖坑，后人填。\n\n我本身只是一个Java后端，PHP逻辑我不清楚，甚至连放在那个文件都不清楚，询问他PHP的加解密Java能实现吗，给我否定的答案。当我继续追问PHP版本的加密方式是什么的时候直接不理我了。\n\n寻求前同事帮助无果，出于项目经理的要求，我只能自己在服务器用关键词查找相关的关键词，终于还是找到了。\n具体加密方式不多说，跟位运算相关，很明显Java是能实现的，于是只能写了个来过渡，维持服务正常进行吧，唉~\n好在新系统的接口保持跟PHP的接口一致我才有机会找到PHP加解密的逻辑，打工人真难。\n解决奇葩报错: “java.lang.IllegalStateException: No subdirectories found”将打包后的jar包发布到服务器之后，运行的时候出现了这个错误：\n\njava.lang.IllegalStateException: No subdirectories found for mandatory directory location ‘file:.&#x2F;config&#x2F;*&#x2F;‘.\n\n百思不得其解，GPT给的答案也解决不了，最终居然是在Bing上找到的答案，记录一下：\n\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"Web应用接入Line登录","url":"/2024/03/01/web%E5%BA%94%E7%94%A8%E6%8E%A5%E5%85%A5Line%E7%99%BB%E5%BD%95.html/","content":"Web应用接入Line登录台湾客户要求在原App的基础上接入Line登录，接入第三方登录的需求工作至今是第一次遇到（毕竟现在手上负责的两个项目都是维护阶段），好在除了登录之后业务的处理之外，登录问题顺利解决了。\n接到需求的我第一时间找的是现成的技术分享，但好像比较少，最终我还是选择一点点啃官方的纯英文文档：https://developers.line.biz/en/docs/line-login/getting-started/和https://developers.line.biz/en/docs/line-login/integrate-line-login/\n博主身在内地，所以这篇博文，是博主在内地接入Line的文档实践。\n开始之前开始之前有些特殊的名字术语解释如下，我就不翻译了，尽可能保持原汁原味：\n\n\n\nRequirement\nDescription\n\n\n\nLINE account\nAn account for the LINE app. You need a LINE account to try out the starter app. To create a LINE account, download (opens new window)LINE for iOS or LINE for Android and sign up. For more information about creating a new LINE account, see Create a new account (opens new window)(only available in Japanese) in the LINE user’s guide.\n\n\nProvider\nProvider is a concept that describes the person or organization that provides the application. Create a provider on the LINE Developers Console. A LINE user has a different user ID for each provider.\n\n\nLINE Login channel\nA channel forms the connection between your app and the LINE Platform. Create a channel within the provider. You need to create a channel for each app. Create a LINE Login channel on the LINE Developers Console. Notes:- If you’ve never logged in to the LINE Developers Console, you’ll be asked to register as a developer first.– The steps for creating your LINE Login channel are explained in Step 1: Create your LINE Login channel.- When creating a LINE Login channel to use a starter app, makes sure you select Web app under App types.\n\n\nHeroku account\nHeroku (opens new window)is a service that offers hosting for web apps. Deploying the starter app to Heroku means you don’t need your own server.\n\n\nHeroku CLI\nThe Heroku Command Line Interface (CLI) (opens new window)is necessary for using certain Heroku functions.\n\n\n就着我对文档的理解，我小小提一嘴：实际使用的时候Channel是最小单位，openId是用户在Channel唯一标识，在不同Channel当中同一个用户的openId是不同的。\n步骤一：创建Line Login ChannelChannel是应用程序与 LINE 平台连接的通道，第一步要做的就是在控制台为Web Apps创建Channel。\n\n登录Line开发者控制台\n\n选择一个Provider，并选择在Channels 选项中选择LINE Login\n\n填入必填的信息，信息的解释如下：\n\n\n\nItem\nRequired?\nDescription\nLocation displayed to users\n\n\n\nChannel type\n✅\nThe channel type. Select LINE Login to create your LINE Login Channel.\n-\n\n\nProvider\n✅\nThe channel’s provider\nPermission consent screen when launching LINE Login or LIFF App\n\n\nRegion to provide the service\n✅\nThe region you want to provide your LINE Login service. One of: JapanThailandTaiwanIndonesia*If you want to provide your service in multiple regions, create a channel for each region.\n-\n\n\nCompany or owner’s country or region\n✅\nCountry or region of the company or owner that manage the channel\nPermission consent screen when launching LINE Login or LIFF App\n\n\nChannel icon\n❌\nThe channel’s icon\nPermission consent screen when launching LINE Login or LIFF App\n\n\nChannel name\n✅\nThe channel’s name *Channel name can’t contain “LINE” or similar strings.\nPermission consent screen when launching LINE Login or LIFF App\n\n\nChannel description\n✅\nThe channel’s description\nPermission consent screen when launching LINE Login or LIFF App\n\n\nApp types\n✅\nThe type of app you plan to integrate LINE Login with. One of: Web appMobile app*In the example of deploying a starter app, select Web app.\n-\n\n\nEmail address\n✅\nEmail address to receive important updates about the channel\n-\n\n\nPrivacy policy URL\nSee description\nThe URL of the app’s privacy policy. Required if your provider is a certified provider.\nPermission consent screen when launching LINE Login or LIFF App\n\n\nTerms of use URL\n❌\nThe URL of the app’s terms of use\nPermission consent screen when launching LINE Login or LIFF App\n\n\nLINE Developers Agreement\n✅\nRead and agree to the LINE Developers Agreement (opens new window).\n-\n\n\nLY Corporation Privacy Policy\nSee description\nRequired only if you’ve selected Thailand as Region to provide the service. Read and acknowledge LY Corporation Privacy Policy (opens new window).\n-\n\n\n\n\n这一步的一些注意事项我截取原文放下来\n\n步骤二：部署starter应用接下来通过配置在第一步创建Channel的时候生成的channel ID和channel secret，就可以部署demo程序了\n\ngit克隆以下任一项目，第二个比较方便\n\n\n官方的仓库：https://github.com/line/line-login-starter，可能不能直接跑起来\n\n我调了之后可以正常跑了，并且也增加了打包成为.zip文件的配置方便部署服务器，只要修改好ymal文件里面的三个关键信息、换上本地代理软件http端口就行：https://github.com/linzepore/line-login-starter-zepore\n\n\n\n在application.yml中填入第一步创建Channel的时候生成的channel ID和channel secret\n修改com.linecorp.sample.login.infra.http.Client中的http代理端口（V2RayN的是10809）\n\n关于Java程序设置代理，可以看看这篇文章：Java配置代理\n步骤三：检查Channel设置，并填入回调地址\n进入第一步创建的Channel\n点击Basic setting选项，App types一行勾上Web app\n点击LINE Login选项，填入回调地址（跟application.yml保持一致）\n\n在demo程序中/authController就是回调用的，同时也要在application.yml中进行配置\n控制台中Basic setting选项的信息解释如下\nThe Basic settings tab contains basic information about your channel. Here’s the information you’ll find:\n\n\n\nItem\nDescription\n\n\n\nChannel ID\nUnique identifier for the channel\n\n\nRegion to provide the service\nThe region you want to provide your LINE Login service. You can only set the region when creating a new channel.\n\n\nCompany or owner’s country or region\nCountry or region of the company or owner that manage the channel\n\n\nChannel icon\nThe channel’s icon\n\n\nChannel name\nThe channel’s name\n\n\nChannel description\nThe channel’s description\n\n\nEmail address\nEmail address to receive important updates about the channel\n\n\nPrivacy policy URL\nThe URL of the app’s privacy policy\n\n\nTerms of use URL\nThe URL of the app’s terms of use\n\n\nApp types\nThe type of app you plan to integrate LINE Login with\n\n\nPermissions\nThe type of user data this channel can access\n\n\nChannel secret\nA unique secret key you can use to grant an app access to your channel\n\n\nAssertion Signing Key\nThe UUIDs associated with your assertion signing key pair\n\n\nYour user ID\nYour LINE account’s user ID\n\n\nLinked LINE Official Account\nYour LINE Official Account linked to this channel. You can only link a LINE Official Account from the same provider.\n\n\nLocalization\nYou can add other languages to provide multi-language support for your channel.\n\n\nEmail address permission\nApply for permission to request a user’s email using OpenID Connect.\n\n\nDelete\nDelete this channel.\n\n\n步骤四：尝试登录\n浏览器进入应用根地址\n\n\n\n点击按钮，通过提示完成Line登录\n\n尝试对Token进行操作：\n\nVerify the user access token\nRefresh the user access token\nRevoke the access token (log out)\n\n\n查看控制台拿到的用户信息\n\n\n步骤五：进一步配置程序关于程序的进一步配置，可以通过文档去了解不同模块的设置和效果，我就不展开了，比如设置不同的Scopes获取不同需要的信息，我把它截取出来\n\nOK，写完下班，快乐周末~\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]},{"title":"3月4~6日工作内容","url":"/2024/03/06/3%E6%9C%884~6%E6%97%A5%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9.html/","content":"3月4~6日工作内容接入Line登录与Vue前端的交互上周基本完成Line登录的接入，剩下的只有业务的处理。\n今天在写相关的业务的时候发现，Line和国内微信不太一样直接获取得到的userId就是openId，不需要通过code再次获取，但是要命的一点是Line开发者账号获取到的用户信息里面没有手机号。\n客户说只能一时间没办法认证企业Line，只能下次更新了。\n\n我就先把代码放着，捋一下后续的思路：\n\nApp通过/lineLogin/gotoauthpage请求Line登录地址，服务端获取回调信息，服务端携带用户信息重定向到App页面，App页面获取参数请求登录接口\n\n之所以要这么做，是为了防止出现跨域的问题。\n\n随之就是一个难点：在RestController通常是返回Json或者字符串，如果想要重定向到某一个地址，该怎么做。\n一个方式是通过HttpServletResponse：\n\n另一个是GPT提到的，通过HttpHeaders：\n\n这两种方式我测试都是可行的，各取所好就行。\nJava复习这段时间没有太多的bug要改，索性复习一下专业课吧。\n文件比较在写File的相关操作的时候，发现一个方法compareTo，但是作用的效果不符合预期，主要出现在这三种情况：\n\nfile1是通过相对路径创建的，file2是通过file1.getAbsolutePath()创建的：不一样\nFile f2 = new File(file.getAbsolutePath());System.out.println(&quot;比较两个文件：&quot; + file.equals(f2)); //FALSE\n\n\n\nfile1是通过相对路径创建的，file2是通过file1.getCanonicalPath()创建的：不一样\nFile f2 = new File(file.getCanonicalPath());System.out.println(&quot;比较两个文件：&quot; + file.equals(f2)); //FALSE\n\n\n\nfile1是通过相对路径的目录+文件名两步创建的，file2是通过file1.getCanonicalPath()创建的：不一样\nFile f2 = new File(file.getCanonicalPath());System.out.println(&quot;比较两个文件：&quot; + file.equals(f2)); //FALSE\n\n也就是说file1是通过相对路径创建的情况下，file2也需要是通过相对路径创建的，两者compareTo或equals的结果才会使一样。\n所以像这种情况需要比较的其实是绝对路径，即file.getAbsolutePath().equals(f2.getCanonicalPath()或者file.getCanonicalPath().equals(f2.getCanonicalPath()，又或者file.getAbsolutePath().equals(f2.getAbsolutePath()\n然后测完还看到一篇类似的文章，印证了我的想法。\n一键删除今天客户的一个需求，项目经理跟我描述时候是这样的\n\n昨晚功能来到客户这边的反馈却是：\n所以需求就变成了对现在列出客户进行批量删除，那么就需要看看获取的接口列出的数据有哪些。很这里面的数据到底有哪一些，奇怪的是这个接口请求时候携带的参数中，除了分页并没有特别明确的限制条件，难道是列出全部数据吗？\n带着这个疑问，那我就将数据库列出表里未删除的数据量跟系统现在这个区域的数量进行比较，数量是一致的，接口写完，剩下的就是前端的事情了。\n涉及这种敏感的大批量操作一定要小心再小心，客户操作的时候可以备份一下表，防止他们又反悔了。\n\n与前端发生的一些问题最近发生了一些不愉快的事情，公司新来的所谓干了三年的前端，水得一匹，装个前端环境一直抱怨着抱怨那，不是电脑不行就是网络不行。原本这跟我无关，我只需要做好自己的事情就行，可惨的是我一个后端需要跟他对接。\n一开始我抱着一种热心的成分，也刚好有空，帮他解决各种问题，结果第三天他环境还是没配好，他最后竟然一直背后跟组长说是后端的问题？？？我没跟他交接好。可是在这种情况下，我一个后端怎么可能知道前端要交接什么，真是农夫与蛇。\n那天他说他电脑要连的上我这边测试环境，我帮他在电脑用小皮配置了nginx，结果这煞毕连webpack配置不会改，一直BB说是我的问题，我真的一肚子火！！！但我忍住了，跟那组长要来前端的权限，弄完他搞了两天没搞完的前端环境，改了webpack配置甩给他看是不是后端问题。\n然后来到今天，在做需求的时候，无数据的时候给他传了空数组\n\n然后他说不行，要这样的\n\n我就纳闷了，这两个data不都是空数组吗，结果人家跟我爆了一句我没传__ob__给他，给我整无语了，我是不是还得把原型传给他？\n职场不易，如果后面还有类似情况，我就直接把他的事情反馈出来，我一实习生其实也大不了走人。\n","categories":["实习记录","Working","SpringBoot"],"tags":["tech","实习"]}]